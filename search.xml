<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[jQuery]]></title>
      <url>%2F2017%2F02%2F12%2FjQuery%2F</url>
      <content type="text"><![CDATA[jQuery 只有一个对象 （jQuery == $） 一定要搞清楚jQuery 与dom 对象之间的区别于联系dom对象：dom 对象 是浏览器自带对象，dom 对象只能调用dom 里面的属性和方法， 不能调用jQuery 对象里面的属性和方法 jQuery对象：jquery 对象是通过jQuery 包装页面上面的元素或者dom 而产生的一个新的 对象，jquery 对象时jQuery 独有的，不能调用dom 对象里面的属性和方法，jQuery 对象是一个数组。 jQuery 对象与dom 对象时可以相互转换的，转换之后它们就可以相互调用了 三种方式1234567891011$(document).ready(function()&#123; $("#dombutton").click();&#125;);$(document).ready(function()&#123; $("#dombutton").click();&#125;);jQuery().ready(function()&#123; $("#dombutton").click();&#125;); DOM转换成jQuery对象1234567//DOM获取var username = document.getElementById(&quot;username&quot;);alert(username.value);//DOM对象转换成jQuery对象:$(DOM对象)var $username = $(username);alert($username.val()); jQuery对象转换成DOM对象1234567891011//jQuery获取(定义jQuery变量,在其前面增加&quot;$&quot;.不加是可以的,但是不建议)var $username = $(&quot;#username&quot;);//jQuery对象转换成DOM对象//1 jQuery对象是一个数组对象var username = $username[0];alert(username.value);//2 jQuery提供了get(index)方法var username = $username.get(0);alert(username.value); $()：方法调用，根据正则去匹配 选择器基本选择器#one：id为one的元素.mini：class为mini的元素div：元素名为div的元素*：所有元素123456789101112131415161718192021222324252627$(document).ready(function()&#123; //&lt;input type="button" value="选择 id为 one 的元素." id="btn1"/&gt; $("#btn1").click(function()&#123; $("#one").css("background","red"); &#125;); //&lt;input type="button" value="选择 class 为 mini 的所有元素." id="btn2"/&gt; $("#btn2").click(function()&#123; $(".mini").css("background","yellow"); &#125;); //&lt;input type="button" value="选择 元素名是 div 的所有元素." id="btn3"/&gt; $("#btn3").click(function()&#123; $("div").css("background","green"); &#125;); //&lt;input type="button" value="选择 所有的元素." id="btn4"/&gt; $("#btn4").click(function()&#123; $("*").css("background","blue"); &#125;); //&lt;input type="button" value="选择 所有的span元素和id为two的元素." id="btn5"/&gt; $("#btn5").click(function()&#123; //组合选择器.. $("span,#two").css("background","blue"); &#125;);&#125;); 层级选择器(只有当前的这个方法返回的是jQuery对象才能进行链式操作)body div：body内的所有div元素body&gt;div：在body内,选择子元素是div的#one+div：id为one 的下一个div元素#two~div：id为two的元素后面的所有div兄弟元素（只有它后面的）$(&quot;#two&quot;).siblings(&quot;div&quot;)：id为two的元素的所有div兄弟元素（前面后面都包括） 1234567&lt;body&gt; &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627$(document).ready(function()&#123; //&lt;input type="button" value="选择 body内的所有div元素." id="btn1"/&gt; $("#btn1").click(function()&#123; $("body div").css("background","blue"); &#125;); //&lt;input type="button" value="在body内,选择子元素是div的。" id="btn2"/&gt; $("#btn2").click(function()&#123; $("body&gt;div").css("background","blue"); &#125;); //&lt;input type="button" value="选择 id为one 的下一个div元素." id="btn3"/&gt; $("#btn3").click(function()&#123; $("#one+div").css("background","blue"); &#125;); //&lt;input type="button" value="选择 id为two的元素后面的所有div兄弟元素." id="btn4"/&gt; $("#btn4").click(function()&#123; $("#two~div").css("background","blue"); &#125;); //&lt;input type="button" value="选择 id为two的元素的所有div兄弟元素." id="btn5"/&gt; $("#btn5").click(function()&#123; //只有当前的这个方法返回的是jQuery 对象才能进行链式操作... $("#two").siblings("div").css("background","blue"); &#125;);&#125;); 基本过滤选择器找到一堆页面元素，我们可以对这些元素加过滤条件，找到我们想要的这些元素，然后进行操作过滤条件前面添加 : 符号div:first：第一个div元素div:last：最后一个div元素div:not(&#39;.one&#39;)：class不为one的所有div元素div:even：索引值为偶数的div元素div:odd：索引值为奇数的div元素div:eq(3)：索引值等于3的元素div:gt(3)：索引值大于3的元素div:lt(3)：索引值小于3的元素:header：所有的标题元素:animated：当前正在执行动画的所有元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556$(document).ready(function()&#123; //&lt;input type="button" value="选择第一个div元素." id="btn1"/&gt; $("#btn1").click(function()&#123; $("div:first").css("background","red"); &#125;); //&lt;input type="button" value="选择最后一个div元素." id="btn2"/&gt; $("#btn2").click(function()&#123; $("div:last").css("background","green"); &#125;); //&lt;input type="button" value="选择class不为one的 所有div元素." id="btn3"/&gt; $("#btn3").click(function()&#123; $("div:not('.one')").css("background","green"); &#125;); //&lt;input type="button" value="选择索引值为偶数 的div元素." id="btn4"/&gt; $("#btn4").click(function()&#123; $("div:even").css("background","green"); &#125;); //&lt;input type="button" value="选择索引值为奇数 的div元素." id="btn5"/&gt; $("#btn5").click(function()&#123; $("div:odd").css("background","green"); &#125;); //&lt;input type="button" value="选择索引值等于3的元素." id="btn6"/&gt; $("#btn6").click(function()&#123; $("div:eq(3)").css("background","green"); &#125;); //&lt;input type="button" value="选择索引值大于3的元素." id="btn7"/&gt; $("#btn7").click(function()&#123; $("div:gt(3)").css("background","green"); &#125;); //&lt;input type="button" value="选择索引值小于3的元素." id="btn8"/&gt; $("#btn8").click(function()&#123; $("div:lt(3)").css("background","red"); &#125;); //&lt;input type="button" value="选择所有的标题元素." id="btn9"/&gt; $("#btn9").click(function()&#123; $(":header").css("background","red"); &#125;); //&lt;input type="button" value="选择当前正在执行动画的所有元素." id="btn10"/&gt; function move()&#123; $("#mover").slideToggle("slow",move); &#125; move(); $("#btn10").click(function()&#123; $(":animated").css("background","red"); &#125;); &#125;); 内容过滤选择器div:contains(&#39;di&#39;)：含有文本“di”的div元素div:empty：不包含子元素(或者文本元素)的div空元素div:has(&#39;.mini&#39;)：含有class为mini元素的div元素div:parent：含有子元素(或者文本元素)的div元素 123456789101112131415161718192021$(document).ready(function()&#123; //&lt;input type="button" value="选取含有文本“di”的div元素." id="btn1"/&gt; $("#btn1").click(function()&#123; $("div:contains('di')").css("background","red"); &#125;); //&lt;input type="button" value="选取不包含子元素(或者文本元素)的div空元素." id="btn2"/&gt; $("#btn2").click(function()&#123; $("div:empty").css("background","red"); &#125;); //&lt;input type="button" value="选取&lt;含有!&gt;class为mini元素的div元素." id="btn3"/&gt; $("#btn3").click(function()&#123; $("div:has('.mini')").css("background","red"); &#125;); //&lt;input type="button" value="选取含有子元素(或者文本元素)的div元素." id="btn4"/&gt; $("#btn4").click(function()&#123; $("div:parent").css("background","red"); &#125;); &#125;); 可见性过滤选择器div:visible：所有可见的div元素div:hidden：所有不可见的div元素input:hidden：选取所有的文本隐藏域, 并打印它们的值#onediv&gt;div：选取onediv所有的div的, 并打印它们的值 12345678910111213141516171819202122232425262728293031323334353637383940$(document).ready(function()&#123; //&lt;input type="button" value=" 选取所有可见的div元素" id="b1"/&gt; $("#b1").click(function()&#123; $("div:visible").css("background","red"); &#125;); //&lt;input type="button" value=" 选取所有不可见的元素, 利用 jQuery 中的 show() 方法将它们显示出来" id="b2"/&gt; $("#b2").click(function()&#123; $("div:hidden").css("background","red").show(2000); &#125;); //&lt;input type="button" value=" 选取所有的文本隐藏域, 并打印它们的值" id="b3"/&gt; $("#b3").click(function()&#123; // &lt;!--文本隐藏域--&gt; // &lt;input type="hidden" value="hidden_1"&gt; // &lt;input type="hidden" value="hidden_2"&gt; // &lt;input type="hidden" value="hidden_3"&gt; // &lt;input type="hidden" value="hidden_4"&gt; //var $input=$("input:hidden"); //首先我们通过dom来遍历... //1.显示迭代 // for(var i=0;i&lt;$input.length;i++)&#123; // alert($input[i].value); // &#125; //2.隐式迭代 $("input:hidden").each(function(index,dom)&#123; //alert(index); //alert(dom.value); &#125;) &#125;); //&lt;input type="button" value=" 选取onediv所有的div的, 并打印它们的值" id="b4"/&gt; $("#b4").click(function()&#123; $("#onediv&gt;div").each(function(index,dom)&#123; alert($(dom).text()); &#125;) &#125;); &#125;); 属性过滤选择器div[title]：含有属性title的div元素div[title=test]：属性title值等于“test”的div元素div[title!=test]：属性title值不等于“test”的div元素(没有属性title的也将被选中)div[title^=te]：属性title值以“te”开始的div元素div[title$=est]：属性title值以“est”结束的div元素div[title*=es]：属性title值 含有“es”的div元素div[id][title*=es]：组合属性选择器,首先选取有属性id的div元素，然后在结果中选取属性title值含有“es”的元素 12345678910111213141516171819202122232425262728293031323334353637$(document).ready(function()&#123; //&lt;input type="button" value="选取含有 属性title 的div元素." id="btn1"/&gt; $("#btn1").click(function()&#123; $("div[title]").css("background","red"); &#125;); //&lt;input type="button" value="选取 属性title值等于“test”的div元素." id="btn2"/&gt; $("#btn2").click(function()&#123; $("div[title=test]").css("background","red"); &#125;); //&lt;input type="button" value="选取 属性title值不等于“test”的div元素(没有属性title的也将被选中)." id="btn3"/&gt; $("#btn3").click(function()&#123; $("div[title!=test]").css("background","red"); &#125;); //&lt;input type="button" value="选取 属性title值 以“te”开始 的div元素." id="btn4"/&gt; $("#btn4").click(function()&#123; $("div[title^=te]").css("background","red"); &#125;); //&lt;input type="button" value="选取 属性title值 以“est”结束 的div元素." id="btn5"/&gt; $("#btn5").click(function()&#123; $("div[title$=est]").css("background","red"); &#125;); //&lt;input type="button" value="选取 属性title值 含有“es”的div元素." id="btn6"/&gt; $("#btn6").click(function()&#123; $("div[title*=es]").css("background","red"); &#125;); //&lt;input type="button" value="组合属性选择器,首先选取有属性id的div元素，然后在结果中 选取属性title值 含有“es”的元素." id="btn7"/&gt; $("#btn7").click(function()&#123; $("div[id][title*=es]").css("background","red"); &#125;); &#125;); 子元素过滤选择器冒号前一定要加空格div[class=one] :nth-child(2)：选取每个class为one的div,父元素下的第2个子元素div[class=one] :first-child：选取每个class为one的div, 父元素下的第一个子元素div[class=one] :last-child：选取每个class为one的div父元素下的最后一个子元素div[class=one] :only-child：如果class为one的div父元素下的仅仅只有一个子元素，那么选中这个子元素 12345678910111213141516171819202122232425$(document).ready(function()&#123; //&lt;input type="button" value="选取每个class为one的div,父元素下的第2个子元素." id="btn1"/&gt; $("#btn1").click(function()&#123; //子元素过滤选择器特殊写法，: 前面加空格... 从1开始计算... $("div[class=one] :nth-child(2)").css("background","red"); &#125;); //&lt;input type="button" value="选取每个class为one的div, 父元素下的第一个子元素." id="btn2"/&gt; $("#btn2").click(function()&#123; //第一种写法 //$("div[class=one] :nth-child(1)").css("background","red"); //第二种写法.. $("div[class=one] :first-child").css("background","red"); &#125;); //&lt;input type="button" value="选取每个class为one的div父元素下的最后一个子元素." id="btn3"/&gt; $("#btn3").click(function()&#123; $("div[class=one] :last-child").css("background","red"); &#125;); //&lt;input type="button" value="如果class为one的div父元素下的仅仅只有一个子元素，那么选中这个子元素." id="btn4"/&gt; $("#btn4").click(function()&#123; $("div[class=one] :only-child").css("background","red"); &#125;); &#125;); 表单对象属性过滤选择器$(&quot;input:enabled&quot;).val(&quot;&quot;);：对表单内可用input赋值操作$(&quot;input:disabled&quot;).val(&quot;卢雨&quot;);：对表单内不可用input赋值操作$(&quot;input:checked&quot;).size()：获取多选框选中的个数$(&quot;select&gt;option:selected&quot;).each()：获取下拉框选中的内容 1234567891011121314151617181920212223242526$(document).ready(function()&#123; //&lt;button id="btn1"&gt;对表单内 可用input 赋值操作.&lt;/button&gt; $("#btn1").click(function()&#123; $("input:enabled").val("卢雨"); &#125;); //&lt;button id="btn2"&gt;对表单内 不可用input 赋值操作.&lt;/button&gt; $("#btn2").click(function()&#123; $("input:disabled").val("卢雨"); &#125;); //&lt;button id="btn3"&gt;获取多选框选中的个数.&lt;/button&gt; $("#btn3").click(function()&#123; alert($("input:checked").size()); &#125;); //&lt;button id="btn4"&gt;获取下拉框选中的内容.&lt;/button&gt; $("#btn4").click(function()&#123; //alert($("select&gt;option:selected").length); $("select&gt;option:selected").each(function(index,dom)&#123; //alert($(dom).text()); var title=$(dom).attr("title"); alert(title); &#125;) &#125;); &#125;); 表单属性过滤选择器var $alltext = $(&quot;#form1 :text&quot;);：拿到表单下的文本框var $allpassword= $(&quot;#form1 :password&quot;);：拿到表单下的密码var $allradio= $(&quot;#form1 :radio&quot;);：var $allcheckbox= $(&quot;#form1 :checkbox&quot;);： var $allsubmit= $(&quot;#form1 :submit&quot;);：var $allimage= $(&quot;#form1 :image&quot;);：var $allreset= $(&quot;#form1 :reset&quot;);：var $allbutton= $(&quot;#form1 :button&quot;);：var $allfile= $(&quot;#form1 :file&quot;);：var $allhidden= $(&quot;#form1 :hidden&quot;);：var $allselect = $(&quot;#form1 select&quot;);：var $alltextarea = $(&quot;#form1 textarea&quot;);：var $AllInputs = $(&quot;#form1 :input&quot;);：var $inputs = $(&quot;#form1 input&quot;);： 123456789101112131415161718192021222324252627282930313233 $(document).ready(function()&#123; var $alltext = $("#form1 :text"); var $allpassword= $("#form1 :password"); var $allradio= $("#form1 :radio"); var $allcheckbox= $("#form1 :checkbox"); var $allsubmit= $("#form1 :submit"); var $allimage= $("#form1 :image"); var $allreset= $("#form1 :reset"); var $allbutton= $("#form1 :button"); // &lt;input type=button /&gt; 和 &lt;button &gt;&lt;/button&gt;都可以匹配 var $allfile= $("#form1 :file"); var $allhidden= $("#form1 :hidden"); // &lt;input type="hidden" /&gt;和&lt;div style="display:none"&gt;test&lt;/div&gt;都可以匹配. var $allselect = $("#form1 select"); var $alltextarea = $("#form1 textarea"); var $AllInputs = $("#form1 :input"); var $inputs = $("#form1 input"); $("div").append(" 有" + $alltext.length + " 个（ :text 元素）&lt;br/&gt;") .append(" 有" + $allpassword.length + " 个（ :password 元素）&lt;br/&gt;") .append(" 有" + $allradio.length + " 个（ :radio 元素）&lt;br/&gt;") .append(" 有" + $allcheckbox.length + " 个（ :checkbox 元素）&lt;br/&gt;") .append(" 有" + $allsubmit.length + " 个（ :submit 元素）&lt;br/&gt;") .append(" 有" + $allimage.length + " 个（ :image 元素）&lt;br/&gt;") .append(" 有" + $allreset.length + " 个（ :reset 元素）&lt;br/&gt;") .append(" 有" + $allbutton.length + " 个（ :button 元素）&lt;br/&gt;") .append(" 有" + $allfile.length + " 个（ :file 元素）&lt;br/&gt;") .append(" 有" + $allhidden.length + " 个（ :hidden 元素）&lt;br/&gt;") .append(" 有" + $allselect.length + " 个（ select 元素）&lt;br/&gt;") .append(" 有" + $alltextarea.length + " 个（ textarea 元素）&lt;br/&gt;") .append(" 表单有 " + $inputs.length + " 个（input）元素。&lt;br/&gt;") .append(" 总共有 " + $AllInputs.length + " 个(:input)元素。&lt;br/&gt;") .css("color", "red") $("form").submit(function () &#123; return false; &#125;); // return false;不能提交.&#125;); dom操作页面上面的元素分为三种类型的节点：1：元素节点 （9大选择器都是用来找元素节点）2：属性节点 （先找到元素节点，然后调用attr()）3：文本节点 (先找到元素节点然后调用text()) 节点的创建：元素节点的创建，属性节点，文本节点 查找节点12345678910111213141516171819&lt;body&gt; &lt;ul&gt; &lt;li id="bj"&gt;&lt;/li&gt; &lt;li id="tj" name="tianjin"&gt;天津&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; //元素节点的查找 //怎么查找元素节点的属性节点 alert($("#tj").attr("name")); //文本节点查找 text(); alert($("#tj").text()); //删除属性节点 $("#tj").removeAttr("name"); alert($("#tj").attr("name")); //设置属性节点 $("#tj").attr("name","tianjin") alert($("#tj").attr("name"));&lt;/script&gt; 创建节点1234567891011121314151617181920&lt;body&gt; &lt;ul id="city"&gt; &lt;li id="bj" name="beijing"&gt;北京&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; //通过jquery dom 创建&lt;li id="tj" name="tianjin"&gt;天津&lt;/li&gt; //创建元素节点 var $li=$("&lt;li&gt;&lt;/li&gt;"); //设置属性节点 $li.attr("id","tj"); $li.attr("id","tj"); //设置文本节点 $li.text("天津"); alert('a'); //获取节点 var $city=$("#city"); //往节点里面追加创建好的节点.. $city.append($li);&lt;/script&gt; 内部插入节点12345678910111213141516171819202122&lt;body&gt; &lt;ul id="city"&gt; &lt;li id="bj" name="beijing"&gt;北京&lt;/li&gt; &lt;li id="tj" name="tianjin"&gt;天津&lt;/li&gt; &lt;li id="cq" name="chongqing"&gt;重庆&lt;/li&gt; &lt;/ul&gt; &lt;ul id="love"&gt; &lt;li id="fk" name="fankong"&gt;反恐&lt;/li&gt; &lt;li id="xj" name="xingji"&gt;星际&lt;/li&gt; &lt;/ul&gt; &lt;div id="foo1"&gt;Hello1&lt;/div&gt; &lt;/body&gt;&lt;script type="text/javascript"&gt; //append(content):向每个匹配的元素的内部的结尾处追加内容 $("#bj").append($("#fk")); //appendTo(content):将每个匹配的元素追加到指定的元素中的内部结尾处 $("#bj").appendTo($("#fk")); //prepend(content):向每个匹配的元素的内部的开始处插入内容 $("#bj").prepend($("#fk")); //prependTo(content):将每个匹配的元素插入到指定的元素内部的开始处 $("#bj").prependTo($("#fk"));&lt;/script&gt; 外部插入节点123456789101112131415161718&lt;body&gt; &lt;ul id="city"&gt; &lt;li id="bj" name="beijing"&gt;北京&lt;/li&gt; &lt;li id="tj" name="tianjin"&gt;天津&lt;/li&gt; &lt;li id="cq" name="chongqing"&gt;重庆&lt;/li&gt; &lt;/ul&gt; &lt;p id="p3"&gt;I would like to say: p3&lt;/p&gt; &lt;p id="p2"&gt;I would like to say: p2&lt;/p&gt; &lt;p id="p1"&gt;I would like to say: p1&lt;/p&gt; &lt;/body&gt;&lt;script type="text/javascript"&gt; // 在每个匹配的元素之后插入内容 // $("#bj").after($("#p3")); // 在每个匹配元素 的前面插入内容 // $("#bj").before($("#p3")); // $("#bj").insertAfter($("#p3")); $("#bj").insertBefore($("#p3"));&lt;/script&gt; 删除节点123456789101112&lt;body&gt; &lt;ul id="city"&gt; &lt;li id="bj" name="beijing"&gt;北京&lt;p&gt;海淀区&lt;/p&gt;&lt;/li&gt; &lt;li id="tj" name="tianjin"&gt;天津&lt;p&gt;河西区&lt;/p&gt;&lt;/li&gt; &lt;li id="cq" name="chongqing"&gt;重庆&lt;/li&gt; &lt;/ul&gt; &lt;p class="hello"&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt; &lt;/body&gt;&lt;script type="text/javascript"&gt; //$("#bj").remove(); $("#city").remove(); &lt;/script&gt; 复制节点123456789101112&lt;body&gt; &lt;button&gt;保存&lt;/button&gt;&lt;br&gt; &lt;p&gt;段落&lt;/p&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; //button增加事件 $("button").click(function()&#123; $("p").append($("button").clone(true)); &#125;); // clone 克隆某个元素的副本，但是这个副本不具备任何的行为，不具备任何的时间 // 如果需要把时间也克隆过去，需要在clone(true));&lt;/script&gt; 替换节点1234567891011&lt;html&gt; &lt;p&gt;段落&lt;/p&gt; &lt;p&gt;段落&lt;/p&gt; &lt;p&gt;段落&lt;/p&gt; &lt;button&gt;保存&lt;/button&gt;&lt;/html&gt;&lt;script type="text/javascript"&gt; // 将所有匹配的元素都替换为指定的 HTML 或 DOM 元素 // $("button").replaceWith($("p")); $("button").replaceAll($("p"));&lt;/script&gt; 样式操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;head&gt; &lt;style type="text/css"&gt; .one&#123; width: 200px; height: 140px; margin: 40px; background: red; border: #000 1px solid; float:left; font-size: 17px; font-family:Roman; &#125; div,span&#123; width: 140px; height: 140px; margin: 20px; background: #9999CC; border: #000 1px solid; float:left; font-size: 17px; font-family:Roman; &#125; div.mini&#123; width: 30px; height: 30px; background: #CC66FF; border: #000 1px solid; font-size: 12px; font-family:Roman; &#125; &lt;/style&gt;&lt;/head&gt;&lt;script type="text/javascript"&gt;//&lt;input type="button" value="采用属性增加样式" id="b1"/&gt; $("#b1").click(function()&#123; $("#mover").css("background","red"); &#125;); //&lt;input type="button" value=" addClass" id="b2"/&gt; $("#b2").click(function()&#123; $("#mover").addClass("mini"); &#125;);//&lt;input type="button" value="removeClass" id="b3"/&gt; $("#b3").click(function()&#123; /* * removeClass(): * * 不传参数:删除所有样式 * * 传递参数:删除指定样式 */ $("#mover").removeClass(); //$("#mover").removeClass(); &#125;);//&lt;input type="button" value=" 切换样式" id="b4"/&gt; $("#b4").click(function()&#123; $("#mover").toggleClass("one"); &#125;);//&lt;input type="button" value=" hasClass" id="b5"/&gt; $("#b5").click(function()&#123; //hasClass():判断某个元素是否含有某个指定样式 $("#mover").addClass("mini"); alert($("#mover").hasClass("mini")); &#125;);&lt;/script&gt; 遍历节点123456789101112131415161718192021&lt;body&gt; &lt;ul id="city"&gt; &lt;li id="bj" name="beijing"&gt;北京&lt;/li&gt; &lt;li id="tj" name="tianjin"&gt;天津&lt;/li&gt; &lt;li id="nj" name="nanjing"&gt;南京&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;script type="text/javascript"&gt; // 该方法只考虑子元素而不考虑任何后代元素. // alert($("#city").children().length); // 取得相邻元素的下一个同级元素 // alert($("#bj").next().text()); // alert($("#tj").prev().text()); // alert($("#bj").siblings().length); //find //选获取元素通过find 找到对应的标签的子元素的集合... alert($("#city").find("li").length);&lt;/script&gt; 包裹节点123456789101112&lt;body&gt; &lt;strong title="jQuery"&gt;jQuery&lt;/strong&gt; &lt;strong title="jQuery"&gt;jQuery&lt;/strong&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; //jQuery代码如下： // $("strong").wrap("&lt;b&gt;&lt;/b&gt;"); $("strong").wrapAll("&lt;b&gt;&lt;/b&gt;"); &lt;br&gt;&lt;&lt;strong title="jQuery"&gt;jQuery&lt;/strong&gt; &lt;strong title="jQuery"&gt;jQuery&lt;/strong&gt;&lt;/br&gt;&lt;/script&gt; 总结123456789101112131415161718192021222324252627282930313233* DOM操作：jQuery中封装DOM(对比原生DOM的使用方法) * 查找节点： * 元素节点：所有的选择器 * 文本节点：text() * 属性节点： * attr() * removeAttr() * 创建节点； * 元素节点：$(HTML代码) * 文本节点：text() * 属性节点：attr() * 插入：内部与外部 * 删除节点： * remove()：删除自身节点及后代节点 * empty()：删除后代节点，自身节点保留（清空） * 复制节点： * jQuery的clone(Boolean)：表示是否复制事件。 * js的cloneNode(Boolean)：表示是否复制后代节点。 * 替换节点： * replaceWith()：前面的元素是被替换元素;后面的元素是替换元素 * replaceAll()：就是颠倒了的replaceWith() * html()方法：直接操作HTML代码（等价于innerHTML属性） * 遍历节点： * 子节点：children() * 父节点：parent() * 上一个兄弟节点：prev() * 下一个兄弟节点：next() * 所有兄弟节点：siblings() * find()：通用遍历方法 * 包裹节点： * wrap()：分别包裹 * wrapAll()：一起包裹 * wrapInner()：包裹内部 绑定与解绑事件12345678910//页面加载完毕执行 window.onload=function()&#123;&#125;//页面加载完毕执行 $(function()&#123;&#125;)$().ready(function()&#123;&#125;) 区别：window.onload与$(function(){})都是用来作于界面渲染完毕之后的初始化操作。 window.onload需要等待页面上面所有的元素都绘制完毕之后才执行，包含图片。$(function(){})页面上面所有的dom元素绘制完毕之后就执行，不包含图片。 getscript和getjsonjQuery的异步提交表单12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jQuery异步提交表单&lt;/title&gt; &lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt; &lt;meta http-equiv="description" content="this is my page"&gt; &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"&gt; &lt;script type="text/javascript" src="../../js/jquery-1.4.2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; $("#formbutton").click(function()&#123; // 发送异步的ajax 请求 // 将表单里面的选项序列化成一个数组... //var data=$("#form1").serialize(); var data=$("#form1").serializeArray(); // 可以打印对象里面更加详细的信息 console.info(data); for(var i=0;i&lt;data.length;i++)&#123; alert(data[i].name); alert(data[i].value); &#125; $.ajax(&#123; url:"../../formServlet", //通过ajax方法提交的时候有两种数据格式(字符串/json) data:data, type:"POST", success:function(data)&#123; &#125; &#125;) &#125;) &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form id="form1"&gt; 用户名：&lt;input type="text" name="username" id="username"&gt;&lt;br&gt;&lt;br&gt; 密&amp;nbsp;&amp;nbsp;码：&lt;input type="password" name="password" id="password"&gt;&lt;br&gt;&lt;br&gt; 邮&amp;nbsp;&amp;nbsp;箱：&lt;input type="text" name="email" id="email"&gt;&lt;br&gt;&lt;br&gt; &lt;input type="button" value="异步提交表单" id="formbutton"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; jQuery的ajax load交互1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;ajax 异步加载...&lt;/title&gt; &lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt; &lt;meta http-equiv="description" content="this is my page"&gt; &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"&gt; &lt;!--当用户第一次访问界面的时候我们不需要加载页面上面所有的资源,当用户想看的时候去加载...--&gt; &lt;script type="text/javascript" src="../../js/jquery-1.4.2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(window).scroll(function()&#123; var t=document.documentElement.scrollTop; if(t&gt;0 &amp;&amp; t&lt;800)&#123; loadImage("1"); &#125; if(t&gt;800 &amp;&amp; t&lt;1600)&#123; loadImage("2"); &#125; if(t&gt;1600 &amp;&amp; t&lt;2400)&#123; loadImage("3"); &#125; if(t&gt;2400 &amp;&amp; t&lt;3200)&#123; loadImage("4"); &#125; if(t&gt;3200 &amp;&amp; t&lt;4000)&#123; loadImage("5"); &#125; if(t&gt;4000 &amp;&amp; t&lt;4800)&#123; loadImage("6"); &#125; function loadImage(imageType)&#123; $.ajax(&#123; url:"../../imageServlet", type:"POST", data:&#123; imageType:imageType &#125;, success:function(data)&#123; var area="#area_"+imageType; var image="&lt;img src='../../"+data+"'&gt;"; $(area).html(image); &#125; &#125;) &#125; &#125;) &lt;/script&gt; &lt;style type="text/css"&gt; #message&#123; height:4800px; &#125; #message div&#123; height:800px; border:30px solid red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="message"&gt; &lt;div id="area_1"&gt;&lt;/div&gt; &lt;div id="area_2"&gt;&lt;/div&gt; &lt;div id="area_3"&gt;&lt;/div&gt; &lt;div id="area_4"&gt;&lt;/div&gt; &lt;div id="area_5"&gt;&lt;/div&gt; &lt;div id="area_6"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; jQuery的插件扩展1.全局方法的插件$.validateUsername(&quot;&quot;)1234567891011&lt;script type="text/javascript"&gt; $.extend(&#123; Constants:&#123; baseURL:"http://localhost:8080/jQuery" &#125;, validateTelephone:function(tel)&#123; alert(tel); $Constants.baseURL &#125; &#125;)&lt;/script&gt; 2.局部方法的插件$(&quot;#datagrid&quot;).datagrid({})123456789&lt;script type="text/javascript"&gt; $.fn.extend(&#123; datagrid:function(obj)&#123; var columns=obj.columns; var tr="&lt;tr&gt;"; ...... &#125; &#125;)&lt;/script&gt; 3.选择器插件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PageHelper分页]]></title>
      <url>%2F2017%2F02%2F11%2FPageHelper%E5%88%86%E9%A1%B5%2F</url>
      <content type="text"><![CDATA[前些天按照视频里讲的做一个分页功能，可是不知道什么原因在页面就是不显示数据。昨天碰巧发现了一个分页插件，只需一些设置就可以完成分页，非常方便。不过由于是新手，其中遇到了很多很多麻烦，不过幸好得到大神的帮助，最终完成了功能，非常感谢他十分耐心地帮我，给你一个么么哒(づ￣ 3￣)づ没想到做一个小小的分页功能也有这么多的不懂的地方，感觉要学的东西太多太多，加油努力学习吧~ 首先给出项目Github地址：Mybatis通用分页插件然后按步骤给出各部分代码（其他无关代码和配置文件省略） SqlMapConfig.xml此处要导入两个jar包：pagehelper-5.0.0.jar和jsqlparser-0.9.5.jar1234567&lt;!-- 配置分页插件 --&gt;&lt;plugins&gt; &lt;plugin interceptor="com.github.pagehelper.PageHelper"&gt; &lt;!-- 指定数据库方言 --&gt; &lt;property name="dialect" value="mysql"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; poCountry.java1234567891011121314151617181920212223242526272829public class Country &#123; private Integer id; private String countryname; private String countrycode; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getCountryname() &#123; return countryname; &#125; public void setCountryname(String countryname) &#123; this.countryname = countryname == null ? null : countryname.trim(); &#125; public String getCountrycode() &#123; return countrycode; &#125; public void setCountrycode(String countrycode) &#123; this.countrycode = countrycode == null ? null : countrycode.trim(); &#125; @Override public String toString() &#123; // return (this.getId()+" "+this.getCountryname()+" "+this.getCountrycode()); return "Country [id=" + id +", countryname=" + countryname + ", countrycode=" + countrycode + "]"; &#125;&#125; EasyUIDataGridResult.java123456789101112131415161718public class EasyUIDataGridResult &#123; // easyUI dataGrid 返回结果封装 Long total; // 总的记录数 List&lt;?&gt; rows; // 数据集 public Long getTotal() &#123; return total; &#125; public void setTotal(Long total) &#123; this.total = total; &#125; public List&lt;?&gt; getRows() &#123; return rows; &#125; public void setRows(List&lt;?&gt; rows) &#123; this.rows = rows; &#125;&#125; serviceCountryService.java123public interface CountryService &#123; public EasyUIDataGridResult getCountryList(int page, int rows);&#125; CountryServiceImpl.java1234567891011121314151617181920212223242526@Servicepublic class CountryServiceImpl implements CountryService&#123; @Autowired private CountryMapper countryMapper; public EasyUIDataGridResult getCountryList(int page, int rows) &#123; //分页处理 PageHelper.startPage(page, rows); //查询结果 CountryExample example = new CountryExample(); List&lt;Country&gt; list = countryMapper.selectByExample(example); //获取分页信息 PageInfo&lt;Country&gt; info = new PageInfo&lt;&gt;(list); EasyUIDataGridResult result = new EasyUIDataGridResult(); long total = info.getTotal(); //封装分页信息 List&lt;Country&gt; row = info.getList(); result.setRows(row); result.setTotal(total); return result; &#125;&#125; controllerCountryController.java123456789101112@Controllerpublic class CountryController &#123; @Autowired private CountryService countryService; @RequestMapping("/country/list") @ResponseBody private EasyUIDataGridResult getItemList(Integer page, Integer rows)&#123; EasyUIDataGridResult countrylists = countryService.getCountryList(page,rows); return countrylists; &#125;&#125; springmvc.xml在原来的基础上增加json convertors，以便将List集合转换成json对象，可以使用fastjson或者jackson库，二者择其一就好注意Jar的版本，我选择的是jackson-core-2.8.7.jar jackson-databind-2.8.7.jar jackson-annotations-2.8.7.jar，三者缺一不可，而且不同的版本可能会导致一些异常123456&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"/&gt; &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"/&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; jspcountryList.jsp123456789101112131415161718192021222324252627282930313233&lt;%@ page contentType="text/html;charset=UTF-8" language="java" pageEncoding="UTF-8" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;列表分页展示&lt;/title&gt; &lt;!--必须引入jQuery和easyUI库--&gt; &lt;link rel="stylesheet" type="text/css" href="../js/jquery-easyui-1.4.1/themes/default/easyui.css" /&gt; &lt;link rel="stylesheet" type="text/css" href="../js/jquery-easyui-1.4.1/themes/icon.css" /&gt; &lt;link rel="stylesheet" type="text/css" href="../css/taotao.css" /&gt; &lt;script type="text/javascript" src="../js/jquery-easyui-1.4.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/jquery-easyui-1.4.1/jquery.easyui.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/jquery-easyui-1.4.1/locale/easyui-lang-zh_CN.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/common.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table id="dg"&gt;&lt;/table&gt; &lt;/body&gt; &lt;script&gt; $(document).ready(function () &#123; $('#dg').datagrid(&#123; url:'/country/list', pagination: true, columns:[[ &#123;field:'id',title:'id',width:100&#125;, &#123;field:'countryname',title:'国家名称',width:100,align:'center'&#125;, &#123;field:'countrycode',title:'国家代码',width:100,align:'center'&#125; ]] &#125;); &#125;); &lt;/script&gt;&lt;/html&gt; 最后成果如下所示~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax]]></title>
      <url>%2F2017%2F02%2F11%2Fajax%2F</url>
      <content type="text"><![CDATA[AJAX应用的五个步骤 建立XMLHttpRequest对象 设置回调函数 使用open方法与服务器建立连接 向服务器端发送数据 在回调函数针对不同响应状态进行处理 小练习 去参数 检查参数是否有问题 校验操作 这一步需要将用户感兴趣的数据返回给页面端，而不是将一个新的页面发送给用户 文本格式AJAXServer.java12345678910111213141516171819202122232425262728293031public class AJAXServer extends HttpServlet&#123; protected void doPost(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException &#123; doGet(httpServletRequest, httpServletResponse); &#125; protected void doGet(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException &#123; try&#123; httpServletResponse.setContentType("text/html;charset=utf-8"); PrintWriter out = httpServletResponse.getWriter(); // 1.取参数 String old = httpServletRequest.getParameter("name"); // 2.检查参数是否有问题 if (old == null || old.length() == 0) &#123; out.println("用户名不能为空"); &#125; else &#123; // 3.校验操作 String name = old; if (name.equals("wangxingkui")) &#123; //4.和传统应用不同之处。这一步需要将用户感兴趣的数据返回给页面段，而不是将一个新的页面发送给用户 //写法没有变化，本质发生了改变 out.println("用户名[" + name + "]已经存在，请使用其他用户名, " + temp); &#125; else &#123; out.println("用户名[" + name + "]尚未存在，可以使用该用户名注册, " + temp); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; verify.js12345678910111213141516171819202122//定义用户名校验的方法function verify()&#123; // 1.获取文本框中的内容 var jqueryObj = $("#userName"); //获取节点的值 var userName = jqueryObj.val(); // 2.将文本框中的数据发送给服务器段的servlet //使用jquery的XMLHTTPrequest对象get请求的封装：get(url,data,callback) $.get("AJAXServer?name=" + userName,null,callback);&#125;//回调函数function callback(data) &#123; // 3.接收服务器端返回的数据 alert(data); // 4.将服务器段返回的数据动态的显示在页面上 //找到保存结果信息的节点 var resultObj = $("#result"); //动态的改变页面中div节点中的内容 resultObj.html(data);&#125; jQuery的总结与简化调用123456789101112131415161718// 复杂版本function verify() &#123; //解决中文乱码问题的方法1，页面端发出的数据作一次encodeURI，服务器段使用new String(old.getBytes("iso8859-1"),"UTF-8"); //解决中文乱码问题的方法2，页面端发出的数据作两次encodeURI，服务器段使用URLDecoder.decode(old,"UTF-8") var url = "AJAXServer?name=" + encodeURI(encodeURI($("#userName").val())); url = convertURL(url); $.get(url,null,function(data)&#123; $("#result").html(data);&#125;);&#125;// 简化版本function verify() &#123; $.get("AJAXServer?name=" + $("#userName").val(),null,function(data)&#123; $("#result").html(data); &#125;);&#125; XHR对象的创建12345678910111213141516171819202122232425262728293031323334353637var xmlhttp;function verify() &#123; // 0.使用dom的方式获取文本框中的值 var userName = document.getElementById("userName").value; // 1.创建XMLHttpRequest对象 //这是XMLHttpReuquest对象无部使用中最复杂的一步，需要针对IE和其他类型的浏览器建立这个对象的不同方式写不同的代码 if (window.XMLHttpRequest) &#123; //针对FireFox，Mozillar，Opera，Safari，IE7，IE8 xmlhttp = new XMLHttpRequest(); //针对某些特定版本的mozillar浏览器的BUG进行修正 if (xmlhttp.overrideMimeType) &#123; xmlhttp.overrideMimeType("text/xml"); &#125; &#125; else if (window.ActiveXObject) &#123; //针对IE6，IE5.5，IE5 //两个可以用于创建XMLHTTPRequest对象的控件名称，保存在一个js的数组中 //排在前面的版本较新 var activexName = ["MSXML2.XMLHTTP","Microsoft.XMLHTTP"]; for (var i = 0; i &lt; activexName.length; i++) &#123; try&#123; //取出一个控件名进行创建，如果创建成功就终止循环 //如果创建失败，回抛出异常，然后可以继续循环，继续尝试创建 xmlhttp = new ActiveXObject(activexName[i]); break; &#125; catch(e)&#123; &#125; &#125; &#125; //确认XMLHTtpRequest对象创建成功 if (!xmlhttp) &#123; alert("XMLHttpRequest对象创建失败!!"); return; &#125; else &#123; alert(xmlhttp.readyState); &#125;&#125; 使用XHR对象发送和接受数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//--------------------------------------------------------------------------------------------第一步的代码var xmlhttp;function verify() &#123; // 0.使用dom的方式获取文本框中的值 var userName = document.getElementById("userName").value; // 1.创建XMLHttpRequest对象 //这是XMLHttpReuquest对象无部使用中最复杂的一步，需要针对IE和其他类型的浏览器建立这个对象的不同方式写不同的代码 if (window.XMLHttpRequest) &#123; //针对FireFox，Mozillar，Opera，Safari，IE7，IE8 xmlhttp = new XMLHttpRequest(); //针对某些特定版本的mozillar浏览器的BUG进行修正 if (xmlhttp.overrideMimeType) &#123; xmlhttp.overrideMimeType("text/xml"); &#125; &#125; else if (window.ActiveXObject) &#123; //针对IE6，IE5.5，IE5 //两个可以用于创建XMLHTTPRequest对象的控件名称，保存在一个js的数组中 //排在前面的版本较新 var activexName = ["MSXML2.XMLHTTP","Microsoft.XMLHTTP"]; for (var i = 0; i &lt; activexName.length; i++) &#123; try&#123; //取出一个控件名进行创建，如果创建成功就终止循环 //如果创建失败，回抛出异常，然后可以继续循环，继续尝试创建 xmlhttp = new ActiveXObject(activexName[i]); break; &#125; catch(e)&#123; &#125; &#125; &#125; //确认XMLHTtpRequest对象创建成功 if (!xmlhttp) &#123; alert("XMLHttpRequest对象创建失败!!"); return; &#125; else &#123; alert(xmlhttp.readyState); &#125;//--------------------------------------------------------------------------------------------第一步的代码 // 2.注册回调函数 //注册回调函数时，之需要函数名，不要加括号 //我们需要将函数名注册，如果加上括号，就会把函数的返回值注册上，这是错误的 xmlhttp.onreadystatechange = callback; // 3.设置连接信息 //第一个参数表示http的请求方式，支持所有http的请求方式，主要使用get和post //第二个参数表示请求的url地址，get方式请求的参数也在url中 //第三个参数表示采用异步还是同步方式交互，true表示异步 xmlhttp.open("GET","AJAXServer?name="+ userName,true); //POST方式请求的代码 //xmlhttp.open("POST","AJAXServer",true); //POST方式需要自己设置http的请求头 //xmlhttp.setRequestHeader("Content-Type","application/x-www-form-urlencoded"); //POST方式发送数据 //xmlhttp.send("name=" + userName); // 4.发送数据，开始和服务器端进行交互 //同步方式下，send这句话会在服务器段数据回来后才执行完 //异步方式下，send这句话会立即完成执行 xmlhttp.send(null);&#125;//回调函数function callback() &#123; // 5.接收响应数据 //判断对象的状态是交互完成 if (xmlhttp.readyState == 4) &#123; //判断http的交互是否成功 if (xmlhttp.status == 200) &#123; //获取服务器端返回的数据 //获取服务器端输出的纯文本数据 var responseText = xmlhttp.responseText; //将数据显示在页面上 //通过dom的方式找到div标签所对应的元素节点 var divNode = document.getElementById("result"); //设置元素节点中的html内容 divNode.innerHTML = responseText; &#125; else &#123; alert("出错了！！！"); &#125; &#125;&#125; xml格式（利用XHR接受和处理XML数据）AJAXXMLServer.java123456789101112131415161718192021222324252627282930313233343536373839public class AJAXXMLServer extends HttpServlet&#123; protected void doPost(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException &#123; doGet(httpServletRequest, httpServletResponse); &#125; protected void doGet(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException &#123; try&#123; //修改点1111111111111111111111111111111----响应的Content-Type必须是text/xml httpServletResponse.setContentType("text/xml;charset=utf-8"); PrintWriter out = httpServletResponse.getWriter(); //1.取参数 String old = httpServletRequest.getParameter("name"); //修改点2222222222222222222222222222222-----返回的数据需要拼装成xml格式 StringBuilder builder = new StringBuilder(); builder.append("&lt;message&gt;"); //2.检查参数是否有问题 if(old == null || old.length() == 0)&#123; builder.append("用户名不能为空").append("&lt;/message&gt;"); &#125; else&#123; //3.校验操作 String name = old; if(name.equals("wangxingkui"))&#123; //4。和传统应用不同之处。这一步需要将用户感兴趣的数据返回给页面段，而不是将一个新的页面发送给用户 //写法没有变化，本质发生了改变 builder.append("用户名[" + name + "]已经存在，请使用其他用户名").append("&lt;/message&gt;"); &#125; else&#123; builder.append("用户名[" + name + "]尚未存在，可以使用该用户名注册").append("&lt;/message&gt;"); &#125; out.println(builder.toString()); System.out.println(builder.toString()); &#125; &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; verifyxml.js12345678910111213141516171819202122232425262728293031323334353637function callback() &#123; //alert(xmlhttp.readyState); // -----------------5.接收响应数据----------------- //判断对象的状态是交互完成 if (xmlhttp.readyState == 4) &#123; //判断http的交互是否成功 if (xmlhttp.status == 200) &#123; //使用responseXML的方式来接收XML数据对象的DOM对象 var domObj = xmlhttp.responseXML; if (domObj) &#123; //&lt;message&gt;123123123&lt;/message&gt; //dom中利用getElementsByTagName可以根据标签名来获取元素节点，返回的是一个数组 var messageNodes = domObj.getElementsByTagName("message"); if (messageNodes.length &gt; 0) &#123; //获取message节点中的文本内容 //message标签中的文本在dom中是message标签所对应的元素节点的字节点，firstChild可以获取到当前节点的第一个子节点 //通过以下方式就可以获取到文本内容所对应的节点 var textNode = messageNodes[0].firstChild; //对于文本节点来说，可以通过nodeValue的方式返回文本节点的文本内容 var responseMessage = textNode.nodeValue; //将数据显示在页面上 //通过dom的方式找到div标签所对应的元素节点 var divNode = document.getElementById("result"); //设置元素节点中的html内容 divNode.innerHTML = responseMessage; &#125; else &#123; alert("XML数据格式错误，原始文本内容为：" + xmlhttp.responseText); &#125; &#125; else &#123; alert("XML数据格式错误，原始文本内容为：" + xmlhttp.responseText); &#125; &#125; else &#123; alert("出错了！！！"); &#125; &#125;&#125; jQuery处理XML数据verifyjqueryxml.js1234567891011121314151617181920212223242526272829303132333435363738394041function verify()&#123; // 1.获取文本框中的内容 // document.getElementById("userName"); dom的方式 var jqueryObj = $("#userName"); // 获取节点的值 var userName = jqueryObj.val(); // 2.将文本框中的数据发送给服务器段的servlet var obj = &#123;name:"123",age:20&#125;; // 使用jquery的XMLHTTPrequest对象get请求的封装 $.ajax(&#123; type: "POST", //http请求方式 url: "AJAXXMLServer", //服务器端url地址（必须） data: "name=" + userName, //发送给服务器端的数据 dataType: "xml", //告诉JQuery返回的数据格式 success: callback //定义交互完成，并且服务器正确返回数据时调用的回调函数 &#125;);&#125;//回调函数function callback(data) &#123; // 3.接收服务器端返回的数据 // 需要将data这个dom对象中的数据解析出来 // 首先需要将dom的对象转换成JQuery的对象 var jqueryObj = $(data); // 获取message节点 var message = jqueryObj.children(); // 获取文本内容 var text = message.text(); // 4.将服务器段返回的数据动态的显示在页面上 //找到保存结果信息的节点 var resultObj = $("#result"); //动态的改变页面中div节点中的内容 resultObj.html(text); alert(""); // 由于从文本格式变成xml格式所以就不能就这样写了 // var resultObj = $("#result"); // resultObj.html(data);&#125; 解决XHR与图片缓存问题verify.js123456789101112// 给url地址增加时间戳，骗过浏览器，不读取缓存function convertURL(url) &#123; //获取时间戳 var timstamp = (new Date()).valueOf(); //将时间戳信息拼接到url上 if (url.indexOf("?") &gt;= 0) &#123; url = url + "&amp;t=" + timstamp; &#125; else &#123; url = url + "?t=" + timstamp; &#125; return url;&#125; 解决Ajax中文乱码与跨域访问``12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class AJAXServer extends HttpServlet&#123; protected void doPost(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException &#123; doGet(httpServletRequest, httpServletResponse); &#125; protected void doGet(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException &#123; try&#123;// request.setCharacterEncoding("UTF-8");// response.setContentType("text/html;charset=gb18030"); httpServletResponse.setContentType("text/html;charset=utf-8"); PrintWriter out = httpServletResponse.getWriter(); Integer inte = (Integer) httpServletRequest.getSession().getAttribute("total"); int temp = 0; if (inte == null) &#123; temp = 1; &#125; else &#123; temp = inte.intValue() + 1; &#125; httpServletRequest.getSession().setAttribute("total",temp); //1.取参数 String old = httpServletRequest.getParameter("name"); //String name = new String(old.getBytes("iso8859-1"),"UTF-8"); String name = URLDecoder.decode(old,"UTF-8"); //2.检查参数是否有问题 if(old == null || old.length() == 0)&#123; out.println("用户名不能为空"); &#125; else&#123;// String name = URLDecoder.decode(old,"UTF-8");// byte[] by = old.getBytes("ISO8859-1");// String name = new String(by,"utf-8");// String name = URLDecoder.decode(old,"utf-8"); //3.校验操作// String name = old; if(name.equals("wangxingkui"))&#123; //4。和传统应用不同之处。这一步需要将用户感兴趣的数据返回给页面段，而不是将一个新的页面发送给用户 //写法没有变化，本质发生了改变 out.println("用户名[" + name + "]已经存在，请使用其他用户名, " + temp); &#125; else&#123; out.println("用户名[" + name + "]尚未存在，可以使用该用户名注册, " + temp); &#125; &#125; &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; verify.js123456789function verify() &#123; //解决中文乱码问题的方法1：页面端发出的数据作一次encodeURI，服务器端使用new String(old.getBytes("iso8859-1"),"UTF-8"); //解决中文乱码问题的方法2：页面端发出的数据作两次encodeURI，服务器端使用URLDecoder.decode(old,"UTF-8") var url = "AJAXServer?name=" + encodeURI(encodeURI($("#userName").val())); url = convertURL(url); $.get(url,null,function(data)&#123; $("#result").html(data);&#125;);&#125; jQuery的Json支持12345function getInfo() &#123; $.get("GetStockInfo", null, function(data) &#123; ...... &#125;,"json") // 直接在这里加上json就可以将数据转换成json格式 &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mapper层单元测试]]></title>
      <url>%2F2017%2F02%2F10%2Fmapper%E5%B1%82%E6%B5%8B%E8%AF%95%2F</url>
      <content type="text"><![CDATA[po层User.java12345678910111213141516171819202122232425package po;public class User &#123; private int id; private String username; private String password; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; mapper层UserMapper.java1234567package mapper;import po.User;public interface UserMapper &#123; User getUserByName(String username); User getUserById(int id); void insertUser(User user);&#125; UserMapper.xml123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="mapper.UserMapper"&gt; &lt;resultMap type="po.User" id="userMap"&gt; &lt;id property="id" column="id" /&gt; &lt;result property="username" column="username" /&gt; &lt;result property="password" column="password" /&gt; &lt;/resultMap&gt; &lt;!-- select标签的id值对应Mapper类中方法名 --&gt; &lt;select id="getUserByName" parameterType="string" resultMap="userMap"&gt; &lt;!-- 此处写sql语句,#&#123;Mapper类传入的参数&#125; --&gt; select * from T_USER where username = #&#123;username&#125; &lt;/select&gt; &lt;select id="getUserById" parameterType="int" resultMap="userMap"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insertUser" parameterType="po.User" useGeneratedKeys="true" keyProperty="id"&gt; &lt;!--插入时获取自增主键id--&gt; insert into user (id, username, password) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;) &lt;/insert&gt;&lt;/mapper&gt; 测试UserMapperTest.java1234567891011121314151617181920212223242526272829303132package mapper;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import po.User;public class UserMapperTest &#123; private ApplicationContext applicationContext; private UserMapper userMapper; @Before public void setUp() throws Exception &#123; // 创建spring容器 applicationContext = new ClassPathXmlApplicationContext("classpath:spring/applicationContext.xml"); userMapper = (UserMapper) applicationContext.getBean("userMapper"); &#125; @Test public void testGetUserById() &#123; User user = userMapper.getUserById(1); System.out.println(user); &#125; @Test public void testInsertUser()&#123; User user = new User(); user.setUsername("user8"); user.setPassword("psw8"); userMapper.insert(user); System.out.println(user); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSM框架整合]]></title>
      <url>%2F2017%2F02%2F09%2FSSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
      <content type="text"><![CDATA[db.properties和log4j.properties这里是对数据库的参数进行一些配置，为了防止硬编码不利于系统的优化。（在与springmvc整合后，由spring管理） SqlMapConfig.xml配置只需定义别名123456789101112&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 定义别名。配置批量扫描po包 --&gt; &lt;typeAliases&gt; &lt;!-- 批量别名定义。指定包路径，mybatis自动扫描包下边的pojo类，自动定义别名，别名默认为类名（首字母小写或大写） --&gt; &lt;package name="po" /&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 解释1234&lt;typeAliases&gt; &lt;!-- &lt;typeAlias type="zq.mybatis.test1.User" alias="_User"/&gt; --&gt; &lt;package name="zq.mybatis.test1"/&gt;&lt;/typeAliases&gt; 使用package设置别名的手该如何运用这个别名呢？很简单，我指定了他的包名，那这个包下面的所有实体相当于已经被设置了别名，而这个别名实际上就是某一个实体自己的实体名。在对应的映射文件中将使用别名：123456&lt;update id="updateUser" parameterType="User"&gt; &lt;!-- parameterType="User"就是使用了别名User --&gt; update users set name=#&#123;name&#125;,age=#&#123;age&#125; where id=#&#123;id&#125;&lt;/update&gt;&lt;select id="getAllUser" resultType="User"&gt; &lt;!-- resultType="User"就是使用了别名User --&gt; select * from users&lt;/select&gt; applicationContext.xml配置数据源、SqlsessionFactory、MapperScannerConfigurer(mapper扫描器)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt;&lt;!-------------------------------1.dao层-------------------------------&gt; &lt;!-- 1.配置数据源 --&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!-- 2.SqlsessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- mybatis配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis/SqlMapConfig.xml"/&gt; &lt;/bean&gt; &lt;!--3.MapperScannerConfigurer：mapper的扫描器，将包下边的mapper接口自动创建代理对象， 自动创建到spring容器中，bean的id是mapper的类名（首字母小写） --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="mapper"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;/bean&gt;&lt;!-------------------------------2.service层-------------------------------&gt; &lt;!--配置service的实现class--&gt; &lt;!-- 商品管理的service --&gt; &lt;bean id="itemsService" class="service.impl.ItemsServiceImpl"/&gt;&lt;!-------------------------------3.transaction层-------------------------------&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="save*" propagation="REQUIRED"/&gt; &lt;tx:method name="insert*" propagation="REQUIRED"/&gt; &lt;tx:method name="update*" propagation="REQUIRED"/&gt; &lt;tx:method name="delete*" propagation="REQUIRED"/&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="select*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- aop --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* service.impl.*.*(..))"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 使用myBatis-generator工具产生对应的mapper.java接口和mapper.xml实现分别粘贴到cn.itcast.ssm.po和cn.itcast.ssm.mapper包下 Junit测试ItemsMapperTest.java123456789101112131415161718public class ItemsMapperTest &#123; private ApplicationContext applicationContext; private ItemsMapper itemsMapper; @Before public void setUp() throws Exception &#123; // 创建spring容器 applicationContext = new ClassPathXmlApplicationContext("classpath:spring/applicationContext.xml"); itemsMapper = (ItemsMapper) applicationContext.getBean("itemsMapper"); &#125; // 根据主键查询 @Test public void testSelectByPrimaryKey() &#123; Items items = itemsMapper.selectByPrimaryKey(1); System.out.println(items); &#125;&#125; po和mapper重构继续在po下增加ItemsCustom.java、ItemsQueryVo.java在mapper下增加ItemsMapperCustom.java、ItemsMapperCustom.xml 完成service模块UserService.java1...... UserServiceImpl.java1...... 完成controller模块ItemsController.java 配置springmvc.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt; &lt;!-- 1.使用spring组件扫描 --&gt;&lt;!-- 开启注解扫描功能 --&gt; &lt;context:component-scan base-package="controller" /&gt; &lt;!-- 2.通过annotation-driven可以替代下边的处理器映射器和适配器 --&gt; &lt;mvc:annotation-driven conversion-service="conversionService"&gt; &lt;/mvc:annotation-driven&gt; &lt;!--*注解处理器映射器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt; &lt;/bean&gt; &lt;!-- *注解适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;/bean&gt; &lt;!-- 3.配置视图解析器ViewResolver。要求将jstl的包加到classpath --&gt; &lt;!-- prefix:代表请求url的前缀 suffix:代表请求url的后缀 设置了这两个属性值后我们在Controller中进行代码开发时返回的modelandview对象设置的页面路径值就不用带前缀名和后缀名了--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt; 配置web.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt;&lt;!-- 配置spring容器监听器 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/spring/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 前端控制器DispatcherServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载springmvc配置 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 配置文件的地址 如果不配置contextConfigLocation，默认查找的配置文件名称classpath下的：servlet名称+"-serlvet.xml"即：springmvc-serlvet.xml --&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;&lt;/web-app&gt; 写jsp页面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring（三）]]></title>
      <url>%2F2017%2F02%2F08%2Fspring2%2F</url>
      <content type="text"><![CDATA[基于aspectj的注解aop操作使用注解方式实现aop操作 创建对象Book.java 123456package cn.itcast.aop;public class Book &#123; public void add() &#123; System.out.println("add............."); &#125;&#125; 在spring核心配置文件中，开启aop操作bean.xml 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 开启aop操作 --&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;!-- 1 配置对象 --&gt; &lt;bean id="book" class="cn.itcast.aop.Book"&gt;&lt;/bean&gt; &lt;bean id="myBook" class="cn.itcast.aop.MyBook"&gt;&lt;/bean&gt;&lt;/beans&gt; 在增强类上面使用注解完成aop操作MyBook.java 123456789package cn.itcast.aop;@Aspectpublic class MyBook &#123; // 在方法上面使用注解完成增强配置 @Before(value="execution(* cn.itcast.aop.Book.*(..))") public void before1() &#123; System.out.println("before.............."); &#125;&#125; TestAop.java123456789package cn.itcast.aop;public class TestAop &#123; @Test public void testDemo() &#123; ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml"); Book book = (Book) context.getBean("book"); book.add(); &#125;&#125; spring的jdbcTemplate操作spring框架一站式框架（1）针对javaee三层，每一层都有解决技术（2）在dao层，使用 jdbcTemplate spring对不同的持久化层技术都进行封装： jdbcTemplate对jdbc进行封装，它的使用和dbutils使用很相似，都数据库进行crud操作。 spring配置连接池spring配置c3p0连接池 导入jar包 创建spring配置文件，配置连接池代码实现： 12345678import com.mchange.v2.c3p0.ComboPooledDataSource;public class JdbcTemplateDemo1 &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass("com.mysql.jdbc.Driver"); dataSource.setJdbcUrl("jdbc:mysql:///spring_day03"); dataSource.setUser("root"); dataSource.setPassword("123");&#125; 配置实现：bean.xml12345678&lt;!-- 配置c3p0连接池 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 注入属性值 --&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day03"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt;&lt;/bean&gt; dao使用jdbcTemplate 创建service和dao，配置service和dao对象，在service注入dao对象bean.xml 12345678910&lt;!-- 创建service和dao对象，在service注入dao对象 --&gt;&lt;bean id="userService" class="cn.itcast.c3p0.UserService"&gt; &lt;!-- 注入dao对象 --&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="userDao" class="cn.itcast.c3p0.UserDao"&gt; &lt;!-- 注入jdbcTemplate对象 --&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt;&lt;/bean&gt; 创建jdbcTemplate对象，把模板对象注入到dao里面UserDao.java 123456789101112131415public class UserDao &#123; //得到JdbcTemplate对象 private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; //添加操作 public void add() &#123; // 代码实现：创建jdbcTemplate对象 // JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); String sql = "insert into user values(?,?)"; jdbcTemplate.update(sql, "李雷","520"); &#125;&#125; 在jdbcTemplate对象里面注入dataSourcebean.xml 12345&lt;!-- 创建jdbcTemplate对象 --&gt;&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;!-- 把dataSource传递到模板对象里面 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; spring事务管理spring事务管理两种方式 编程式事务管理（不用） 声明式事务管理 （1）基于xml配置文件实现 （2）基于注解实现（最简单方便） spring事务管理的api介绍spring针对不同的dao层框架，提供接口不同的实现类声明式事务管理（xml配置） 创建service和dao类，完成注入关系OrdersDao.java12345678910111213141516171819public class OrdersDao &#123; //注入jdbcTemplate private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; // 做对数据库操作的方法，不写业务操作 // 小王少钱的方法 public void lessMoney() &#123; String sql = "update account set salary=salary-? where username=?"; jdbcTemplate.update(sql, 1000,"小王"); &#125; // 小马多钱的方法 public void moreMoney() &#123; String sql = "update account set salary=salary+? where username=?"; jdbcTemplate.update(sql, 1000,"小马"); &#125;&#125; OrdersService.java1234567891011121314151617public class OrdersService &#123; private OrdersDao ordersDao; public void setOrdersDao(OrdersDao ordersDao) &#123; this.ordersDao = ordersDao; &#125; //调用dao的方法 //业务逻辑层，写转账业务 public void accountMoney() &#123; //小王少1000 ordersDao.lessMoney(); //出现异常，应该进行回滚操作 int i = 10/0; //小马多1000 ordersDao.moreMoney(); &#125;&#125; bean.xml123456789101112131415161718&lt;!-- 配置c3p0连接池 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 注入属性值 --&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day03"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="ordersService" class="cn.itcast.service.OrdersService"&gt; &lt;property name="ordersDao" ref="ordersDao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="ordersDao" class="cn.itcast.dao.OrdersDao"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 配置事务管理器 12345&lt;!-- 第一步 配置事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入dataSource，知道对哪个数据库进行操作 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 配置事务增强 12345678&lt;!-- 第二步 配置事务增强 --&gt;&lt;tx:advice id="txadvice" transaction-manager="transactionManager"&gt; &lt;!-- transaction-manager指定事务管理器id --&gt; &lt;!-- 做事务操作 --&gt; &lt;tx:attributes&gt; &lt;!-- 设置进行事务操作的方法匹配规则 --&gt; &lt;tx:method name="account*" propagation="REQUIRED"/&gt; &lt;!-- 如果方法都以account开头则都进行操作 --&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 配置切面 1234567&lt;!-- 第三步 配置切面 --&gt;&lt;aop:config&gt; &lt;!-- 切入点 --&gt; &lt;aop:pointcut expression="execution(* cn.itcast.service.OrdersService.*(..))" id="pointcut1"/&gt; &lt;!-- 切面 --&gt; &lt;aop:advisor advice-ref="txadvice" pointcut-ref="pointcut1"/&gt; &lt;!-- 指定哪个增强用在哪个切入点上 --&gt;&lt;/aop:config&gt; 总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 配置c3p0连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 注入属性值 --&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day03"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 第一步 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入dataSource --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 第二步 配置事务增强 --&gt; &lt;tx:advice id="txadvice" transaction-manager="transactionManager"&gt; &lt;!-- 做事务操作 --&gt; &lt;tx:attributes&gt; &lt;!-- 设置进行事务操作的方法匹配规则 --&gt; &lt;tx:method name="account*" propagation="REQUIRED"/&gt; &lt;!-- &lt;tx:method name="insert*" /&gt; --&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 第三步 配置切面 --&gt; &lt;aop:config&gt; &lt;!-- 切入点 --&gt; &lt;aop:pointcut expression="execution(* cn.itcast.service.OrdersService.*(..))" id="pointcut1"/&gt; &lt;!-- 切面 --&gt; &lt;aop:advisor advice-ref="txadvice" pointcut-ref="pointcut1"/&gt; &lt;/aop:config&gt; &lt;bean id="ordersService" class="cn.itcast.service.OrdersService"&gt; &lt;property name="ordersDao" ref="ordersDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="ordersDao" class="cn.itcast.dao.OrdersDao"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 声明式事务管理（注解） 配置事务管理器 1234&lt;!-- 第一步配置事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 配置事务注解 12&lt;!-- 第二步 开启事务注解 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; 在要使用事务的方法所在类上面添加注解OrdersService.java 12345678910111213141516171819@Transactionalpublic class OrdersService &#123; private OrdersDao ordersDao; public void setOrdersDao(OrdersDao ordersDao) &#123; this.ordersDao = ordersDao; &#125; //调用dao的方法 //业务逻辑层，写转账业务 public void accountMoney() &#123; //小王少1000 ordersDao.lessMoney(); //出现异常 int i = 10/0; //小马多1000 ordersDao.moreMoney(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 配置c3p0连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 注入属性值 --&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day03"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 第一步配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 第二步 开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;bean id="ordersService" class="cn.itcast.service.OrdersService"&gt; &lt;property name="ordersDao" ref="ordersDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="ordersDao" class="cn.itcast.dao.OrdersDao"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring（二）]]></title>
      <url>%2F2017%2F02%2F08%2Fspring1%2F</url>
      <content type="text"><![CDATA[bean管理(注解)导入jar包（基本的jar包+aop的jar包）创建类，创建方法创建spring配置文件，引入约束（第一天做ioc基本功能，引入约束beans + 做注解还要引入新的约束context schema）1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 开启注解扫描 (1)到包里面扫描类、方法、属性上面是否有注解 --&gt; &lt;context:component-scan base-package=&quot;cn.itcast&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- (2)只扫描属性上面的注解 --&gt; &lt;!-- &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; --&gt;&lt;/beans&gt; 注解创建对象在创建对象的类上面使用注解实现 12345678910111213package cn.itcast.anno;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;import org.springframework.stereotype.Service;@Service(value="user") // 相当于&lt;bean id="user" class=""/&gt;@Scope(value="prototype") // 单实例还是多实例public class User &#123; public void add() &#123; System.out.println("add..........."); &#125;&#125; 12345678910111213141516package cn.itcast.anno;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestAnno &#123; @Test public void testUser() &#123; ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml"); User user = (User) context.getBean("user"); System.out.println(user); user.add(); &#125;&#125; 创建对象有四个注解：\@Component \@Controller(web层) \@Service(业务层) \@Repository(持久层)，这四个注解功能是一样的，都创建对象，spring后续版本会对其增强 创建对象是单实例还是多实例@Scope(value=&quot;prototype&quot;) 注解注入属性创建dao和service对象12345678910package cn.itcast.anno;import org.springframework.stereotype.Component;@Component(value="userDao")public class UserDao &#123; public void add() &#123; System.out.println("dao........."); &#125;&#125; 在service类中定义dao类型属性 注入属性第一个注解方式(自动注入\@Autowired) 12345678910111213141516171819package cn.itcast.anno;import javax.annotation.Resource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Service(value="userService")public class UserService &#123; //得到dao对象 //1 定义dao类型属性 //在dao属性上面使用注解 完成对象注入 @Autowired private UserDao userDao; public void add() &#123; System.out.println("service..........."); userDao.add(); &#125;&#125; 123456789101112131415package cn.itcast.anno;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestAnno &#123; @Test public void testService() &#123; ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml"); UserService userService = (UserService) context.getBean("userService"); userService.add(); &#125;&#125; 注入属性第二个注解方式(\@Resource) 12345678910111213141516package cn.itcast.anno;import javax.annotation.Resource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Service(value="userService")public class UserService &#123; @Resource(name="userDao") private UserDao userDao; public void add() &#123; System.out.println("service..........."); userDao.add(); &#125;&#125; 配置文件和注解混合使用创建对象操作使用配置文件方式实现1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 开启注解扫描 (1)到包里面扫描类、方法、属性上面是否有注解 --&gt; &lt;context:component-scan base-package=&quot;cn.itcast&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 配置对象 --&gt; &lt;bean id=&quot;bookService&quot; class=&quot;cn.itcast.xmlanno.BookService&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;cn.itcast.xmlanno.BookDao&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;ordersDao&quot; class=&quot;cn.itcast.xmlanno.OrdersDao&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 注入属性的操作使用注解方式实现12345678package cn.itcast.xmlanno;public class BookDao &#123; public void book() &#123; System.out.println("bookdao.........."); &#125;&#125; 12345678package cn.itcast.xmlanno;public class OrdersDao &#123; public void buy() &#123; System.out.println("ordersdao.........."); &#125;&#125; 12345678910111213141516171819package cn.itcast.xmlanno;import javax.annotation.Resource;public class BookService &#123; //得到bookdao和ordersdao对象 @Resource(name="bookDao") private BookDao bookDao; @Resource(name="ordersDao") private OrdersDao ordersDao; public void add() &#123; System.out.println("service........."); bookDao.book(); ordersDao.buy(); &#125;&#125; junit测试12345678910111213141516package cn.itcast.xmlanno;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestAnno &#123; @Test public void testService() &#123; ApplicationContext context = new ClassPathXmlApplicationContext("bean2.xml"); BookService bookService = (BookService) context.getBean("bookService"); bookService.add(); &#125;&#125; AOP概念1 aop：面向切面（方面）编程，扩展功能不修改源代码实现 2 AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码 3 aop底层使用动态代理实现（1）第一种情况，有接口情况，使用动态代理创建接口实现类代理对象（2）第二种情况，没有接口情况，使用动态代理创建类的子类代理对象 AOP操作导入jar包增加aop约束1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;/beans&gt; 基于aspectj的xml配置使用表达式配置接入点123456781 切入点：实际增强的方法2 常用的表达式execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)（1）execution(* cn.itcast.aop.Book.add(..)) //要增强的方法的全路径.只有Book类中的add()方法增强 （2）execution(* cn.itcast.aop.Book.*(..)) //Book类中的所有方法都增强 （3）execution(* *.*(..)) //所有类的所有方法 （4）匹配所有save开头的方法 execution(* save*(..)) //满足一定规则的方法都增强.save开头的方法都增强 12345678910111213141516171819202122232425&lt;!-- 1 配置对象 --&gt;&lt;bean id=&quot;book&quot; class=&quot;cn.itcast.aop.Book&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;myBook&quot; class=&quot;cn.itcast.aop.MyBook&quot;&gt;&lt;/bean&gt;&lt;!-- 2 配置aop操作 --&gt;&lt;aop:config&gt; &lt;!-- 2.1 配置切入点 id=&quot;&quot;即给切入点起个名字 --&gt; &lt;aop:pointcut expression=&quot;execution(* cn.itcast.aop.Book.*(..))&quot; id=&quot;pointcut1&quot;/&gt; &lt;!-- 2.2 配置切面 把增强用到方法上面 --&gt; &lt;aop:aspect ref=&quot;myBook&quot;&gt; &lt;!-- 配置增强类型 method： 增强类里面使用哪个方法作为前置 --&gt; &lt;aop:before method=&quot;before1&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;aop:after-returning method=&quot;after1&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;aop:around method=&quot;around1&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 1234567package cn.itcast.aop;public class Book &#123; public void add() &#123; System.out.println("add..........."); &#125;&#125; 1234567891011121314151617181920package cn.itcast.aop;import org.aspectj.lang.ProceedingJoinPoint;public class MyBook &#123; public void before1() &#123; System.out.println("前置增强......"); &#125; public void after1() &#123; System.out.println("后置增强......"); &#125; //环绕通知 public void around1(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; //方法之前 System.out.println("方法之前....."); //执行被增强的方法 proceedingJoinPoint.proceed(); //方法之后 System.out.println("方法之后....."); &#125;&#125; 1234567891011121314package cn.itcast.aop;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestAnno &#123; @Test public void testService() &#123; ApplicationContext context = new ClassPathXmlApplicationContext("bean3.xml"); Book book = (Book) context.getBean("book"); book.add(); &#125;&#125; 基于aspectj的注解方式使用配置文件创建对象123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 开启aop操作 --&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;!-- 1 配置对象 --&gt; &lt;bean id=&quot;book&quot; class=&quot;cn.itcast.aop.Book&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;myBook&quot; class=&quot;cn.itcast.aop.MyBook&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 在spring核心配置文件中，开启aop操作&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 在增强类上面使用注解完成aop操作123456package cn.itcast.aop;public class Book &#123; public void add() &#123; System.out.println("add............."); &#125;&#125; 12345678910111213package cn.itcast.aop;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class MyBook &#123; //在方法上面使用注解完成增强配置 @Before(value="execution(* cn.itcast.aop.Book.*(..))") public void before1() &#123; System.out.println("before.............."); &#125;&#125; 123456789101112131415package cn.itcast.aop;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestAop &#123; @Test public void testDemo() &#123; ApplicationContext context = new ClassPathXmlApplicationContext("bean3.xml"); Book book = (Book) context.getBean("book"); book.add(); &#125;&#125; log4j123456789101 通过log4j可以看到程序运行过程中更详细的信息（1）经常使用log4j查看日志2 使用（1）导入log4j的jar包（2）复制log4j的配置文件log4j.properties，复制到src下面3 设置日志级别（1）info：看到基本信息（2）debug：看到更详细信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring（一）]]></title>
      <url>%2F2017%2F02%2F08%2Fspring%2F</url>
      <content type="text"><![CDATA[IOC入门案例 导入jar包 创建类，在类里面创建方法User.java 123456789101112131415161718192021222324package cn.itcast.ioc;// 创建类，在类里面创建方法public class User &#123; private String username; public User(String username) &#123; this.username = username; &#125; public User() &#123; // 无参构造函数 &#125; public void add() &#123; System.out.println("add.........."); &#125; public static void main(String[] args) &#123; //原始做法// User user = new User();// user.add(); &#125;&#125; 创建spring配置文件applicationContext.xml，配置创建类 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="user" class="cn.itcast.ioc.User"&gt;&lt;/bean&gt;&lt;/beans&gt; 写代码测试对象创建 123456789101112131415161718package cn.itcast.ioc;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestIOC &#123; @Test public void testUser() &#123; //1 加载spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml"); //2 得到配置创建的对象 UserService userService = (UserService) context.getBean("userService"); userService.add(); &#125;&#125; bean管理bean实例化的三种方式：使用类的无参构造创建（重点）、使用静态工厂创建、使用实例工厂创建 123public User() &#123; // 无参构造函数&#125; Bean标签常用属性 id属性 class属性 name属性 scope属性 -singleton：默认值，单例 -prototype：多例 -request -session -globalSession 属性注入创建对象时候，向类里面属性里面设置值 使用set方法注入 1234567891011121314package cn.itcast.property;public class Book &#123; private String bookname; //set方法 public void setBookname(String bookname) &#123; this.bookname = bookname; &#125; public void demobook() &#123; System.out.println("book..........."+bookname); &#125;&#125; 12345678&lt;!-- 使用set方法注入属性 --&gt;&lt;!-- &lt;bean id=&quot;book&quot; class=&quot;cn.itcast.property.Book&quot;&gt; --&gt; &lt;!-- 注入属性值 name属性值：类里面定义的属性名称 value属性：设置具体的值 --&gt; &lt;!-- &lt;property name=&quot;bookname&quot; value=&quot;易筋经&quot;&gt;&lt;/property&gt;&lt;/bean&gt; --&gt; 123456789101112131415161718package cn.itcast.property;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestIOC &#123; @Test public void testUser() &#123; //1 加载spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml"); //2 得到配置创建的对象 Book book = (Book) context.getBean("book"); person.demobook(); &#125;&#125; 使用有参数构造注入 123456789101112131415package cn.itcast.property;public class PropertyDemo1 &#123; private String username; public PropertyDemo1(String username) &#123; this.username = username; &#125; public void test1() &#123; System.out.println("demo1.........."+username); &#125;&#125; 12345&lt;!-- 使用有参数构造注入属性 --&gt;&lt;!-- &lt;bean id=&quot;demo&quot; class=&quot;cn.itcast.property.PropertyDemo1&quot;&gt; --&gt; &lt;!-- 使用有参构造注入 --&gt; &lt;!-- &lt;constructor-arg name=&quot;username&quot; value=&quot;小王小马&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; --&gt; 123456789101112131415161718package cn.itcast.property;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestIOC &#123; @Test public void testUser() &#123; //1 加载spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml"); //2 得到配置创建的对象 PropertyDemo1 demo1 = (PropertyDemo1) context.getBean("demo"); demo1.test1(); &#125;&#125; 使用接口注入 注入对象类型属性12345678package cn.itcast.ioc;public class UserDao &#123; public void add() &#123; System.out.println("dao........."); &#125;&#125; 123456789101112&lt;!-- 注入对象类型属性 --&gt;&lt;!-- 1 配置service和dao对象 --&gt;&lt;!-- &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.ioc.UserDao&quot;&gt;&lt;/bean&gt; --&gt;&lt;!-- &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.ioc.UserService&quot;&gt; --&gt; &lt;!-- 注入dao对象 name属性值：service类里面属性名称 现在不要写value属性，因为刚才是字符串，现在是对象 写ref属性：dao配置bean标签中id值 --&gt; &lt;!-- &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;&lt;/bean&gt; --&gt; 12345678910111213141516171819package cn.itcast.ioc;public class UserService &#123; //1 定义dao类型属性 private UserDao userDao; //2 生成set方法 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void add() &#123; System.out.println("service........."); //在service里面得到dao类对象，才能调用dao里面的方法// UserDao dao = new UserDao();// dao.add(); userDao.add(); &#125;&#125; 注入复杂类型属性IOC和DI区别 IOC：控制反转，把对象创建交给spring进行配置 DI：依赖注入，向类里面的属性中设置值 关系：依赖注入不能单独存在，需要在IOC基础上完成操作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[视图解析器]]></title>
      <url>%2F2017%2F02%2F07%2F%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8%2F</url>
      <content type="text"><![CDATA[InternalResourceViewResolver1234&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt;&lt;/bean&gt; FreeMarkerViewResolver12345678&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="templateLoaderPath" value="/WEB-INF/freemarker"/&gt;&lt;/bean&gt;&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"&gt; &lt;property name="cache" value="true"/&gt; &lt;property name="prefix" value=""/&gt; &lt;property name="suffix" value=".ftl"/&gt;&lt;/bean&gt; ContentNegotiatingViewResolver1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;mvc:annotation-driven content-negotiation-manager="contentNegotiationManager"&gt;&lt;/mvc:annotation-driven&gt;&lt;!--视图解析器3--&gt;&lt;!--ContentNegotiatingViewResolver的配置主要分为3个部分，viewResolvers，defaultViews，contentNegotiationManager三个部分。contentNegotiationManager用来配置视图对请求的处理，设置请求的媒体类型，响应方式。defaultContentType用来设置默认的视图，这里我设置的是json,ignoreAcceptHeader用来设置是否要使用报文头来确定请求的类型，favorPathExtension设置是否根据拓展名确定视图类型，这两个我都设置成true。--&gt;&lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;property name="contentNegotiationManager" ref="contentNegotiationManager"/&gt; &lt;property name="viewResolvers"&gt; &lt;list&gt; &lt;bean id="viewResolver1" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="order" value="1"&gt;&lt;/property&gt; &lt;property name="prefix" value="/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="viewResolver2" class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"&gt; &lt;property name="cache" value="true"/&gt; &lt;property name="prefix" value=""/&gt; &lt;property name="suffix" value=".ftl"/&gt; &lt;/bean&gt; &lt;bean id="beanNameViewResolver" class="org.springframework.web.servlet.view.BeanNameViewResolver"&gt; &lt;property name="order" value="2"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="defaultViews"&gt; &lt;list&gt; &lt;bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.view.xml.MarshallingView"&gt; &lt;constructor-arg&gt; &lt;bean class="org.springframework.oxm.xstream.XStreamMarshaller"&gt; &lt;property name="classesToBeBound"&gt; &lt;list&gt; &lt;value&gt;com.model.User&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="contentNegotiationManager" class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean"&gt; &lt;property name="order" value="1" /&gt; &lt;property name="favorParameter" value="false" /&gt; &lt;property name="ignoreAcceptHeader" value="true" /&gt; &lt;property name="defaultContentType" value="text/html" /&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;entry key="json" value="application/json" /&gt; &lt;entry key="xml" value="application/xml" /&gt; &lt;entry key="htm" value="application/json" /&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SpringMVC（二）]]></title>
      <url>%2F2017%2F02%2F07%2FSpringMVC%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[数据回显需求表单提交出现错误，重新回到表单，用户重新填写数据，刚才提交的参数在页面上回显。 对简单类型的数据回显对商品修改数据回显：注意在进入修改页面的controller方法中和提交修改商品信息方法model.addAttribute方法设置的key一致。 修改商品显示方法：ItemsController.java12345@RequestMapping(value="/editItems",method=&#123;RequestMethod.GET&#125;)public String editItems(Model model, Integer id) throws Exception &#123; // 将id传到页面 model.addAttribute("id", id);&#125; 修改商品页面：12&lt;form id="itemForm" action="$&#123;pageContext.request.contextPath &#125;/items/editItemSubmit.action" method="post" enctype="multipart/form-data"&gt;&lt;input type="text" name="id" value="$&#123; id &#125;"/&gt; 修改商品提交方法：12345@RequestMapping("/editItemSubmit")public String editItemSubmit(Model model, Integer id) throws Exception &#123; // 进行数据回显 model.addAttribute("id", id);&#125; pojo类型数据回显方法一：使用Model.addtribute方法进行数据回显12345@RequestMapping("/editItemSubmit")public String editItemSubmit(Model model, Integer id, ItemsCustom itemsCustom) throws Exception &#123; // 进行数据回显 model.addAttribute("item", itemsCustom);&#125; 方法二：使用@ModelAttribute，作用于将请求pojo数据放到Model中回显到页面123public String editItemSubmit(Model model, Integer id, @ModelAttribute(value="itemsCustom") ItemsCustom itemsCustom) throws Exception &#123; model.addAttribute("item", itemsCustom);&#125; 在ModelAttribute方法指定的名称就是要填充Model中的key，在页面中就要通过key取数据。 @ModelAttribute将方法返回值传到页面 参数绑定集合类型绑定数组需求：在商品查询列表页面，用户选择要删除的商品，批量删除商品。在controller方法中如何将批量提交的数据绑定成数组类型。 页面定义 itemsList.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;html&gt;&lt;script type="text/javascript"&gt;function deleteItems()&#123; //将form的action指向删除商品的地址 document.itemsForm.action="$&#123;pageContext.request.contextPath &#125;/items/deleteItems.action"; //进行form提交 document.itemsForm.submit();&#125;&lt;/script&gt;&lt;body&gt;当前用户：$&#123;usercode &#125; &lt;c:if test="$&#123; usercode!=null &#125;"&gt; &lt;a href="$&#123; pageContext.request.contextPath &#125;/logout.action"&gt;退出&lt;/a&gt;&lt;/c:if&gt;&lt;form name="itemsForm" action="$&#123; pageContext.request.contextPath &#125;/items/queryItem.action" method="post"&gt;查询条件：&lt;table width="100%" border=1&gt;&lt;tr&gt;&lt;td&gt;商品类别：&lt;select&gt; &lt;c:forEach items="$&#123;itemsType &#125;" var="item"&gt; &lt;option value="$&#123;item.key &#125;"&gt;$&#123;item.value &#125;&lt;/option&gt; &lt;/c:forEach&gt;&lt;/select&gt;&lt;/td&gt;&lt;td&gt;&lt;input type="submit" value="查询"/&gt;&lt;input type="button" value="批量删除" onclick="deleteItems()"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;商品列表：&lt;table width="100%" border=1&gt;&lt;tr&gt; &lt;td&gt;选择&lt;/td&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;生产日期&lt;/td&gt; &lt;td&gt;商品描述&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;td&gt;rest连接&lt;/td&gt;&lt;/tr&gt;&lt;c:forEach items="$&#123;itemsList &#125;" var="item"&gt;&lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" name="delete_id" value="$&#123;item.id&#125;" /&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt; &lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/items/editItems.action?id=$&#123;item.id&#125;"&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/items/viewItems/$&#123;item.id&#125;"&gt;商品查看&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; controller方法定义 ItemsController.java 1234567//删除 商品@RequestMapping("/deleteItems")public String deleteItems(Integer[] delete_id) throws Exception &#123; //调用service方法删除 商品 //.... return "success";&#125; 绑定List需求：批量修改商品信息提交。先进入批量修改商品页面，填写信息，点击提交。 页面定义 itemsList.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;html&gt;&lt;title&gt;批量修改商品查询&lt;/title&gt;&lt;script type="text/javascript"&gt;//修改商品提交function updateItems()&#123; //将form的action指向删除商品的地址 document.itemsForm.action="$&#123;pageContext.request.contextPath &#125;/items/editItemsListSubmit.action"; //进行form提交 document.itemsForm.submit();&#125;&lt;/script&gt;&lt;body&gt;&lt;form name="itemsForm" action="$&#123;pageContext.request.contextPath &#125;/items/queryItem.action" method="post"&gt;查询条件：&lt;table width="100%" border=1&gt;&lt;tr&gt;&lt;td&gt;商品类别：&lt;select&gt; &lt;c:forEach items="$&#123;itemsType &#125;" var="item"&gt; &lt;option value="$&#123;item.key &#125;"&gt;$&#123;item.value &#125;&lt;/option&gt; &lt;/c:forEach&gt;&lt;/select&gt;&lt;/td&gt;&lt;td&gt;&lt;input type="submit" value="查询"/&gt;&lt;input type="button" value="批量修改提交" onclick="updateItems()"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;商品列表：&lt;table width="100%" border=1&gt;&lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;生产日期&lt;/td&gt; &lt;td&gt;商品描述&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt;&lt;/tr&gt;&lt;c:forEach items="$&#123;itemsList &#125;" var="item" varStatus="s"&gt;&lt;tr&gt; &lt;td&gt;&lt;input type="text" name="itemsList[$&#123;s.index &#125;].name" value="$&#123;item.name &#125;"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="itemsList[$&#123;s.index &#125;].price" value="$&#123;item.price &#125;"/&gt;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value="$&#123; item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;&lt;/td&gt; &lt;td&gt;$&#123; item.detail &#125;&lt;/td&gt; &lt;td&gt;&lt;a href="$&#123; pageContext.request.contextPath &#125;/items/editItems.action?id=$&#123;item.id&#125;"&gt;修改&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; controller方法定义 ItemsController.java 12345678910111213141516171819//批量修改商品查询@RequestMapping("/editItemsList")public ModelAndView editItemsList(HttpServletRequest request) throws Exception &#123; System.out.println(request.getParameter("id")); //调用service查询商品列表 List&lt;ItemsCustom&gt; itemsList = itemsService.findItemsList(null); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("itemsList", itemsList); // 指定逻辑视图名 modelAndView.setViewName("editItemsList"); return modelAndView;&#125;//批量修改商品提交@RequestMapping("/editItemsListSubmit")public String editItemsListSubmit(ItemsQueryVo itemsQueryVo) throws Exception &#123; return "success";&#125; 1234&lt;c:forEach items="$&#123;itemsList &#125;" var="item" varStatus="s"&gt;&lt;tr&gt; &lt;td&gt;&lt;input type="text" name="itemsList[$&#123;s.index &#125;].name" value="$&#123;item.name &#125;"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="itemsList[$&#123;s.index &#125;].price" value="$&#123;item.price &#125;"/&gt;&lt;/td&gt; 注释： itemsList：controller方法形参包装类型中list的属性名。 itemsList[0]或itemsList[1]…：[]中是序号，从0开始。 itemsList[].name：name就是controller方法形参包装类型中list中pojo的属性名 在包装类型里定义一个list ItemsQueryVo.java 123456public class ItemsQueryVo &#123; //商品信息 private ItemsCustom itemsCustom; //定义一个list private List&lt;ItemsCustom&gt; itemsList;&#125; springmvc和struts的区别springmvc是通过方法的形参接收参数，在使用时可以以单例方式使用，建议使用单例。struts是通过成员变量接收参数，在使用时必须以多例方式使用。 springmvc是基于方法开发，struts基于类开发。springmvc将一个请求的Method和Handler进行关联绑定，一个method对应一个Handler。 springmvc开发以方法为单位进行开发，方法更帖进service(业务方法)。 经过实际测试，发现struts标签解析速度比较慢，建议在实际开发时使用jstl。 图片上传需求在商品修改页面，增加图片上传的功能。操作流程： 用户进入商品修改页面 上传图片 点击提交（提交的是图片和商品信息） 再次进入修改页面，图片在商品修改页面展示 图片存储问题切记：不要把图片上传到工程目录 ，不方便进行工程维护。实际电商项目中使用专门图片服务器(http，比如apache、tomcat)。 本教程使用图片虚拟目录，通过虚拟目录 访问硬盘上存储的图片目录。 虚拟目录设置： 注意：图片目录中尽量进行目录分级存储，提高访问速度（提交i/o）。 配置图片上传解析器springmvc使用commons-fileupload进行图片上传。commons-fileupload对应的springmvc的图片上传解析器：org.springframework.web.multipart.commons.CommonsMultipartResolverspringmvc.xml12345678&lt;!-- 文件上传 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 设置上传文件的最大尺寸为5MB --&gt; &lt;property name="maxUploadSize"&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 加入commons-fileupload的jar包：commons-fileupload-1.3.2.jar和commons-io-2.5.jar 编写上传图片的页面editItem.jsp12345678910&lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td&gt; &lt;c:if test="$&#123;itemsCustom.pic !=null&#125;"&gt; &lt;img src="/pic/$&#123;itemsCustom.pic&#125;" width=100 height=100/&gt; &lt;br/&gt; &lt;/c:if&gt; &lt;input type="file" name="pictureFile"/&gt; &lt;/td&gt;&lt;/tr&gt; 编写controller方法ItemsController.java1234567891011121314151617181920212223242526@RequestMapping("/editItemSubmit")public String editItemSubmit(Model model,Integer id, @ModelAttribute(value="itemsCustom") ItemsCustom itemsCustom, //上传图片 MultipartFile pictureFile ) throws Exception &#123; //进行数据回显 model.addAttribute("id", id); //进行图片上传 if(pictureFile!=null &amp;&amp; pictureFile.getOriginalFilename()!=null &amp;&amp; pictureFile.getOriginalFilename().length()&gt;0)&#123; //图片上传成功后，将图片的地址写到数据库 String filePath = "F:\\develop\\upload\\temp\\"; //上传文件原始名称 String originalFilename = pictureFile.getOriginalFilename(); //新的图片名称 String newFileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf(".")); //新文件 File file = new java.io.File(filePath+newFileName); //将内存中的文件写入磁盘 pictureFile.transferTo(file); //图片上传成功，将新图片地址写入数据库 itemsCustom.setPic(newFileName); &#125; json数据的交互需求json数据格式是比较简单容易理解，json数据格式常用于远程接口传输，http传输json数据，非常方便页面进行提交/请求结果解析，对json数据的解析。 springmvc解析json加入json解析包Springmvc默认用MappingJacksonHttpMessageConverter对json数据进行转换，需要加入jackson的包，如下：jackson-core-asl-1.9.13.jarjackson-mapper-asl-1.9.13.jar 在处理器适配器中注入MappingJacksonHttpMessageConverter让处理器适配器支持json数据解析，需要注入MappingJacksonHttpMessageConverter。springmvc.xml12345678&lt;!-- 注解适配器 --&gt;&lt;!-- 加入 json数据的消息转换器 MappingJacksonHttpMessageConverter依赖Jackson的包 --&gt;&lt;property name="messageConverters"&gt; &lt;list&gt; &lt;bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt;&lt;/bean&gt; &lt;/list&gt;&lt;/property&gt; @RequestBody和@ResponseBody@RequestBody：将请求的json数据转成java对象@ResponseBody：将java对象转成json数据输出。 请求json响应jsoncontroller方法：JsonTest.java12345678@Controllerpublic class JsonTest &#123; //请求的json响应json，请求商品信息，商品信息用json格式，输出商品信息 @RequestMapping("/requestJson") public @ResponseBody ItemsCustom requestJson(@RequestBody ItemsCustom itemsCustom) throws Exception&#123; return itemsCustom; &#125;&#125; 页面：JsonTest.jsp123456789101112131415161718192021222324252627282930313233343536373839404142&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;json测试&lt;/title&gt; &lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath &#125;/js/jquery-1.4.4.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; //请求json响应json function requestJson()&#123; $.ajax(&#123; url:"$&#123;pageContext.request.contextPath &#125;/requestJson.action", type:"post", contentType:"application/json;charset=utf-8", //请求json数据,使用json表示商品信息 data:'&#123;"name":"手机","price":1999&#125;', success:function(data)&#123; alert(data.name); &#125; &#125;); &#125; //请求key/value响应json function responseJson()&#123; $.ajax(&#123; url:"$&#123;pageContext.request.contextPath &#125;/responseJson.action", type:"post", //请求key/value数据 data:"name=手机&amp;price=1999", success:function(data)&#123; alert(data.name); &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="请求json响应json" onclick="requestJson()"/&gt; &lt;input type="button" value="请求key/value响应json" onclick="responseJson()"/&gt;&lt;/body&gt;&lt;/html&gt; 测试跟踪： 请求key/value响应jsoncontroller方法：JsonTest.java12345678@Controllerpublic class JsonTest &#123; //请求key/value响应json @RequestMapping("/responseJson") public @ResponseBody ItemsCustom responseJson(ItemsCustom itemsCustom) throws Exception&#123; return itemsCustom; &#125;&#125; 测试跟踪： 小结如果前端处理没有特殊要求，建议使用第二种，请求key/value，响应json，方便客户端解析请求结果。 validation校验（了解）统一异常处理要在一个统一异常处理的类中要处理系统抛出的所有异常，根据异常类型来处理。 统一异常处理的类是什么？ 前端控制器DispatcherServlet在进行HandlerMapping、调用HandlerAdapter执行Handler过程中，如果遇到异常，进行异常处理。 在系统中自定义统一的异常处理器，写系统自己的异常处理代码。 定义统一异常处理器类 统一异常处理器实现HandlerExceptionResolver接口。 CustomException.java 123456789101112131415161718package cn.itcast.ssm.exception;public class CustomException extends Exception &#123; //异常信息 private String message; public CustomException(String message)&#123; super(message); this.message = message; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; CustomExceptionResolver.java 1234567891011public class CustomExceptionResolver implements HandlerExceptionResolver &#123; //前端控制器DispatcherServlet在进行HandlerMapping、调用HandlerAdapter执行Handler过程中，如果遇到异常就会执行此方法 @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; //输出异常 ex.printStackTrace(); //统一异常处理代码 //...... return null; &#125;&#125; 配置统一异常处理器 springmvc.xml 12&lt;!-- 定义统一异常处理器 --&gt;&lt;bean class="cn.itcast.ssm.exception.CustomExceptionResolver"&gt;&lt;/bean&gt; 异常处理逻辑根据不同的异常类型进行异常处理。 系统自定义的异常类是CustomException ，在controller方法中、service方法中手动抛出此类异常。 针对系统自定义的CustomException异常，就可以直接从异常类中获取异常信息，将异常处理在错误页面展示。针对非CustomException异常，对这类重新构造成一个CustomException，异常信息为“未知错误”，此类错误需要在系统测试阶段去排除。 在统一异常处理器CustomExceptionResolver中实现上边的逻辑。 CustomExceptionResolver.java 12345678910111213141516171819202122232425262728293031323334353637public class CustomExceptionResolver implements HandlerExceptionResolver &#123; //前端控制器DispatcherServlet在进行HandlerMapping、调用HandlerAdapter执行Handler过程中，如果遇到异常就会执行此方法 //handler最终要执行的Handler，它的真实身份是HandlerMethod //Exception ex就是接收到异常信息 @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; //输出异常 ex.printStackTrace(); //统一异常处理代码 // 1.针对系统自定义的CustomException异常，就可以直接从异常类中获取异常信息，将异常处理在错误页面展示 //异常信息 String message = null; CustomException customException = null; //如果ex是系统自定义的异常，直接取出异常信息 if(ex instanceof CustomException)&#123; customException = (CustomException)ex; &#125; else&#123; // 2.针对非CustomException异常，对这类重新构造成一个CustomException，异常信息为“未知错误” customException = new CustomException("未知错误"); &#125; //错误信息 message = customException.getMessage(); request.setAttribute("message", message); try &#123; //转向到错误页面 request.getRequestDispatcher("/WEB-INF/jsp/error.jsp").forward(request, response); &#125; catch (ServletException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return new ModelAndView(); &#125;&#125; 测试抛出异常由统一异常处理器捕获 可以在controller方法、service方法、dao实现类中抛出异常，要求dao、service、controller遇到异常全部向上抛出异常，方法向上抛出异常throws Exception ItemsServiceImpl.java 1234567891011121314151617package cn.itcast.ssm.service.impl;public class ItemsServiceImpl implements ItemsService &#123; @Override public ItemsCustom findItemsById(int id) throws Exception &#123; Items items = itemsMapper.selectByPrimaryKey(id); //如果查询的商品信息为空，抛出系统自定义的异常 if(items==null)&#123; throw new CustomException("修改商品信息不存在"); &#125; //在这里随着需求的变量，需要查询商品的其它的相关信息，返回到controller ItemsCustom itemsCustom = new ItemsCustom(); //将items的属性拷贝到itemsCustom BeanUtils.copyProperties(items, itemsCustom); return itemsCustom; &#125;&#125; ItemsController.java 123456789101112131415//方法返回字符串，字符串就是逻辑视图名，Model作用是将数据填充到request域，在页面展示@RequestMapping(value="/editItems",method=&#123;RequestMethod.GET&#125;)public String editItems(Model model,Integer id)throws Exception&#123; //将id传到页面 model.addAttribute("id", id); //调用 service查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(id); if(itemsCustom == null)&#123; throws new CustomException("修改商品信息不存在"); &#125; model.addAttribute("itemsCustom", itemsCustom); return "editItem";&#125; 图解： RESTful架构什么是RESTfulRESTful软件开发理念，RESTful对http进行非常好的诠释。RESTful即Representational State Transfer的缩写。综合上面的解释，我们总结一下什么是RESTful架构：（1）每一个URI代表一种资源；（2）客户端和服务器之间，传递这种资源的某种表现层；（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 url的RESTful实现非RESTful的http的url：http://localhost:8080/items/editItems.action?id=1&amp;…. RESTful的url是简洁的：http:// localhost:8080/items/editItems/1参数通过url传递，rest接口返回json数据 需求根据id查看商品信息，商品信息查看的链接使用RESTful方式实现，商品信息以json返回。 更改DispatcherServlet配置 web.xml 1234567891011121314151617&lt;!-- restful的配置 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc_rest&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载springmvc配置 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 配置文件的地址 如果不配置contextConfigLocation， 默认查找的配置文件名称classpath下的：servlet名称+"-serlvet.xml"即：springmvc-serlvet.xml --&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc_rest&lt;/servlet-name&gt; &lt;!-- rest方式配置为/ --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 参数通过url传递 ItemsController.java 123456789// 根据商品id查看商品信息rest接口// @RequestMapping中指定restful方式的url中的参数，参数需要用&#123;&#125;包起来// @PathVariable将url中的&#123;&#125;包起参数和形参进行绑定@RequestMapping("/viewItems/&#123;id&#125;")public @ResponseBody ItemsCustom viewItems(@PathVariable("id") Integer id) throws Exception&#123; //调用 service查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(id); return itemsCustom;&#125; itemsList.jsp 123456789101112&lt;c:forEach items="$&#123;itemsList &#125;" var="item"&gt;&lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" name="delete_id" value="$&#123;item.id&#125;" /&gt;&lt;/td&gt; &lt;td&gt;$&#123; item.name &#125;&lt;/td&gt; &lt;td&gt;$&#123; item.price &#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;&lt;/td&gt; &lt;td&gt;$&#123; item.detail &#125;&lt;/td&gt; &lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/items/editItems.action?id=$&#123;item.id&#125;"&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/items/viewItems/$&#123;item.id&#125;"&gt;商品查看&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt; 设置静态资源解析 当DispatcherServlet拦截/开头的所有请求，对静态资源的访问就报错404，需要通过设置对静态资源进行解析. springmvc.xml 123&lt;!-- 静态资源 解析 --&gt;&lt;mvc:resources location="/js/" mapping="/js/**" /&gt;&lt;mvc:resources location="/img/" mapping="/img/**" /&gt; 访问/js/**的url从工程下/js/下解析。 springmvc拦截器拦截器的异常场合用户请求到DispatherServlet中，DispatherServlet调用HandlerMapping查找Handler，HandlerMapping返回一个拦截的链儿（多个拦截），springmvc中的拦截器是通过HandlerMapping发起的。在企业开发，使用拦截器实现用户认证（用户登陆后进行身份校验拦截），用户权限拦截。 springmvc拦截器方法测试拦截器拦截器应用（用户认证拦截）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SpringMVC（一）]]></title>
      <url>%2F2017%2F02%2F07%2FSpringMVC%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[SpringMVC架构的概念及应用1234567891011DispatcherServlet前端控制器-----------------------ViewResolver视图解析器、View视图 | |----请求查找Handler | \/ HandlerMapping处理器映射器 | |----请求执行Handler | \/ HandlerAdapter处理器适配器-----------------------Handler处理器 步骤 用户发起request请求，请求至DispatcherServlet前端控制器 DispatcherServlet前端控制器请求HandlerMapping处理器映射器查找Handler (DispatcherServlet：前端控制器，相当于中央调度器，各个组件都和前端控制器进行交互，降低各个组件之间耦合度) HandlerMapping处理器映射器，根据url及一些配置规则（xml配置、注解配置）查找Handler，将Handler返回给DispatcherServlet前端控制器 DispatcherServlet前端控制器调用适配器执行Handler，有了适配器通过适配器去扩展对不同Handler执行方式（比如：原始servlet开发，注解开发） 适配器执行Handler (Handler：后端控制器，当成模型) Handler执行完成返回ModelAndView (ModelAndView：springmvc的一个对象，对Model和view进行封装) 适配器将ModelAndView返回给DispatcherServlet DispatcherServlet调用视图解析器进行视图解析，解析后生成view 视图解析器根据逻辑视图名解析出真正的视图。 (View：springmvc视图封装对象，提供了很多view，jsp、freemarker、pdf、excel) ViewResolver视图解析器给前端控制器返回view DispatcherServlet调用view的渲染视图的方法，将模型数据填充到request域 DispatcherServlet向用户响应结果(jsp页面、json数据…) 组成 DispatcherServlet：前端控制器，相当于中央调度器，可以降低组件之间的耦合度。由springmvc提供 HandlerMappting：处理器映射器，负责根据url查找Handler。由springmvc提供 HandlerAdapter：处理器适配器，负责根据适配器要求的规则去执行处理器，可以通过扩展适配器支持不同类型的Handler。由springmvc提供 Handler：处理器，需要程序员开发 ViewResolver：视图解析器，根据逻辑视图名解析成真正的视图，可配置视图解析器的前缀和后缀，真正视图地址==前缀+逻辑视图名+后缀。由springmvc提供 View：真正视图页面需要由程序编写 入门程序前端控制器在web.xml中配置：12345678910111213141516171819202122232425&lt;!-- 前端控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载springmvc配置 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 配置文件的地址 如果不配置contextConfigLocation， 默认查找的配置文件名称classpath下的：servlet名称+"-serlvet.xml"即：springmvc-serlvet.xml --&gt; &lt;!-- 一定要加classpath:，不然服务器运行会报错 --&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 可以配置/ ，此工程 所有请求全部由springmvc解析，此种方式可以实现 RESTful方式，需要特殊处理对静态文件的解析不能由springmvc解析 可以配置*.do或*.action，所有请求的url扩展名为.do或.action由springmvc解析，此种方法常用 不可以/*，如果配置/*，返回jsp也由springmvc解析，这是不对的。 --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; springmvc.xml在config目录下的springmvc.xml中配置springmvc架构三大组件（处理器映射器、处理器适配器、视图解析器）和Handler12345678910111213141516171819202122232425262728293031323334&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt; &lt;!-- 1.配置处理器映射器，根据 HandlerMapping 接口判断是否是处理器映射器 --&gt; &lt;!-- 根据bean的name进行查找Handler 将action的url配置在bean的name中 --&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" /&gt; &lt;!-- 2.配置处理器适配器，根据 HandlerAdapter 接口判断是否是处理器适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter" /&gt; &lt;!-- 3.配置Handler，由于使用了BeanNameUrlHandlerMapping处理映射器，name配置为url --&gt; &lt;bean name="/itemList.action" class="cn.itcast.springmvc.first.ItemController1" /&gt; &lt;!-- 4.配置视图解析器 要求将jstl的包加到classpath --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt; (1)处理器映射器在springmvc.xml中配置：BeanNameUrlHandlerMapping： 根据请求url（XXXX.action）匹配spring容器bean的name找到对应的bean（程序编写的Handler）1234&lt;!-- 根据bean的name进行查找Handler 将action的url配置在bean的name中 --&gt;&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt; 所有处理器映射器都实现HandlerMapping接口 (2)处理器适配器在springmvc.xml配置，根据HandlerAdapter接口判断是否是处理器适配器。123&lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/&gt; 所有的适配器都是实现了HandlerAdapter接口 程序编写Handler根据适配器的要求编写。SimpleControllerHandlerAdapter适配器要求：通过supports方法知道Handler必须要实现哪个接口：123public boolean supports(Object handler)&#123; return (handler instanceof Controller);&#125; (3)Handler编写返回一个ModelAndView。123456789101112131415161718192021222324252627282930public class ItemController1 implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception&#123; // 使用静态数据将商品信息列表显示在jsp页面 // 商品列表 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); Items items_1 = new Items(); items_1.setName("联想笔记本"); items_1.setPrice(6000f); items_1.setCreatetime(new Date()); items_1.setDetail("ThinkPad T430 联想笔记本电脑！"); Items items_2 = new Items(); items_2.setName("苹果手机"); items_2.setPrice(5000f); items_2.setDetail("iphone6苹果手机！"); itemsList.add(items_1); itemsList.add(items_2); ModelAndView modelAndView = new ModelAndView(); // 1.将数据填充到request域 // request.setAttribute("itemsList", itemsList); modelAndView.addObject("itemsList", itemsList); // 2.指定转发的jsp页面 modelAndView.setViewName("/WEB-INF/jsp/itemsList.jsp"); return modelAndView; &#125;&#125; (4)配置Handler在springmvc.xml配置Handler由spring管理Handler。1234&lt;!-- 配置Handler 由于使用了BeanNameUrlHandlerMapping处理映射器，name配置为url --&gt;&lt;bean id="itemController1" name="/itemList.action" class="cn.itcast.springmvc.first.ItemController1"/&gt; (5)配置视图解析器配置视图解析，能够解析jsp视图。（要求将jstl的包加到classpath）1234567&lt;!-- 配置视图解析器 要求将jstl的包加到classpath --&gt;&lt;!-- ViewResolver --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt;&lt;/bean&gt; 其它非注解处理器映射器和适配器 BeanNameUrlHandlerMapping(映射器)根据请求url（XXXX.action）匹配spring容器bean的name找到对应的bean（程序编写的Handler） SimpleUrlHandlerMapping(映射器) 123456789&lt;!--简单url映射 集中配置bean的id对应 的url --&gt;&lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="/itemsTest1.action"&gt;itemController1&lt;/prop&gt; &lt;prop key="/itemsTest2.action"&gt;itemController1&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 注意：在springmvc.xml配置了多个处理器映射器，多个处理器映射器可以共存。 SimpleControllerHandlerAdapter(适配器)要求程序编写的Handler(Controller)需要实现Controller接口。 HttpRequestHandlerAdapter（适配器）在springmvc.xml配置：HttpRequestHandlerAdapter要求Handler实现HttpRequestHandler接口 12&lt;!-- HttpRequestHandlerAdapter适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter" /&gt; 开发Handler 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.IOException;import java.util.ArrayList;import java.util.Date;import java.util.List;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.HttpRequestHandler;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import cn.itcast.springmvc.po.Items;public class ItemController2 implements HttpRequestHandler &#123; @Override public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 使用静态数据将商品信息列表显示在jsp页面 // 商品列表 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); Items items_1 = new Items(); items_1.setName("联想笔记本"); items_1.setPrice(6000f); items_1.setCreatetime(new Date()); items_1.setDetail("ThinkPad T430 联想笔记本电脑！"); Items items_2 = new Items(); items_2.setName("苹果手机"); items_2.setPrice(5000f); items_2.setDetail("iphone6苹果手机！"); itemsList.add(items_1); itemsList.add(items_2); request.setAttribute("itemsList", itemsList); // 转发到jsp页面 request.getRequestDispatcher("/WEB-INF/jsp/itemsList.jsp").forward(request, response); &#125;&#125; 配置HandlerBeanNameUrlHandlerMapping或SimpleUrlHandlerMapping都可配置 1234567891011&lt;!-- handler2 --&gt;&lt;bean id="itemController2" class="cn.itcast.springmvc.first.ItemController2"&gt;&lt;/bean&gt;&lt;!--简单url映射 集中配置bean的id对应 的url --&gt;&lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="/itemsTest2.action"&gt;itemController2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; DispatcherServlet.properotiesDispatcherServlet前端控制器加载DispatcherServlet.properoties配置文件，从而默认加载各个组件，如果在springmvc.xml中配置了处理器映射器和适配器，以sprintmvc.xml中配置的为准。 注解映射器和适配器注解映射器spring3.1之前默认加载映射器是org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMappingspring3.1之后要使用：org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping 在springmvc.xml中配置RequestMappingHandlerMapping：使用RequestMappingHandlerMapping需要在Handler中使用@controller标识此类是一个控制器，使用@requestMapping指定Handler方法所对应的url。123&lt;!-- 注解处理器映射器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt; 注解适配器spring3.1之前默认加载映射器是org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapterspring3.1之后要使用：org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter RequestMappingHandlerAdapter，不要求Handler实现任何接口，它需要和RequestMappingHandlerMapping注解映射器配对使用，主要解析Handler方法中的形参。 注解开发Handler12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.ArrayList;import java.util.Date;import java.util.List;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import cn.itcast.springmvc.po.Items;@Controllerpublic class ItemController3 &#123; //商品列表，@RequestMapping中url建议和方法名一致，方便开发维护 @RequestMapping("/queryItems") public ModelAndView queryItems()&#123; // 使用静态数据将商品信息列表显示在jsp页面 // 商品列表 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); Items items_1 = new Items(); items_1.setName("联想笔记本"); items_1.setPrice(6000f); items_1.setCreatetime(new Date()); items_1.setDetail("ThinkPad T430 联想笔记本电脑！"); Items items_2 = new Items(); items_2.setName("苹果手机"); items_2.setPrice(5000f); items_2.setDetail("iphone6苹果手机！"); itemsList.add(items_1); itemsList.add(items_2); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("itemsList", itemsList); // 指定逻辑视图名 modelAndView.setViewName("itemsList"); return modelAndView; &#125; //商品添加 //商品删除&#125; 配置Handler建议使用组件扫描，组件扫描可以扫描@Controller、@Service、@Component、@Repsitory1234&lt;!-- 注解的handler，单个配置 --&gt;&lt;bean class="cn.itcast.springmvc.first.ItemController3"/&gt;&lt;!-- 使用spring组件扫描 --&gt;&lt;context:component-scan base-package="cn.itcast.springmvc.first" /&gt; 总结1&lt;!-- sss --&gt; 1.DispatcherServlet通过HandlerMapping查找Handler2.DispatcherServlet通过适配器去执行Handler，得到ModelAndview3.视图解析，解析完成得到一个view4.进行视图渲染，将Model中的数据 填充到request域 springmvc和mybatis整合整合思路在mybatis和spring整合的基础上添加springmvc。 spring要管理springmvc编写的Handler（controller）、mybatis的SqlSessionFactory、mapper 第一步：整合dao，spring和mybatis整合第二步：整合service，spring管理service接口，service中可以调用spring容器中dao(mapper)第三步：整合controller，spring管理controller接口，在controller调用service jar包mybatis：3.2.7spring：3.2.0 mybatis的jarmybatis和spring整合包spring的所有jar包(包括 springmvc的包)数据库驱动包log4j日志.. 工程结构配置文件 applicationContext-dao.xml—配置数据源、SqlSessionFactory、mapper扫描器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!-- SqlsessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- mybatis配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis/SqlMapConfig.xml"/&gt; &lt;/bean&gt; &lt;!-- MapperScannerConfigurer：mapper的扫描器，将包下边的mapper接口自动创建代理对象， 自动创建到spring容器中，bean的id是mapper的类名（首字母小写） --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 配置扫描包的路径 如果要扫描多个包，中间使用半角逗号分隔 要求mapper.xml和mapper.java同名且在同一个目录 --&gt; &lt;property name="basePackage" value="cn.itcast.ssm.mapper"/&gt; &lt;!-- 使用sqlSessionFactoryBeanName --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;/bean&gt;&lt;/beans&gt; applicationContext-service.xml—配置service接口 123456789101112131415&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt;&lt;/beans&gt; 这样配置：12&lt;!-- 商品管理的service --&gt;&lt;bean id="itemsService" class="cn.itcast.ssm.service.impl.ItemsServiceImpl"/&gt; applicationContext-transaction.xml–事务管理 123456789101112131415&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt;&lt;/beans&gt; 这样配置： 12345678910111213141516171819202122232425&lt;!-- 1.事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;&lt;!-- 2.通知 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;&lt;tx:attributes&gt; &lt;tx:method name="save*" propagation="REQUIRED"/&gt; &lt;tx:method name="insert*" propagation="REQUIRED"/&gt; &lt;tx:method name="update*" propagation="REQUIRED"/&gt; &lt;tx:method name="delete*" propagation="REQUIRED"/&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="select*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true"/&gt;&lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 3.aop(切点) --&gt;&lt;aop:config&gt;&lt;aop:advisor advice-ref="txAdvice" &lt;!-- impl包下任意类任意方法，不管输入参数和返回值是什么 --&gt; pointcut="execution(* cn.itcast.ssm.service.impl.*.*(..))"/&gt;&lt;/aop:config&gt; 前端控制器配置 web.xml 12345678910111213141516171819&lt;!-- 前端控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载springmvc配置 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 配置文件的地址 如果不配置contextConfigLocation， 默认查找的配置文件名称classpath下的：servlet名称+"-serlvet.xml"即：springmvc-serlvet.xml --&gt; &lt;param-value&gt;classpath:/spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 可以配置/，此工程所有请求全部由springmvc解析，此种方式可以实现RESTful方式，需要特殊处理对静态文件的解析不能由springmvc解析。 可以配置*.do或*.action，所有请求的url扩展名为.do或.action由springmvc解析，此种方法常用。 不可以/*，如果配置/*，返回jsp也由springmvc解析，这是不对的。 --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; springmvc.xml—springmvc的配置，配置处理器映射器、适配器、视图解析器 123456789101112131415&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt;&lt;/beans&gt; 这样配置： 12&lt;!-- 通过annotation-driven可以替代下边的处理器映射器和适配器 --&gt;&lt;!-- &lt;mvc:annotation-driven conversion-service="conversionService"&gt;&lt;/mvc:annotation-driven&gt; --&gt; 基本配置： 123456789101112131415161718192021&lt;!-- 1.使用spring组件扫描 --&gt;&lt;context:component-scan base-package="cn.itcast.ssm.controller" /&gt;&lt;!-- 2.注解处理器映射器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt;&lt;!-- 3.注解适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;!-- 在webBindingInitializer中注入自定义属性编辑器、自定义转换器 --&gt; &lt;property name="webBindingInitializer" ref="customBinder"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 4.配置视图解析器 要求将jstl的包加到classpath --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt;&lt;/bean&gt; 增加的更多的配置： 123456789101112131415161718192021222324252627&lt;!-- 自定义webBinder --&gt;&lt;bean id="customBinder" class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer"&gt; &lt;!-- 使用converter进行参数转 --&gt; &lt;property name="conversionService" ref="conversionService" /&gt; &lt;!-- propertyEditorRegistrars用于属性编辑器 --&gt; &lt;!-- &lt;property name="propertyEditorRegistrars"&gt; &lt;list&gt; &lt;ref bean="customPropertyEditor" /&gt; &lt;/list&gt; &lt;/property&gt; --&gt;&lt;/bean&gt;&lt;!-- 注册属性编辑器 --&gt;&lt;bean id="customPropertyEditor" class="cn.itcast.ssm.controller.propertyeditor.CustomPropertyEditor"&gt;&lt;/bean&gt;&lt;!-- 转换器 --&gt;&lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;bean class="cn.itcast.ssm.controller.converter.CustomDateConverter"/&gt; &lt;bean class="cn.itcast.ssm.controller.converter.StringTrimConverter"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; SqlMapConfig.xml—mybatis的配置文件，配置别名、settings、mapper 12345678910111213141516&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 定义 别名 --&gt; &lt;typeAliases&gt; &lt;!-- 批量别名定义 指定包路径，自动扫描包下边的pojo，定义别名，别名默认为类名（首字母小写或大写） --&gt; &lt;package name="cn.itcast.ssm.po" /&gt; &lt;/typeAliases&gt; &lt;!-- 由于使用spring和mybatis整合的mapper扫描器，这里可以不用配置了 &lt;mappers&gt; &lt;package name="cn.itcast.ssm.mapper" /&gt; &lt;/mappers&gt; --&gt;&lt;/configuration&gt; 商品列表开发从底层即dao数据层开始写 mapper功能描述：根据条件查询商品信息，返回商品列表一般情况下针对查询mapper需要自定义mapper。 首先针对单表进行逆向工程，生成代码。 mapper.xml ItemsMapperCustom.xml 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.itcast.ssm.mapper.ItemsMapperCustom"&gt; &lt;!-- 商品查询的sql片段 建议是以单表为单位定义查询条件 建议将常用的查询条件都写出来 --&gt; &lt;sql id="query_items_where"&gt; &lt;if test="itemsCustom!=null"&gt; &lt;if test="itemsCustom.name!=null and itemsCustom.name!=''"&gt; and name like '%$&#123;itemsCustom.name&#125;%' &lt;/if&gt; &lt;if test="itemsCustom.id!=null"&gt; and id = #&#123;itemsCustom.id&#125; &lt;/if&gt; &lt;/if&gt; &lt;/sql&gt; &lt;!-- 商品查询 --&gt; &lt;select id="findItemsList" parameterType="cn.itcast.ssm.po.ItemsQueryVo" resultType="cn.itcast.ssm.po.ItemsCustom"&gt; SELECT * FROM items &lt;where&gt; &lt;include refid="query_items_where"/&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 包装类： ItemsCustom.java 123package cn.itcast.ssm.po;public class ItemsCustom extends Items&#123;&#125; ItemsQueryVo.java 12345678910111213package cn.itcast.ssm.po;public class ItemsQueryVo &#123; //商品信息 private ItemsCustom itemsCustom; public ItemsCustom getItemsCustom() &#123; return itemsCustom; &#125; public void setItemsCustom(ItemsCustom itemsCustom) &#123; this.itemsCustom = itemsCustom; &#125;&#125; mapper.java ItemsMapperCustom.java 123456789101112package cn.itcast.ssm.mapper;import java.util.List;import cn.itcast.ssm.po.ItemsCustom;import cn.itcast.ssm.po.ItemsQueryVo;// 商品自定义mapperpublic interface ItemsMapperCustom &#123; // 商品查询列表 public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception; // 把包装类作参数&#125; serviceItemsService.java1234567891011121314151617181920package cn.itcast.ssm.service;import java.util.List;import cn.itcast.ssm.po.Items;import cn.itcast.ssm.po.ItemsCustom;import cn.itcast.ssm.po.ItemsQueryVo;// 商品service接口public interface ItemsService &#123; // 商品查询列表 public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception; // 根据商品id查询商品信息 public ItemsCustom findItemsById(int id) throws Exception; // 更新商品信息 // 定义service接口，遵循单一职责，将业务参数细化 （不要使用包装类型，比如map） public void updateItems(Integer id, ItemsCustom itemsCustom) throws Exception;&#125; ItemsServiceImpl.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.itcast.ssm.service.impl;import org.springframework.beans.BeanUtils;import org.springframework.beans.factory.annotation.Autowired;public class ItemsServiceImpl implements ItemsService &#123; // 注入mapper @Autowired private ItemsMapperCustom itemsMapperCustom; @Autowired private ItemsMapper itemsMapper; // 商品查询列表 // service接口，然后用serviceImpl实现接口 @Override public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception &#123; return itemsMapperCustom.findItemsList(itemsQueryVo); &#125; @Override public ItemsCustom findItemsById(int id) throws Exception &#123; Items items = itemsMapper.selectByPrimaryKey(id); //在这里随着需求的变量，需要查询商品的其它的相关信息，返回到controller ItemsCustom itemsCustom = new ItemsCustom(); //将items的属性拷贝到itemsCustom BeanUtils.copyProperties(items, itemsCustom); return itemsCustom; &#125; @Override public void updateItems(Integer id,ItemsCustom itemsCustom) throws Exception &#123; // 写业务代码 // 对于关键业务数据的非空校验 if(id == null)&#123; // 抛出异常，提示调用接口的用户，id不能为空 //... &#125; // itemsMapper.updateByPrimaryKey(itemsCustom); itemsMapper.updateByPrimaryKeyWithBLOBs(itemsCustom); &#125;&#125; 在applicationContext-service.xml中配置service12&lt;!-- 商品管理 的service --&gt;&lt;bean id="itemsService" class="cn.itcast.ssm.service.impl.ItemsServiceImpl"/&gt; controller1234567891011121314151617181920212223@Controller//定义url的根路径，访问时根路径+方法的url@RequestMapping("/items")public class ItemsController &#123; // 注入service @Autowired private ItemsService itemsService; @RequestMapping("/queryItems") public ModelAndView queryItems(HttpServletRequest request) throws Exception &#123; System.out.println(request.getParameter("id")); //调用service查询商品列表 List&lt;ItemsCustom&gt; itemsList = itemsService.findItemsList(null); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("itemsList", itemsList); // 指定逻辑视图名 modelAndView.setViewName("itemsList"); return modelAndView; &#125;&#125; jspitemsList.jsp12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;查询商品列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="$&#123;pageContext.request.contextPath &#125;/items/queryItem.action" method="post"&gt;查询条件：&lt;table width="100%" border=1&gt;&lt;tr&gt;&lt;td&gt;&lt;input type="submit" value="查询"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;商品列表：&lt;table width="100%" border=1&gt;&lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;生产日期&lt;/td&gt; &lt;td&gt;商品描述&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt;&lt;/tr&gt;&lt;c:forEach items="$&#123;itemsList &#125;" var="item"&gt;&lt;tr&gt; &lt;td&gt;$&#123;item.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt; &lt;td&gt;&lt;a href="$&#123; pageContext.request.contextPath &#125;/items/editItems.action?id=$&#123;item.id&#125;"&gt;修改&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在web.xml配置spring监听器12345678&lt;!-- 配置spring容器监听器 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/spring/applicationContext-*.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 注解开发基础功能描述：商品信息修改操作流程：1、在商品列表页面点击修改连接。2、打开商品修改页面，显示了当前商品的信息。 根据商品id查询商品信息3、修改商品信息，点击提交。 更新商品信息 mapper和serviceItemsMapper.java1234567891011121314151617181920212223242526272829public interface ItemsMapper &#123; int countByExample(ItemsExample example); int deleteByExample(ItemsExample example); int deleteByPrimaryKey(Integer id); int insert(Items record); int insertSelective(Items record); List&lt;Items&gt; selectByExampleWithBLOBs(ItemsExample example); List&lt;Items&gt; selectByExample(ItemsExample example); Items selectByPrimaryKey(Integer id); int updateByExampleSelective(@Param("record") Items record, @Param("example") ItemsExample example); int updateByExampleWithBLOBs(@Param("record") Items record, @Param("example") ItemsExample example); int updateByExample(@Param("record") Items record, @Param("example") ItemsExample example); int updateByPrimaryKeySelective(Items record); int updateByPrimaryKeyWithBLOBs(Items record); int updateByPrimaryKey(Items record);&#125; ItemsService.java123456public interface ItemsService &#123; //根据商品id查询商品信息 public ItemsCustom findItemsById(int id) throws Exception; //更新商品信息 public void updateItems(Integer id,ItemsCustom itemsCustom)throws Exception;&#125; @RequestMapping 设置方法对应的url（完成url映射）一个方法对应一个url。ItemsController.java 12@RequestMapping("/queryItems")public ModelAndView queryItems(HttpServletRequest request) throws Exception &#123;&#125; 窄化请求映射在class上定义根路径。 1234@Controller//定义url的根路径，访问时根路径+方法的url@RequestMapping("/items")public class ItemsController &#123;&#125; 好处：更新规范系统 的url，避免 url冲突。 限制http请求的方法通过requestMapping限制url请求的http方法，如果限制请求必须是post，如果get请求就抛出异常。商品修改方法，限制为http的get：123456789101112131415//使用method=RequestMethod.GET限制使用get方法@RequestMapping(value="/editItems",method=&#123;RequestMethod.GET&#125;)// GET和POST都可以：@RequestMapping(value="/editItems",method=&#123;RequestMethod.GET,RequestMethod.POST&#125;)public ModelAndView editItems()throws Exception&#123; ModelAndView modelAndView = new ModelAndView(); //调用 service查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(1); //将模型数据传到jsp modelAndView.addObject("item", itemsCustom); //指定逻辑视图名 modelAndView.setViewName("editItem"); return modelAndView;&#125; controller方法返回值 返回ModelAndView 1234567891011121314@RequestMapping("/queryItems")public ModelAndView queryItems(HttpServletRequest request) throws Exception &#123; System.out.println(request.getParameter("id")); //调用service查询商品列表 List&lt;ItemsCustom&gt; itemsList = itemsService.findItemsList(null); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("itemsList", itemsList); // 指定逻辑视图名 modelAndView.setViewName("itemsList"); return modelAndView;&#125; 返回字符串如果controller方法返回jsp页面，可以简单将方法返回值类型定义为字符串，最终返回逻辑视图名。 12345678910//方法返回字符串，字符串就是逻辑视图名，Model作用是将数据填充到request域，在页面展示@RequestMapping(value="/editItems",method=&#123;RequestMethod.GET&#125;)public String editItems(Model model,Integer id)throws Exception&#123; //调用 service查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(id); model.addAttribute("item", itemsCustom); return "editItem";&#125; 返回void 12345678@RequestMapping(value="/editItems",method=&#123;RequestMethod.GET&#125;)public void editItems(HttpServletRequest request, HttpServletResponse response, Integer id) throws Exception &#123; //调用service查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(id); request.setAttribute("item", itemsCustom); //注意如果使用request转向页面，这里指定页面的完整路径 request.getRequestDispatcher("/WEB-INF/jsp/editItem.jsp").forward(request, response);&#125; 使用此方法，容易输出json、xml格式的数据：通过response指定响应结果，例如响应json数据如下：response.setCharacterEncoding(&quot;utf-8&quot;);response.setContentType(&quot;application/json;charset=utf-8&quot;);response.getWriter().write(&quot;json串&quot;); redirect重定向如果方法重定向到另一个url，方法返回值为redirect:url路径使用redirect进行重定向，request数据无法共享，url地址栏会发生变化的。 forward转发使用forward进行请求转发，request数据可以共享，url地址栏不会。方法返回值为forward:url路径 123456789101112//商品修改提交@RequestMapping("/editItemSubmit")public String editItemSubmit() throws Exception&#123; // 1.请求重定向 return "redirect:queryItems.action"; // 2.转发 return "forward:queryItems.action";&#125;``` `edititem.jsp````js&lt;form id="itemForm" action="$&#123; pageContext.request.contextPath &#125;/items/editItemSubmit.action" method="post" &gt; 参数绑定默认支持的参数类型处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。HttpServletRequest：通过request对象获取请求信息HttpServletResponse：通过response处理响应信息HttpSession：通过session对象得到session中存放的对象Model：通过model向页面传递数据，如下：123//调用service查询商品信息Items item = itemService.findItemById(id);model.addAttribute("item", item); 页面通过${item.XXXX}获取item对象的属性值。 @RequestParam如果request请求的参数名和controller方法的形参数名称一致，适配器自动进行参数绑定。如果不一致可以通过@RequestParam指定request请求的参数名绑定到哪个方法形参上。对于必须要传的参数，通过@RequestParam中属性required设置为true，如果不传此参数则报错。对于有些参数如果不传入，还需要设置默认值，使用@RequestParam中属性defaultvalue设置默认值。 12345678@RequestMapping(value="/editItems",method=&#123;RequestMethod.GET&#125;)public void editItems(HttpServletRequest request, HttpServletResponse response, @RequestParam(value = "item_id", required = false, defaultValue = "1")) throws Exception &#123; //调用service查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(id); request.setAttribute("item", itemsCustom); //注意如果使用request转向页面，这里指定页面的完整路径 request.getRequestDispatcher("/WEB-INF/jsp/editItem.jsp").forward(request, response);&#125; 可以绑定简单类型可以绑定整型、字符串、单精/双精度、日期、布尔型。 可以绑定简单pojo类型简单pojo类型只包括简单类型的属性。绑定过程：request请求的参数名称和pojo的属性名一致，就可以绑定成功。 12345678//商品修改提交@RequestMapping("/editItemSubmit")public String editItemSubmit(Integer id,ItemsCustom itemsCustom)throws Exception&#123; //调用service接口更新商品信息 itemsService.updateItems(id, itemsCustom); //请求重定向 return "redirect:queryItems.action";&#125; 问题：如果controller方法形参中有多个pojo且pojo中有重复的属性，使用简单pojo绑定无法有针对性的绑定。比如：方法形参有items和User，pojo同时存在name属性，从http请求过程的name无法有针对性的绑定到items或user。 可以绑定包装的pojo包装的pojo里边包括了pojo。1234567@RequestMapping("/editItemSubmit")public String editItemSubmit(Integer id,ItemsCustom itemsCustom, ItemsQueryVo itemsQueryVo)throws Exception&#123; //调用service接口更新商品信息 itemsService.updateItems(id, itemsCustom); //请求重定向 return "redirect:queryItems.action";&#125; 页面参数定义：1234567891011121314&lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="itemsCustom.name" value="$&#123;item.name &#125;"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="itemsCustom.price" value="$&#123;item.price &#125;"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;商品简介&lt;/td&gt; &lt;td&gt; &lt;textarea rows="3" cols="30" name="itemsCustom.detail"&gt;$&#123;item.detail &#125;&lt;/textarea&gt; &lt;/td&gt;&lt;/tr&gt; 包装类型的属性也是itemsCustom：ItemsQueryVo.java12345public class ItemsQueryVo &#123; // 商品信息 private ItemsCustom itemsCustom; // getter setter方法省略......&#125; 按照上边的规则进行包装类型的绑定。 自定义绑定使用属性编辑器springmvc没有提供默认的对日期类型的绑定，需要自定义日期类型的绑定。 使用WebDataBinder（了解）在controller类中定义：ItemsController.java 1234567// 自定义属性编辑器@InitBinderpublic void initBinder(WebDataBinder binder) throws Exception &#123; // Date.class必须是与controler方法形参pojo属性一致的date类型，这里是java.util.Date binder.registerCustomEditor(Date.class, new CustomDateEditor( new SimpleDateFormat("yyyy-MM-dd HH-mm-ss"), true));&#125; 使用这种方法问题是无法在多个controller共用。 使用WebBindingInitializer（了解）使用WebBindingInitializer让多个controller共用 属性编辑器。自定义WebBindingInitializer，注入到处理器适配器中。如果想多个controller需要共同注册相同的属性编辑器，可以实现PropertyEditorRegistrar接口，并注入webBindingInitializer中。 如下：编写CustomPropertyEditor.java： 1234567891011121314151617package cn.itcast.ssm.controller.propertyeditor;import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.beans.PropertyEditorRegistrar;import org.springframework.beans.PropertyEditorRegistry;import org.springframework.beans.propertyeditors.CustomDateEditor;public class CustomPropertyEditor implements PropertyEditorRegistrar &#123; @Override public void registerCustomEditors(PropertyEditorRegistry binder) &#123; binder.registerCustomEditor(Date.class, new CustomDateEditor( new SimpleDateFormat("yyyy-MM-dd HH-mm-ss"), true)); &#125;&#125; 配置如下：springmvc.xml 1234567891011121314151617&lt;!-- 注册属性编辑器 --&gt; &lt;bean id="customPropertyEditor" class="cn.itcast.ssm.propertyeditor.CustomPropertyEditor"&gt;&lt;/bean&gt;&lt;!-- 自定义webBinder --&gt; &lt;bean id="customBinder" class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer"&gt; &lt;property name="propertyEditorRegistrars"&gt; &lt;list&gt; &lt;ref bean="customPropertyEditor"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;!--注解适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;property name="webBindingInitializer" ref="customBinder"&gt;&lt;/property&gt; &lt;/bean&gt; 自定义参数绑定使用转换器(架构师掌握) 实现Converter接口：定义日期类型转换器和字符串去除前后空格转换器。CustomDateConverter.java 1234567891011121314151617181920package cn.itcast.ssm.controller.converter;import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.core.convert.converter.Converter; // 自定义日期转换器public class CustomDateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String source) &#123; try &#123; //进行日期转换 return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(source); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; StringTrimConverter.java 123456789101112131415161718192021222324package cn.itcast.ssm.controller.converter;import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.core.convert.converter.Converter;public class StringTrimConverter implements Converter&lt;String, String&gt; &#123; @Override public String convert(String source) &#123; try &#123; //去掉字符串两边空格，如果去除后为空设置为null if(source!=null)&#123; source = source.trim(); if(source.equals(""))&#123; return null; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return source; &#125;&#125; 配置转换器配置方式1针对不使用&lt;mvc:annotation-driven&gt;springmvc.xml 123456789101112131415161718192021 &lt;!--注解适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;property name="webBindingInitializer" ref="customBinder"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 自定义webBinder --&gt;&lt;bean id="customBinder" class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer"&gt; &lt;property name="conversionService" ref="conversionService" /&gt;&lt;/bean&gt;&lt;!-- conversionService --&gt;&lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;!-- 转换器 --&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;bean class="cn.itcast.ssm.controller.converter.CustomDateConverter"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 配置方式2针对使用&lt;mvc:annotation-driven&gt;的配置springmvc.xml 123456789101112&lt;mvc:annotation-driven conversion-service="conversionService"&gt;&lt;/mvc:annotation-driven&gt;&lt;!-- conversionService --&gt; &lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;!-- 转换器 --&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;bean class="cn.itcast.ssm.controller.converter.CustomDateConverter"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 问题处理 post乱码 在web.xml中加入： 123456789101112&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; get乱码 对于get请求中文参数出现乱码解决方法有两个： 修改tomcat配置文件添加编码与工程编码一致&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; 对参数进行重新编码： 12String userName newString(request.getParamter("userName").getBytes("ISO8859-1"),"utf-8") ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MyBatis]]></title>
      <url>%2F2017%2F02%2F05%2FMybatis%2F</url>
      <content type="text"><![CDATA[入门实例+配置文件log4j.properties(公用文件)123456# Global logging configuration，建议开发环境中要用debuglog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n SqlMapConfig.xml(公用文件)通过SqlMapConfig.xml加载mybatis运行环境。12345678910111213141516171819202122232425&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理--&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载mapper.xml --&gt; &lt;mappers&gt; &lt;mapper resource="sqlmap/User.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; pojo（User.java）123456789101112131415161718192021222324package cn.itcast.mybatis.po;import java.util.Date;public class User &#123; private int id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; // ......继续写getter setter方法，限于篇幅省略 @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", sex=" + sex + ", birthday=" + birthday + ", address=" + address + "]"; &#125;&#125; User.xml建议命名规则：表名+mapper.xml早期ibatis命名规则：表名.xmlUser.xml1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace命名空间，为了对sql语句进行隔离，方便管理 ，mapper开发dao方式，使用namespace有特殊作用mapper代理开发时将namespace指定为mapper接口的全限定名 --&gt;&lt;mapper namespace="test"&gt;&lt;!-- 在mapper.xml文件中配置很多的sql语句，执行每个sql语句时，封装为MappedStatement对象mapper.xml以statement为单位管理sql语句 --&gt; &lt;!-- 根据id查询用户信息 --&gt; &lt;!-- id：唯一标识 一个statement #&#123;&#125;：表示 一个占位符，如果#&#123;&#125;中传入简单类型的参数，#&#123;&#125;中的名称随意 parameterType：输入 参数的类型，通过#&#123;&#125;接收parameterType输入 的参数 resultType：输出结果 类型，不管返回是多条还是单条，指定单条记录映射的pojo类型 --&gt; &lt;select id="findUserById" parameterType="int" resultType="cn.itcast.mybatis.po.User"&gt; SELECT * FROM USER WHERE id= #&#123;id&#125; &lt;/select&gt; 编码创建SqlSessionFactory:MybatisFirst.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.itcast.mybatis.first;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import cn.itcast.mybatis.po.User;public class MybatisFirst &#123; // 会话工厂 private SqlSessionFactory sqlSessionFactory; // 创建工厂 @Before public void init() throws IOException &#123; // 配置文件（SqlMapConfig.xml） String resource = "SqlMapConfig.xml"; // 加载配置文件到输入流 InputStream inputStream = Resources.getResourceAsStream(resource); // 创建会话工厂 sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; // 测试根据id查询用户(得到单条记录) @Test public void testFindUserById() &#123; // 通过sqlSessionFactory创建sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过sqlSession操作数据库 // 第一个参数：statement的位置，等于namespace+statement的id // 第二个参数：传入的参数 User user = null; try &#123; user = sqlSession.selectOne("test.findUserById", 2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭sqlSession sqlSession.close(); &#125; System.out.println(user); &#125;&#125; mybatis开发dao的方式SqlSession作用范围* `SqlSessionFactoryBuilder`：SqlSessionFactoryBuilder是以工具类方式来使用，需要创建sqlSessionFactory就new一个SqlSessionFactoryBuilder。 * `sqlSessionFactory`：正常开发时，以单例方式管理sqlSessionFactory，整个系统运行过程中sqlSessionFactory只有一个实例，将来和spring整合后由spring以单例方式管理sqlSessionFactory。 * `SqlSession`：sqlSession是一个面向用户（程序员）的接口，程序员调用sqlSession的接口方法进行操作数据库。 sqlSession能否以单例 方式使用？？ 由于sqlSession是线程不安全，所以sqlSession最佳应用范围在方法体内，在方法体内定义局部变量使用sqlSession。 原始dao开发方式 dao接口：UserDao.java 1234public interface UserDao &#123; //根据id查询用户信息 public User findUserById(int id) throws Exception;&#125; dao接口实现类：UserDaoImpl.java 123456789101112131415161718192021222324252627package cn.itcast.mybatis.dao;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import cn.itcast.mybatis.po.User;public class UserDaoImpl implements UserDao &#123; private SqlSessionFactory sqlSessionFactory; // 将SqlSessionFactory注入 public UserDaoImpl(SqlSessionFactory sqlSessionFactory) &#123; this.sqlSessionFactory = sqlSessionFactory; &#125; @Override public User findUserById(int id) throws Exception &#123; // 创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 根据id查询用户信息 User user = sqlSession.selectOne("test.findUserById", id); sqlSession.close(); return user; &#125;&#125; 测试类：UserDaoImplTest.java 1234567891011121314151617181920212223242526272829303132333435package cn.itcast.mybatis.dao;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import cn.itcast.mybatis.po.User;public class UserDaoImplTest &#123; // 会话工厂 private SqlSessionFactory sqlSessionFactory; // 创建工厂 @Before public void init() throws IOException &#123; // 配置文件（SqlMapConfig.xml） String resource = "SqlMapConfig.xml"; // 加载配置文件到输入流 InputStream inputStream = Resources.getResourceAsStream(resource); // 创建会话工厂 sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void testFindUserById() throws Exception &#123; UserDao userDao = new UserDaoImpl(sqlSessionFactory); User user = userDao.findUserById(1); System.out.println(user); &#125;&#125; mapper代理的方式程序员只需要写dao接口，dao接口实现对象由mybatis自动生成代理对象。本身dao在三层架构中就是一个通用的接口。 原始dao开发方式的问题： dao的实现类中存在重复代码，整个mybatis操作的过程代码模板重复（先创建sqlsession、调用sqlsession的方法、关闭sqlsession） dao的实现类中存在硬编码，调用sqlsession方法时将statement的id硬编码。 mapper开发规范：要想让mybatis自动创建dao接口实现类的代理对象，必须遵循一些规则： 1. mapper.xml中namespace指定为mapper接口的全限定名。此步骤目的：通过mapper.xml和mapper.java进行关联。 2. mapper.xml中statement的id就是mapper.java中方法名 3. mapper.xml中statement的parameterType和mapper.java中方法输入参数类型一致 4. mapper.xml中statement的resultType和mapper.java中方法返回值类型一致 mapper.xml（映射文件） config文件夹下新建mapper目录。 mapper映射文件的命名方式建议：表名Mapper.xml namespace指定为mapper接口的全限定名 12345678&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace命名空间，为了对sql语句进行隔离，方便管理 ，mapper开发dao方式，使用namespace有特殊作用mapper代理开发时将namespace指定为mapper接口的全限定名--&gt;&lt;mapper namespace="cn.itcast.mybatis.mapper.UserMapper"&gt;&lt;/mapper&gt; mapper接口 mybatis提出了mapper接口，相当于dao接口。 mapper接口的命名方式建议：表名Mapper UserMapper.java 1234public interface UserMapper &#123; //根据用户id查询用户信息 public User findUserById(int id) throws Exception;&#125; 将mapper.xml在SqlMapConfig.xml中加载 1234&lt;mappers&gt; &lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt; &lt;mapper resource=&quot;mapper/UserMapper.xml&quot; /&gt;&lt;/mappers&gt; 测试 12345678910111213141516171819202122232425262728293031323334353637383940package cn.itcast.mybatis.mapper;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import cn.itcast.mybatis.po.User;public class UserMapperTest &#123; // 会话工厂 private SqlSessionFactory sqlSessionFactory; // 创建工厂 @Before public void init() throws IOException &#123; // 配置文件（SqlMapConfig.xml） String resource = "SqlMapConfig.xml"; // 加载配置文件到输入流 InputStream inputStream = Resources.getResourceAsStream(resource); // 创建会话工厂 sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void testFindUserById() throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); // 创建代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.findUserById(1); System.out.println(user); &#125;&#125; mapper接口返回单个对象和集合对象不管查询记录是单条还是多条，在 statement中resultType定义一致，都是单条记录映射的pojo类型。mapper接口方法返回值，如果是返回的单个对象，返回值类型是pojo类型，生成的代理对象内部通过selectOne获取记录，如果返回值类型是集合对象，生成的代理对象内部通过selectList获取记录。12345//根据用户id查询用户信息public User findUserById(int id) throws Exception;//根据用户名称 查询用户信息public List&lt;User&gt; findUserByName(String username) throws Exception; sqlMapConfig.xmlSqlMapConfig.xml中配置的内容和顺序如下：1234567891011properties（属性）settings（全局配置参数）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境集合属性对象） environment（环境子属性对象） transactionManager（事务管理） dataSource（数据源）mappers（映射器） properties属性定义可以把一些通用的属性值配置在属性文件中，加载到mybatis运行环境内。比如：创建db.properties配置数据库连接参数。123456&lt;!-- 属性定义加载一个properties文件，在properties标签中配置属性值 --&gt;&lt;properties resource="db.properties"&gt; &lt;!-- &lt;property name="" value=""/&gt; --&gt;&lt;/properties&gt; 注意： MyBatis 将按照下面的顺序来加载属性： 在properties元素体内定义的属性property首先被读取。 然后会读取properties元素中resource或url加载的属性，它会覆盖已读取的同名属性。 最后读取parameterType传递的属性，它会覆盖已读取的同名属性。建议使用properties，不要在properties中定义属性，只引用定义的properties文件中属性，并且properties文件中定义的key要有一些特殊的规则。 settings全局参数配置mybatis运行时可以调整一些全局参数（相当于软件的运行参数），参考：mybatis-settings.xlsx根据使用需求进行参数配置。注意：小心配置，配置参数会影响mybatis的执行。 ibatis的全局配置参数中包括很多的性能参数（最大线程数，最大待时间…），通过调整这些性能参数使ibatis达到高性能的运行，mybatis没有这些性能参数，由mybatis自动调节。 typeAliases类型别名(常用)可以将parameterType、resultType中指定的类型 通过别名引用。 mybaits提供了很多别名：123456789101112131415161718192021别名 映射的类型_byte byte_long long_short short_int int_integer int_double double_float float_boolean booleanstring Stringbyte Bytelong Longshort Shortint Integerinteger Integerdouble Doublefloat Floatboolean Booleandate Datedecimal BigDecimalbigdecimal BigDecimal 自定义别名：123456789&lt;!-- 定义 别名 --&gt;&lt;typeAliases&gt; &lt;!-- 单个别名的定义 alias：别名，type：别名映射的类型 --&gt; &lt;!-- &lt;typeAlias type="cn.itcast.mybatis.po.User" alias="user"/&gt; --&gt; &lt;!-- 批量别名定义：指定包路径，自动扫描包下边的pojo，定义别名，别名默认为类名（首字母小写或大写） --&gt; &lt;package name="cn.itcast.mybatis.po"/&gt;&lt;/typeAliases&gt; 使用别名：在parameterType、resultType中使用别名：UserMapper.xml12345678910&lt;!-- 根据id查询用户信息 --&gt;&lt;!-- id：唯一标识 一个statement #&#123;&#125;：表示一个占位符，如果#&#123;&#125;中传入简单类型的参数，#&#123;&#125;中的名称随意 parameterType：输入参数的类型，通过#&#123;&#125;接收parameterType输入 的参数 resultType：输出结果类型，不管返回是多条还是单条，指定单条记录映射的pojo类型 --&gt;&lt;select id="findUserById" parameterType="int" resultType="user"&gt; SELECT * FROM USER WHERE id= #&#123;id&#125;&lt;/select&gt; 123456789101112131415161718192021222324public class UserMapperTest &#123; // 会话工厂 private SqlSessionFactory sqlSessionFactory; // 创建工厂 @Before public void init() throws IOException &#123; // 配置文件（SqlMapConfig.xml） String resource = "SqlMapConfig.xml"; // 加载配置文件到输入 流 InputStream inputStream = Resources.getResourceAsStream(resource); // 创建会话工厂 sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void testFindUserById() throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); // 创建代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.findUserById(1); System.out.println(user); &#125;&#125; typeHandlers类型处理器将java类型和jdbc类型进行映射。mybatis默认提供很多类型处理器，一般情况下够用了。 mappers（映射器）通过class引用mapper接口class：配置mapper接口全限定名要求：需要mapper.xml和mapper.java同名并且在一个目录中SqlMapConfig.xml123456&lt;!--加载mapper映射如果将和spring整合后，可以使用整合包中提供的mapper扫描器，此处的mappers不用配置了。 --&gt;&lt;mappers&gt; &lt;mapper class="cn.itcast.mybatis.mapper.UserMapper"/&gt;&lt;/mappers&gt; 批量mapper配置通过package进行自动扫描包下边的mapper接口要求：需要mapper.xml和mapper.java同名并且在一个目录中123&lt;mappers&gt; &lt;package name="cn.itcast.mybatis.mapper"/&gt;&lt;/mappers&gt; 输入和输出映射通过parameterType完成输入映射，通过resultType和resultMap完成输出映射。 parameterType传递pojo包装对象可以定义pojo包装类型扩展mapper接口输入参数的内容。 需求：自定义查询条件查询用户信息，需要向statement输入查询条件，查询条件可以有user信息、商品信息… 包装类型 UserQueryVo.java 123456public class UserQueryVo &#123; //用户信息 private User user; //自定义user的扩展对象 private UserCustom userCustom;&#125; UserCustom.java 123public class UserCustom extends User &#123; //添加一些扩展字段&#125; mapper.xml 自定义查询条件查询用户的信息 parameterType：指定包装类型 %${userCustom.username}%：userCustom是userQueryVo中的属性，通过OGNL获取属性的值 123&lt;select id="findUserList" parameterType="userQueryVo" resultType="user"&gt; select * from user where username like '%$&#123;userCustom.username&#125;%'&lt;/select&gt; mapper.java（接口） 1234public interface UserMapper &#123; //自定义查询条件查询用户信息 public List&lt;User&gt; findUserList(UserQueryVo userQueryVo) throws Exception;&#125; 测试 UserMapperTest.java 1234567891011121314151617181920// 通过包装类型查询用户信息@Testpublic void testFindUserList() throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); // 创建代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 构造查询条件 UserQueryVo userQueryVo = new UserQueryVo(); UserCustom userCustom = new UserCustom(); userCustom.setUsername("小明"); userCustom.setSex("1"); userQueryVo.setUserCustom(userCustom); List&lt;User&gt; list = userMapper.findUserList(userQueryVo); sqlSession.close(); System.out.println(list);&#125; 异常 如果parameterType中指定属性错误，异常，找不到getter方法。 注意：如果将来和spring整合后，不是通过调用getter方法来获取属性值，通过反射强读取pojo的属性值。 resultType指定输出结果的类型（pojo、简单类型、hashmap…），将sql查询结果映射为java对象。 返回简单类型 输出简单类型 功能：自定义查询条件，返回查询记录个数，通常用于实现查询分页 UserMapper.xml 123&lt;select id="findUserCount" parameterType="userQueryVo" resultType="int"&gt; select count(*) from user where username like '%$&#123;userCustom.username&#125;%'&lt;/select&gt; UserMapper.java 12//查询用户，返回记录个数public int findUserCount(UserQueryVo userQueryVo) throws Exception; UserMapperTest.java 123456789101112131415161718// 返回查询记录总数@Testpublic void testFindUserCount() throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); // 创建代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 构造查询条件 UserQueryVo userQueryVo = new UserQueryVo(); UserCustom userCustom = new UserCustom(); userCustom.setUsername("小明"); userQueryVo.setUserCustom(userCustom); int count = userMapper.findUserCount(userQueryVo); sqlSession.close(); System.out.println(count);&#125; 注意：如果查询记录结果集为一条记录且一列再使用返回简单类型。 resultMap(入门)resultType ：指定输出结果的类型（pojo、简单类型、hashmap..），将sql查询结果映射为java对象 。注意：sql查询的列名要和resultType指定pojo的属性名相同，指定相同属性方可映射成功，如果sql查询的列名要和resultType指定pojo的属性名全部不相同，list中无法创建pojo对象的。 resultMap：将sql查询结果映射为java对象。如果sql查询列名和最终要映射的pojo的属性名不一致，使用resultMap将列名和pojo的属性名做一个对应关系 （列名和属性名映射配置） resultMap配置 12345678910111213&lt;!-- 定义resultMap，列名和属性名映射配置 id：mapper.xml中的唯一标识 type：最终要映射的pojo类型 --&gt;&lt;resultMap id="userListResultMap" type="user" &gt; &lt;!-- 列名 id_,username_,birthday_ id：要映射结果集的唯 一标识 ，称为主键 column：结果集的列名 property：type指定的哪个属性中 --&gt; &lt;id column="id_" property="id"/&gt; &lt;!-- result就是普通列的映射配置 --&gt; &lt;result column="username_" property="username"/&gt; &lt;result column="birthday_" property="birthday"/&gt;&lt;/resultMap&gt; resultMap使用 使用resultMap作结果映射 resultMap：如果引用resultMap的位置和resultMap的定义在同一个mapper.xml，直接使用resultMap的id，如果不在同一个mapper.xml要在resultMap的id前边加namespace 123&lt;select id="findUserListResultMap" parameterType="userQueryVo" resultMap="userListResultMap"&gt; select id id_,username username_,birthday birthday_ from user where username like '%$&#123;userCustom.username&#125;%'&lt;/select&gt; mapper.java 12//查询用户，使用resultMap进行映射public List&lt;User&gt; findUserListResultMap(UserQueryVo userQueryVo)throws Exception; mybatis和spring整合mybaits和spring整合的思路1、让spring管理SqlSessionFactory2、让spring管理mapper对象和dao 使用spring和mybatis整合开发mapper代理及原始dao接口。 自动开启事务，自动关闭 sqlsession.3、让spring管理数据源( 数据库连接池) 创建整合工程加入jar包1、mybatis3.2.7本身的jar包2、数据库驱动包3、spring3.2.04、spring和mybatis整合包 从mybatis的官方下载spring和mybatis整合包 log4j.propertiesSqlMapconfig.xmlmybatis配置文件：别名、settings，数据源不在这里配置 applicationContext.xml1、数据源（dbcp连接池）2、SqlSessionFactory3、mapper或dao 整合开发原始dao接口 配置SqlSessionFactory applicationContext.xml 1234567&lt;!-- SqlsessionFactory --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- mybatis配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis/SqlMapConfig.xml"/&gt;&lt;/bean&gt; 开发dao UserDaoImpl.java 12345678910111213package cn.itcast.mybatis.dao;public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao &#123; @Override public User findUserById(int id) throws Exception &#123; // 创建SqlSession SqlSession sqlSession = this.getSqlSession(); // 根据id查询用户信息 User user = sqlSession.selectOne("test.findUserById", id); return user; &#125;&#125; 配置dao applicationContext.xml 1234&lt;!-- 配置dao(先开发daoUserDaoImpl.java) --&gt;&lt;bean id="userDao" class="cn.itcast.mybatis.dao.UserDaoImpl"&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"/&gt;&lt;/bean&gt; 测试dao接口 UserDaoImplTest.java 12345678910111213141516public class UserDaoImplTest &#123; private ApplicationContext applicationContext; @Before public void setUp() throws Exception &#123; //创建spring容器 applicationContext = new ClassPathXmlApplicationContext("spring/applicationContext.xml"); &#125; @Test public void testFindUserById() throws Exception &#123; //从spring容器中获取UserDao这个bean UserDao userDao = (UserDao) applicationContext.getBean("userDao"); User user = userDao.findUserById(1); System.out.println(user); &#125;&#125; 整合开发mapper代理方法 开发mapper.xml和mapper.java UserMapper.java和UserMapper.xml 使用MapperFactoryBean（繁琐，不推荐） applicationContext.xml 12345678910&lt;!-- 配置mapper (MapperFactoryBean：用于生成mapper代理对象) --&gt;&lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="cn.itcast.mybatis.mapper.UserMapper"/&gt; 指定接口类型 &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"/&gt; 因为它也集成了SqlSessionDaoSupport，所以把它也注入进去&lt;/bean&gt;&lt;bean id="itemMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="cn.itcast.mybatis.mapper.UserMapper"/&gt; 指定接口类型 &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"/&gt; 因为它也集成了SqlSessionDaoSupport，所以把它也注入进去&lt;/bean&gt;&lt;!-- ......这样很繁琐，每个mapper都要配置 --&gt; 使用此方法对于每个mapper都需要配置，比较繁琐。 使用MapperScannerConfigurer（扫描mapper，推荐） applicationContext.xml 1234567&lt;!-- MapperScannerConfigurer：mapper的扫描器，将包下边的mapper接口自动创建代理对象，自动创建到spring容器中，bean的id是mapper的类名（首字母小写） --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 配置扫描包的路径(如果要扫描多个包，中间使用半角逗号分隔) --&gt; &lt;property name="basePackage" value="cn.itcast.mybatis.mapper"/&gt; &lt;!-- 使用sqlSessionFactoryBeanName而不使用sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt;&lt;/bean&gt; 使用扫描器自动扫描mapper，生成代理对象，比较方便。 测试mapper接口 UserMapperTest.java 12345678910111213141516public class UserMapperTest &#123; private ApplicationContext applicationContext; @Before public void setUp() throws Exception &#123; // 创建spring容器 applicationContext = new ClassPathXmlApplicationContext("spring/applicationContext.xml"); &#125; @Test public void testFindUserById() throws Exception &#123; UserMapper userMapper = (UserMapper) applicationContext.getBean("userMapper"); User user = userMapper.findUserById(1); System.out.println(user); &#125;&#125; 逆向工程(MyBatis Generator)mybatis官方为了提高开发效率，提高自动对单表生成sql，包括 ：mapper.xml、mapper.java、表名.java(po类) 在企业开发中通常是在设计阶段对表进行设计、创建。在开发阶段根据表结构创建对应的po类。 mybatis逆向工程的方向：由数据库表—-》java代码 使用配置 xml配置 需要使用用配置的地方： 1、连接数据库的地址和驱动 Mysql配置 123&lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/mybatis" userId="root" password="123"&gt;&lt;/jdbcConnection&gt; Oracle配置 12345&lt;jdbcConnection driverClass="oracle.jdbc.OracleDriver" connectionURL="jdbc:oracle:thin:@127.0.0.1:1521:yycg" userId="yycg" password="yycg"&gt;&lt;/jdbcConnection&gt; 2、需要配置po类的包路径 12345678&lt;!-- targetProject:生成PO类的位置 --&gt;&lt;javaModelGenerator targetPackage="cn.itcast.mybatis.po" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name="trimStrings" value="true" /&gt;&lt;/javaModelGenerator&gt; 3、需要配置mapper包的路径 12345678910111213&lt;!-- targetProject:mapper映射文件生成的位置 --&gt;&lt;sqlMapGenerator targetPackage="cn.itcast.mybatis.mapper" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt;&lt;/sqlMapGenerator&gt;&lt;!-- targetPackage：mapper接口生成的位置 --&gt;&lt;javaClientGenerator type="XMLMAPPER" targetPackage="cn.itcast.mybatis.mapper" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt;&lt;/javaClientGenerator&gt; 4、指定数据表 123&lt;table tableName="items"&gt;&lt;/table&gt;&lt;table tableName="orders"&gt;&lt;/table&gt;&lt;table tableName="orderdetail"&gt;&lt;/table&gt; generatorConfig.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfigurationPUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN""http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;context id="testTables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!--1.数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/mybatis" userId="root" password="123"&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 2.targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage="cn.itcast.mybatis.po" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- 3.targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage="cn.itcast.mybatis.mapper" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 3.targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="cn.itcast.mybatis.mapper" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 4.指定数据库表 --&gt; &lt;table tableName="items"&gt;&lt;/table&gt; &lt;table tableName="orders"&gt;&lt;/table&gt; &lt;table tableName="orderdetail"&gt;&lt;/table&gt; &lt;!-- &lt;table schema="" tableName="sys_user"&gt;&lt;/table&gt; &lt;table schema="" tableName="sys_role"&gt;&lt;/table&gt; &lt;table schema="" tableName="sys_permission"&gt;&lt;/table&gt; &lt;table schema="" tableName="sys_user_role"&gt;&lt;/table&gt; &lt;table schema="" tableName="sys_role_permission"&gt;&lt;/table&gt; --&gt; &lt;!-- 有些表的字段需要指定java类型 &lt;table schema="" tableName=""&gt; &lt;columnOverride column="" javaType="" /&gt; &lt;/table&gt; --&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; java程序 通过java程序生成mapper类、po类 GeneratorSqlmap.java 123456789101112131415161718192021222324252627282930313233import java.io.File;import java.io.IOException;import java.util.ArrayList;import java.util.List;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.exception.XMLParserException;import org.mybatis.generator.internal.DefaultShellCallback;public class GeneratorSqlmap &#123; public void generator() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; //指定逆向工程配置文件 File configFile = new File("generatorConfig.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; public static void main(String[] args) throws Exception &#123; try &#123; GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap(); generatorSqlmap.generator(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用逆向工程生成的代码 第一步配置generatorConfig.xml 第二步配置执行java程序 第三步将生成的代码拷贝到工程中Items.java ItemsExample.java ItemsMapper.java ItemsMapper.xml 测试生成的代码 ItemsMapperTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package cn.itcast.mybatis.mapper;public class ItemsMapperTest &#123; private ApplicationContext applicationContext; private ItemsMapper itemsMapper; @Before public void setUp() throws Exception &#123; // 创建spring容器 applicationContext = new ClassPathXmlApplicationContext( "spring/applicationContext.xml"); itemsMapper = (ItemsMapper) applicationContext.getBean("itemsMapper"); &#125; // 根据主键删除 @Test public void testDeleteByPrimaryKey() &#123; itemsMapper.deleteByPrimaryKey(4); // 自定义条件删除 // itemsMapper.deleteByExample(example) &#125; @Test public void testInsert() &#123; Items items = new Items(); items.setName("手机"); items.setPrice(3000.0f); itemsMapper.insert(items); &#125; // 自定义条件查询 @Test public void testSelectByExample() &#123; ItemsExample itemsExample = new ItemsExample(); ItemsExample.Criteria criteria = itemsExample.createCriteria(); criteria.andNameEqualTo("笔记本2"); // criteria.andNameLike("笔记本"); List&lt;Items&gt; list = itemsMapper.selectByExample(itemsExample); System.out.println(list); // 将大文本字段也查询出来 // itemsMapper.selectByExampleWithBLOBs(example) &#125; // 根据主键查询 @Test public void testSelectByPrimaryKey() &#123; Items items = itemsMapper.selectByPrimaryKey(1); System.out.println(items); &#125; @Test public void testUpdateByPrimaryKey() &#123; // 将更新对象的内容全部更新到数据库 // updateByPrimaryKey通过是先查询再设置更新字段的值 Items items = itemsMapper.selectByPrimaryKey(1); items.setName("笔记 本4"); itemsMapper.updateByPrimaryKey(items); //自定义条件更新，example设置条件，record是更新对象// itemsMapper.updateByExample(record, example) //可以更新大文本字段// itemsMapper.updateByExampleWithBLOBs(record, example) &#125; @Test public void testUpdateByPrimaryKeySelective() &#123; // 如果更新对象的属性不为空才更新到数据库 // 常用于指定字段更新，不用先查询出，可以直接new一个对象，此对象一定要设置id主键，再设置更新字段的值 Items items = new Items(); items.setId(1); items.setName("笔记 本5"); itemsMapper.updateByPrimaryKeySelective(items); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[dbutils]]></title>
      <url>%2F2017%2F02%2F05%2Fdbutils%2F</url>
      <content type="text"><![CDATA[元数据元数据(metaData)：指数据库中 库、表、列的定义信息 DataBaseMetaData 数据库元数据（了解） 123456789101112131415161718192021222324252627问题:怎样获取一个DataBaseMetaData? Connection接口中定义了一个方法 getMetaData();问题:常用API String driverName = dmd.getDriverName(); //获取驱动名称:getDriverName System.out.println(driverName); String userName = dmd.getUserName(); //获取用户名:getUserName System.out.println(userName); String url = dmd.getURL(); //获取url:getURL System.out.println(url); String databaseProductName = dmd.getDatabaseProductName(); //获取数据库名称:getDatabaseProductName System.out.println(databaseProductName); String databaseProductVersion = dmd.getDatabaseProductVersion();//获取数据库版本:getDatabaseProductVersion System.out.println(databaseProductVersion); ResultSet getPrimaryKeys(String catalog, String schema, String table) throws SQLException //获取表中主键相关描述 每个主键列描述都有以下列： TABLE_CAT String =&gt; 表类别（可为null） TABLE_SCHEM String =&gt; 表模式（可为null） TABLE_NAME String =&gt; 表名称 COLUMN_NAME String =&gt; 列名称 KEY_SEQ short =&gt; 主键中的序列号（值 1 表示主键中的第一列，值 2 表示主键中的第二列）。 PK_NAME String =&gt; 主键的名称（可为 null） ParameterMetaData 参数元数据 123456789101112131415161718参数元数据主要用于获取:sql语句中占位符的相关信息.问题:怎样获取ParameterMetaData? 在PreparedStatement中有一个方法getParameterMetaData可以获取.问题:怎样使用? int count = pmd.getParameterCount(); // 获取参数 个数 System.out.println(count); String type1 = pmd.getParameterTypeName(1);//获取参数的类型 System.out.println(type1); 注意：在获取参数类型时会产生异常 java.sql.SQLException: Parameter metadata not available for the given statement 解决方案: 在url后添加参数 jdbc:mysql:///day18?generateSimpleParameterMetadata=true 添加这个参数后，我们在获取，它的结果也是varchar,原因:是mysql驱动的支持问题。 ResultSetMetaData 结果集元数据 1234567问题:怎样获取结果集元数据? 可以通过ResultSet的getMetaData()方法获取.问题:怎样使用? System.out.println(rsmd.getColumnCount()); //获取结果集中列数量 System.out.println(rsmd.getColumnName(2)); //获取结果集中指定列的名称. System.out.println(rsmd.getColumnTypeName(3)); //获取结果集中指定列的类型。 dbutils工具它就是一个简单的jdbc封装工具.使用dbutils可以简化操作.要使用dbutils需要导入jar包. dbutils核心： QueryRunner类 它是用于执行sql语句的类。 query 用于执行select update 用于执行update delete insert batch 批处理 ResultSetHandler接口 用于定义结果集的封装 它提供九个实现类，可以进行不同的封装。 DbUtils类 它提供关于关闭资源close以及事务rollback,commit操作。 Dbutlis详解： QueryRunner类 QueryRunner怎样获取 new QueryRunner() 如果是使用这种构造创建的QueryRunner,它的事务是手动控制。 123456789String sql = "select * from account where id&gt;? and name=?";QueryRunner runner = new QueryRunner(); //事务手动控制Connection con = DataSourceUtils.getConnection();// con.setAutoCommit(false);List&lt;Account&gt; list = runner.query(con,sql,new BeanListHandler&lt;Account&gt;(Account.class),2,"ccc");// con.rollback();System.out.println(list); new QueryRunner(DataSource ds); 如果是使用这种构造，它的事务是自动事务，简单说，一条sql一个事务。 12345String sql = "select * from account where id=?";QueryRunner runner = new QueryRunner(DataSourceUtils.getDataSource()); //自动事务List&lt;Account&gt; list = runner.query(sql,new BeanListHandler&lt;Account&gt;(Account.class),2);System.out.println(list); QueryRunner中的三个核心方法 query update batch 对于上述三个方法，它们提供很多重载。 如果QueryRunner在创建时，没有传递DataSource参数，那么在使用query,update,batch方法时，要传递Connection参数 如果QueryRunner在创建时，传递了Dataource参数，那么在使用query,update,batch方法时，不需要传递Connection参数。 总结: 怎样配套使用: 123456789QueryRunner runner=new QueryRunner();runner.query(Connection,sql,ResultSetHandler,Object... param);runner.update(Connection,sql,Object...param);runner.batch(Connection con,sql,Object[][] objs);QueryRunner runner=new QueryRunner(DataSource ds);runner.query(sql,ResultSetHandler,Object... param);runner.update(sql,Object...param);runner.batch(sql,Object[][] objs); ResultSetHandler接口 用于封装结果集. 1234567891011121314151617181920// 将结果封装到一个javaBeanString sql = "select * from account where id=?";QueryRunner runner = new QueryRunner(DataSourceUtils.getDataSource());Account a = runner.query(sql, new ResultSetHandler&lt;Account&gt;() &#123; //ResultSetHandler上的泛型就是我们执行query方法后得到的结果. //重写handle方法，在这个方法中确定，怎样将结果集封装。 public Account handle(ResultSet rs) throws SQLException &#123; Account a = null; if (rs.next()) &#123; a = new Account(); a.setId(rs.getInt("id")); a.setName(rs.getString("name")); a.setMoney(rs.getDouble("money")); &#125; return a; &#125; &#125;, 2);System.out.println(a); 模仿QueryRunner实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class MyQueryRunner &#123; private DataSource ds; public MyQueryRunner() &#123; super(); &#125; public MyQueryRunner(DataSource ds) &#123; this.ds = ds; &#125; // 执行select操作 public &lt;T&gt; T query(Connection con, String sql, MyResultSetHandler&lt;T&gt; mrs, Object... params) throws SQLException &#123; PreparedStatement pst = con.prepareStatement(sql); // 得到一个预处理的Statement. // 问题:sql语句中可能存在参数，需要对参数赋值。 ParameterMetaData pmd = pst.getParameterMetaData(); // 可以得到有几个参数 int count = pmd.getParameterCount(); for (int i = 1; i &lt;= count; i++) &#123; pst.setObject(i, params[i - 1]); &#125; ResultSet rs = pst.executeQuery(); // 得到了结果集，要将结果集封装成用户想要的对象，但是，工具不可能知道用户需求。 return mrs.handle(rs); &#125; // 执行update操作 public int update(Connection con, String sql, Object... params) throws SQLException &#123; PreparedStatement pst = con.prepareStatement(sql); // 得到一个预处理的Statement. // 问题:sql语句中可能存在参数，需要对参数赋值。 ParameterMetaData pmd = pst.getParameterMetaData(); // 可以得到有几个参数 int count = pmd.getParameterCount(); for (int i = 1; i &lt;= count; i++) &#123; pst.setObject(i, params[i - 1]); &#125; int row = pst.executeUpdate(); // 关闭资源 pst.close(); return row; &#125; public int update(String sql, Object... params) throws SQLException &#123; Connection con = ds.getConnection(); PreparedStatement pst = con.prepareStatement(sql); // 得到一个预处理的Statement. // 问题:sql语句中可能存在参数，需要对参数赋值。 ParameterMetaData pmd = pst.getParameterMetaData(); // 可以得到有几个参数 int count = pmd.getParameterCount(); for (int i = 1; i &lt;= count; i++) &#123; pst.setObject(i, params[i - 1]); &#125; int row = pst.executeUpdate(); // 关闭资源 pst.close(); con.close(); return row; &#125;&#125; ResulSetHandler九个实现类介绍ArrayHandler, 将结果集中第一条记录封装到Object[],数组中的每一个元素就是记录中的字段值。ArrayListHandler, 将结果集中每一条记录封装到Object[],数组中的每一个元素就是记录中的字段值。在将这些数组装入到List集合 BeanHandler（重点）, 将结果集中第一条记录封装到一个javaBean中。BeanListHandler(重点), 将结果集中每一条记录封装到javaBean中，在将javaBean封装到List集合. ColumnListHandler, 将结果集中指定列的值封装到List集合.(无参默认第一列) MapHandler, 将结果集中第一条记录封装到Map集合中，集合的key就是字段名称，value就是字段值MapListHandler, 将结果集中每一条记录封装到Map集合中，集合的key就是字段名称，value就是字段值，再将这些Map封装到List集合 KeyedHandler,在使用指定的列的值做为一个Map集合的key,值为每一条记录的Map集合封装。ScalarHandler 进行单值查询 select count(*) from account;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[事务与连接池]]></title>
      <url>%2F2017%2F02%2F04%2F%E4%BA%8B%E5%8A%A1%E4%B8%8E%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
      <content type="text"><![CDATA[事务事务就是一个事情，组成这个事情可能有多个单元，要求这些单元，要么全都成功，要么全都不成功。在开发中，有事务的存在，可以保证数据完整性。 事务的操作123456789create table account( id int primary key auto_increment, name varchar(20), money double);insert into account values(null,'aaa',1000);insert into account values(null,'bbb',1000);insert into account values(null,'ccc',1000); mysql下怎样操作方式1:start transaction 开启事务rollback 事务回滚(回滚到最开始位置)commit 事务提交(没有commit就不会修改数据)方式2:show variables like &#39;%commit%&#39;; 可以查看当前autocommit值.在mysql数据库中它的默认值是”on”,代表自动事务(执行任何一条mysql语句都会自动提交事务).测试:将autocommit的值设置为off 1.set autocommit=off 关闭自动事务。 2.必须手动commit才可以将事务提交。 注意:mysql默认autocommit=on oracle默认的autocommit=off; jdbc下怎样操作 java.sql.Connection接口中有几个方法是用于可以操作事务 1.setAutocommit(boolean flag) 如果flag=false;它就相当于start transaction; 2.rollBack() 事务回滚 3.commit() 事务提交 123456789101112131415161718192021222324// 随便抛异常版，仅限演示，开发中不这么写public class TransactionTest1 &#123; public static void main(String[] args) throws SQLException &#123; // 修改id=2这个人的money=500; String sql = "update account set money=500 where id=2"; Connection con = JdbcUtils.getConnection(); con.setAutoCommit(false); //开启事务，相当于 start transaction; Statement st = con.createStatement(); st.executeUpdate(sql); //事务回滚 //con.rollback(); con.commit(); //事务提交 st.close(); con.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738// 开发中应该这么写public class TransactionTest2 &#123; public static void main(String[] args) &#123; // 修改id=2这个人的money=500; String sql = "update account set money=500 where id=2"; Connection con = null; Statement st = null; try &#123; con = JdbcUtils.getConnection(); con.setAutoCommit(false); // 开启事务，相当于 start transaction; st = con.createStatement(); st.executeUpdate(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); // 事务回滚 try &#123; con.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; try &#123; con.commit(); // 事务提交 st.close(); con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 事务特性(重点) 原子性：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性：事务前后数据的完整性必须保持一致。 隔离性：多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。 持久性：一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。 如果不考虑事务的隔离性，会出现什么问题？ 脏读：一个事务读取到另一个事务的未提交数据 不可重复读：两次读取的数据不一致(强调update) 虚读(幻读)：两次读取的数据不一致(强调insert) 丢失更新：两个事务对同一条记录进行操作，后提交的事务，将先提交的事务的修改覆盖了。解决方案 事务的隔离级别有哪些? Serializable：可避免脏读、不可重复读、虚读情况的发生。（串行化） Repeatable read：可避免脏读、不可重复读情况的发生。（可重复读）不可以避免虚读 Read committed：可避免脏读情况发生（读已提交） Read uncommitted：最低级别，以上情况均无法保证。(读未提交) 怎样设置事务的隔离级别? 1.mysql中设置 1234561.查看事务隔离级别 select @@tx_isolation 查询当前事务隔离级别(默认为Repeatable read). 扩展:oracle中默认是Read committed2.mysql中怎样设置事务隔离级别 set session transaction isolation level 事务隔离级别 2.jdbc中设置 123456789使用java.sql.Connection接口中提供的方法 void setTransactionIsolation(int level) throws SQLException 参数level可以取以下值: level - 以下 Connection 常量之一： Connection.TRANSACTION_READ_UNCOMMITTED、 Connection.TRANSACTION_READ_COMMITTED、 Connection.TRANSACTION_REPEATABLE_READ Connection.TRANSACTION_SERIALIZABLE。 （注意，不能使用 Connection.TRANSACTION_NONE，因为它指定了不受支持的事务。） 演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061621.脏读 一个事务读取到另一个事务的为提交数据 设置A,B事务隔离级别为 Read uncommitted set session transaction isolation level read uncommitted; 1.在A事务中 start transaction; update account set money=money-500 where name=&apos;aaa&apos;; update account set money=money+500 where name=&apos;bbb&apos;; 2.在B事务中 start transaction; select * from account; 这时，B事务读取时，会发现，钱已经汇完。那么就出现了脏读。 当A事务提交前，执行rollback，在commit， B事务在查询，就会发现，钱恢复成原样 也出现了两次查询结果不一致问题，出现了不可重复读.2.解决脏读问题 将事务的隔离级别设置为 read committed来解决脏读 设置A,B事务隔离级别为 Read committed set session transaction isolation level read committed; 1.在A事务中 start transaction; update account set money=money-500 where name=&apos;aaa&apos;; update account set money=money+500 where name=&apos;bbb&apos;; 2.在B事务中 start transaction; select * from account; 这时B事务中，读取信息时，是不能读到A事务未提交的数据的，也就解决了脏读。 让A事务，提交数据 commit; 这时，在查询，这次结果与上一次查询结果又不一样了，还存在不可重复读。3.解决不可重复读 将事务的隔离级别设置为Repeatable read来解决不可重复读。 设置A,B事务隔离级别为 Repeatable read; set session transaction isolation level Repeatable read; 1.在A事务中 start transaction; update account set money=money-500 where name=&apos;aaa&apos;; update account set money=money+500 where name=&apos;bbb&apos;; 2.在B事务中 start transaction; select * from account; 当A事务提交后commit;B事务在查询，与上次查询结果一致，解决了不可重复读。4.设置事务隔离级别Serializable ,它可以解决所有问题 set session transaction isolation level Serializable; 如果设置成这种隔离级别，那么会出现锁表。也就是说，一个事务在对表进行操作时， 其它事务操作不了。 总结 123456789101112131415脏读:一个事务读取到另一个事务为提交数据不可重复读:两次读取数据不一致(读提交数据)---update虚读:两次读取数据不一致(读提交数据)----insert事务隔离级别: read uncommitted 什么问题也解决不了. read committed 可以解决脏读，其它解决不了. Repeatable read 可以解决脏读，可以解决不可重复读,不能解决虚读. Serializable 它会锁表，可以解决所有问题. 安全性：serializable &gt; repeatable read &gt; read committed &gt; read uncommitted 性能 ：serializable &lt; repeatable read &lt; read committed &lt; read uncommitted 结论： 实际开发中，通常不会选择 serializable 和 read uncommitted ， mysql默认隔离级别 repeatable read ，oracle默认隔离级别 read committed 丢失更新多个事务对同一条记录进行了操作，后提交的事务将先提交的事务操作覆盖了。解决办法： 悲观锁：（假设丢失更新一定会发生 ） —– 利用数据库内部锁机制，管理事务 提供的锁机制 1.共享锁select * from table lock in share mode（读锁、共享锁） 2.排它锁select * from table for update （写锁、排它锁） update语句默认添加排它锁 乐观锁：（假设丢失更新不会发生） —– 采用程序中添加版本字段解决丢失更新问题 解决丢失更新：在数据表添加版本字段，每次修改过记录后，版本字段都会更新，如果读取是版本字段，与修改时版本字段不一致，说明别人进行修改过数据 （重改） 连接池就是创建一个容器，用于装入多个Connection对象，在使用连接对象时，从容器中获取一个Connection，使用完成后，在将这个Connection重新装入到容器中。这个容器就是连接池。(DataSource)也叫做数据源.我们可以通过连接池获取连接对象.优点:节省创建连接与释放连接 性能消耗 —- 连接池中连接起到复用的作用 ，提高程序性能 自定义连接池 创建一个MyDataSource类，在这个类中创建一个LinkedList&lt;Connection&gt; 12private LinkedList&lt;Connection&gt; ll;ll = new LinkedList&lt;Connection&gt;(); 在其构造方法中初始化List集合，并向其中装入5个Connection对象 1234for (int i = 0; i &lt; 5; i++) &#123; Connection con = JdbcUtils.getConnection(); ll.add(con);&#125; 创建一个public Connection getConnection() 从List集合中获取一个连接对象返回. 创建一个public void readd(Connection) 这个方法是将使用完成后的Connection对象重新装入到List集合中. 代码问题1234567891011121314151617181920211.连接池的创建是有标准的. 在javax.sql包下定义了一个接口 DataSource 简单说，所有的连接池必须实现javax.sql.DataSource接口， 我们的自定义连接池必须实现DataSource接口。2.我们操作时，要使用标准，怎样可以让 con.close()它不是销毁，而是将其重新装入到连接池. 要解决这个问题，其本质就是将Connection中的close()方法的行为改变。 怎样可以改变一个方法的行为(对方法功能进行增强) 1.继承 2.装饰模式 1.装饰类与被装饰类要实现同一个接口或继承同一个父类 2.在装饰类中持有一个被装饰类引用 3.对方法进行功能增强。 3.动态代理 可以对行为增强 Proxy.newProxyInstance(ClassLoacer ,Class[],InvocationHandler); 结论:Connection对象如果是从连接池中获取到的，那么它的close方法的行为已经改变了，不在是销毁，而是重新装入到连接池。 方法增强 继承增强（不好） 12345678910111213141516171819public class Demo1 &#123; public static void main(String[] args) &#123; Person1 p=new Student1(); p.eat(); &#125;&#125;class Person1 &#123; public void eat()&#123; System.out.println("吃两个馒头"); &#125;&#125;class Student1 extends Person1 &#123; public void eat()&#123; super.eat(); System.out.println("加两个鸡腿"); &#125;&#125; 装饰模式（不好） 动态代理 12345678910111213141516171819202122232425262728293031323334353637383940import javax.sql.DataSource;public class MyDataSource implements DataSource &#123; private LinkedList&lt;Connection&gt; ll; // 用于装Connection对象的容器。 public MyDataSource() throws SQLException &#123; ll = new LinkedList&lt;Connection&gt;(); // 当创建MyDateSource对象时，会向ll中装入5个Connection对象。 for (int i = 0; i &lt; 5; i++) &#123; Connection con = JdbcUtils.getConnection(); ll.add(con); &#125; &#125; public Connection getConnection() throws SQLException &#123; if (ll.isEmpty()) &#123; for (int i = 0; i &lt; 3; i++) &#123; Connection con = JdbcUtils.getConnection(); ll.add(con); &#125; &#125; final Connection con = ll.removeFirst(); Connection proxyCon = (Connection) Proxy.newProxyInstance(con.getClass().getClassLoader(), con.getClass().getInterfaces(), new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if ("close".equals(method.getName())) &#123; // 这代表是close方法，它要做的事情是将con对象重新装入到集合中. ll.add(con); System.out.println("重新将连接对象装入到集合中"); return null; &#125; else &#123; return method.invoke(con, args);// 其它方法执行原来操作 &#125; &#125; &#125;); return proxyCon; &#125;&#125; dbcp连接池（了解）导入两个jar包：commons-dbcp-1.4.jar和commons-pool-1.5.6.jar 手动配置(手动编码) 12345678910BasicDataSource bds = new BasicDataSource();// 需要设置连接数据库最基本四个条件bds.setDriverClassName("com.mysql.jdbc.Driver");bds.setUrl("jdbc:mysql:///day18");bds.setUsername("root");bds.setPassword("abc");// 得到一个ConnectionConnection con = bds.getConnection(); 示例： 123456789101112131415161718192021222324252627public class JdbcDemo&#123; public void test() throws Exception &#123; BasicDataSource bds = new BasicDataSource(); // 需要设置连接数据库最基本四个条件 bds.setDriverClassName("com.mysql.jdbc.Driver"); bds.setUrl("jdbc:mysql:///day18"); bds.setUsername("root"); bds.setPassword("123"); Connection con = bds.getConnection(); ResultSet rs = con.createStatement().executeQuery("select * from account"); while(rs.next())&#123; System.out.println(rs.getInt("id")+" "+rs.getString("name")); &#125; rs.close(); con.close(); &#125; public static void main(String[] args) throws Exception &#123; JdbcDemo jd = new JdbcDemo(); jd.test(); &#125;&#125; 自动配置(使用配置文件) 12345Properties props = new Properties();FileInputStream fis = new FileInputStream("D:\\java1110\\workspace\\day18_2\\src\\dbcp.properties");props.load(fis);DataSource ds = BasicDataSourceFactory.createDataSource(props); 示例： dbcp.properties 1234driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql:///day18username=rootpassword=123 JdbcDemo.java 1234567891011121314151617181920212223242526272829303132333435import org.apache.commons.dbcp2.BasicDataSource;import org.apache.commons.dbcp2.BasicDataSourceFactory;import java.sql.*;import javax.sql.DataSource;import java.io.FileInputStream;import java.util.Properties;public class JdbcDemo &#123; public void test2() throws Exception &#123; Properties props = new Properties(); // props.setProperty("driverClassName","com.mysql.jdbc.Driver"); // props.setProperty("url","jdbc:mysql:///day18"); // props.setProperty("username","root"); // props.setProperty("password","123"); FileInputStream fis = new FileInputStream("D:\\code\\java\\JDBC\\src\\dbcp.properties"); props.load(fis); DataSource ds = BasicDataSourceFactory.createDataSource(props); Connection con = ds.getConnection(); ResultSet rs = con.createStatement().executeQuery("select * from account"); while(rs.next())&#123; System.out.println(rs.getInt("id")+" "+rs.getString("name")); &#125; rs.close(); con.close(); &#125; public static void main(String[] args) throws SQLException &#123; JdbcDemo jd = new JdbcDemo(); jd.test2(); &#125;&#125; c3p0连接池（必须掌握）C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。dbcp没有自动回收空闲连接的功能，c3p0有自动回收空闲连接功能，它的性能更强大。 导入包：c3p0-0.9.5.2.jar 手动 12345ComboPooledDataSource cpds = new ComboPooledDataSource();cpds.setDriverClass("com.mysql.jdbc.Driver");cpds.setJdbcUrl("jdbc:mysql:///day18");cpds.setUser("root");cpds.setPassword("abc"); 实例： 1234567891011121314151617181920public void test() throws Exception &#123; BasicDataSource bds = new BasicDataSource(); ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass("com.mysql.jdbc.Driver"); cpds.setJdbcUrl("jdbc:mysql:///day18"); cpds.setUser("root"); cpds.setPassword("123"); Connection con = cpds.getConnection(); ResultSet rs = con.createStatement().executeQuery("select * from account"); while(rs.next())&#123; System.out.println(rs.getInt("id")+" "+rs.getString("name")); &#125; rs.close(); con.close();&#125; 自动(使用配置文件) c3p0的配置文件可以是properties也可以是xml. c3p0的配置文件如果名称叫做 c3p0.properties or c3p0-config.xml 并且放置在classpath路径下(对于web应用就是classes目录)，那么c3p0会自动查找。 注意：我们其实只需要将配置文件放置在src下就可以。 使用：ComboPooledDataSource cpds = new ComboPooledDataSource(); 它会在指定的目录下查找指定名称的配置文件，并将其中内容加载。 c3p0-config.xml 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql:///day18&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;123&lt;/property&gt; &lt;/default-config&gt;&lt;/c3p0-config&gt; tomcat内置连接池管理tomcat内置连接池使用的是dbcp。 tomcat怎样管理连接池？（配置）要想将一个dbcp连接池让 tomcat管理，只需要创建一个context.xml配置文件,在配置文件中配置相关信息123456&lt;Context&gt; &lt;Resource name="jdbc/EmployeeDB" auth="Container" type="javax.sql.DataSource" username="root" password="abc" driverClassName="com.mysql.jdbc.Driver" url="jdbc:mysql:///day18" maxActive="8" maxIdle="4"/&gt;&lt;/Context&gt; 问题:context.xml文件位置:12341.在tomcat/conf/context.xml 这时这个连接池是给整个服务器使用的。2.在tomcat/conf/Catalina/localhost 这时这个连接池只给localhost虚拟主机使用。3.将context.xml文件放置在web应用的META-INF下（只给本项目使用，最常用）注意：如果是全局设置，那么我们需要将数据库驱动放置在tomcat/lib目录下 怎样从tomcat中获取连接池?我们在servlet中获取连接池对象。123Context context = new InitialContext();Context envCtx = (Context)context.lookup("java:comp/env"); 固定路径DataSource datasource = (DataSource) envCtx.lookup("jdbc/EmployeeDB"); JNDI：JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI SPI的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。目录服务是一种命名服务，在这种服务里，对象不但有名称，还有属性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDBC]]></title>
      <url>%2F2017%2F02%2F03%2FJDBC%2F</url>
      <content type="text"><![CDATA[一、JDBC介绍JDBC（Java Data Base Connectivity,java数据库连接)。简单说:就是可以直接通过java语言，去操作数据库。jdbc是一套标准,它是由一些接口与类组成的。 学习中涉及到的类与接口：（它们主要在两个包下）123456java.sql 类:DriverManger 接口 Connection Statement ResultSet PreparedStatement CallableStatement（它是用于调用存储过程）javax.sql 接口 DataSource 二、快速入门1. 创建数据库123456789create table user( id int primary key auto_increment, username varchar(20) unique not null, password varchar(20) not null, email varchar(40) not null);INSERT INTO USER VALUES(NULL,'tom','123','tom@163.com');INSERT INTO USER VALUES(NULL,'fox','123','fox@163.com'); 2. 下载驱动将驱动jar包复制到lib下 3. 创建一个JdbcDemo类123456789101112131415161718192021222324252627282930313233343536373839404142import java.sql.*;// import com.mysql.jdbc.Driver;public class JdbcDemo&#123; public static void main(String[] args) throws SQLException, ClassNotFoundException&#123; // 1.注册驱动 // DriverManager.registerDriver(new Driver()); Class.forName("com.mysql.jdbc.Driver"); // 2.获取连接对象 Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/jdbc?useSSL=false", "root", "pengxiaoye"); // 3.通过连接对象获取操作sql语句Statement Statement st = con.createStatement(); // 4.操作sql语句 String sql = "select * from user"; // 操作sql语句(select语句),会得到一个ResultSet结果集 ResultSet rs = st.executeQuery(sql); // 5.遍历结果集 // boolean flag = rs.next(); // 向下移动，返回值为true，代表有下一条记录. // int id = rs.getInt("id"); // String username=rs.getString("username"); // System.out.println(id); // System.out.println(username); while(rs.next())&#123; int id=rs.getInt("id"); String username=rs.getString("username"); String password=rs.getString("password"); String email=rs.getString("email"); System.out.println(id+" "+username+" "+password+" "+email); &#125; //6.释放资源 rs.close(); st.close(); con.close(); &#125;&#125; JDBC操作详解：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211.注册驱动 DriverManager.registDriver(new Driver()); 1.DriverManager类 它是java.sql包下的一个驱动管理的工具类,可以理解成是一个容器(Vector),可以装入很多数据库驱动 它的registDriver方法分析 public static synchronized void registerDriver(java.sql.Driver driver) 参数:java.sql.Driver 我们传递的是 com.mysql.jdbc.Driver; 在com.mysql.jdbc.Driver类中有一段静态代码块: static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); &#125; &#125; 上述代码的问题: 1.在驱动管理器中会装入两个mysql驱动. 解决方案:使用反射 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 分析:使用反射的方式来加载驱动有什么好处? 1.只加载一次，装入一个驱动对象. 2.降低耦合，不依赖于驱动.2.可以通过DriverManager来获取连接对象 Connection con=DriverManager.getConection(String url,String user,String password); url作用:就是用于确定使用哪一个驱动. mysql url: jdbc:mysql://localhsot:3306/数据库名. oralce url: jdbc:oracle:thin:@localhost:1521:sid总结:DriverManager作用: 1.注册驱动 2.获取连接Connection-----------------------------------------------------------关于url url格式 主协议 子协议 主机 端口 数据库 jdbc : mysql ://localhost:3306/day17 mysql的url可以简写: 前提：主机是localhost 端口是3306 jdbc:mysql:///day17 了解:在url后面可以带参数 useUnicode=true&amp;characterEncoding=UTF-8------------------------------------------------------------------2.Connection详解 java.sql.Connection，它代表的是一个连接对象。简单说，就是我们程序与数据库连接。 Connection作用: 1.可以通过Connection获取操作sql的Statement对象。 Statement createStatement() throws SQLException 示例: Statement st=con.createStatement(); 了解: 1.可以获取执行预处理的PreparedStatement对象. PreparedStatement prepareStatement(String sql) throws SQLException 2.可以获取执行存储过程的 CallableStatement CallableStatement prepareCall(String sql) throws SQLException 2.操作事务 setAutoCommit(boolean flag);开启事务 rollback();事务回滚 commit();事务提交------------------------------------------------------------------3.Statement详解 java.sql.Statement用于执行sql语句. Statement作用: 1.执行sql DML:insert update delete int executeUpdate(String sql) 利用返回值判断非0来确定sql语句是否执行成功。 DQL:select ResultSet executeQuery(String sql) 可以通过execute方法来执行任何sql语句. execute(String sql)：用于向数据库发送任意sql语句 2.批处理操作 addBatch(String sql); 将sql语句添加到批处理 executeBatch();批量执行 clearBatch();清空批处理.---------------------------------------------------------------------4.ResultSet详解 java.sql.ResultSet它是用于封装select语句执行后查询的结果。 常用API 1.next()方法 public boolean next(); 用于判断是否有下一条记录。如果有返回true,并且让游标向下移动一行。 如果没有返回false. 2.可以通过ResultSet提供的getXxx()方法来获取当前游标指向的这条记录中的列数据。 常用: getInt() getString() getDate() getDouble() 参数有两种 1.getInt(int columnIndex); 2.getInt(String columnName); 如果列的类型不知道，可以通过下面的方法来操作 getObject(int columnIndex); getObject(String columnName);----------------------------------------------------------------5.关闭资源 Jdbc程序运行完后，切记要释放程序在运行过程中，创建的那些与数据库进行交互的对象，这些对象通常是ResultSet, Statement和Connection对象。 特别是Connection对象，它是非常稀有的资源，用完后必须马上释放，如果Connection不能及时、正确的关闭，极易导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 为确保资源释放代码能运行，资源释放代码也一定要放在finally语句中。 对异常进行try-catch-finally：1234567891011121314151617181920212223242526Connection con = null;Statement st = null;ResultSet rs = null;try&#123; ......&#125; catch(ClassNotFoundException e)&#123; e.printStackTrace();&#125; catch(SQLException e)&#123; e.printStackTrace();&#125; finally&#123; //必须要释放资源 try&#123; if(rs!=null) rs.close(); &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; try&#123; if(st!=null) st.close(); &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; try&#123; if(con!=null) con.close(); &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125;&#125; 三、JDBC api详解(重点)只抽取到Connection123456public static Connection getConnection() throws ClassNotFoundException, SQLException &#123; Class.forName("com.mysql.jdbc.Driver"); // 2.获取连接 Connection con = DriverManager.getConnection("jdbc:mysql:///day17","root", "abc"); return con;&#125; JbdcUtils抽取 将关于连接数据库的信息定义到配置文件中： 123456789driverClass=com.mysql.jdbc.Driverurl=jdbc:mysql:///day17username=rootpassword=abc#driverClass=oracle.jdbc.driver.OracleDriver#url=jdbc:oracle:thin:@localhost:1521:XE#username=system#password=system 读取配置文件进行加载： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class JdbcUtils &#123; private static final String DRIVERCLASS; private static final String URL; private static final String USERNAME; private static final String PASSWORD; static &#123; DRIVERCLASS = ResourceBundle.getBundle("jdbc").getString("driverClass"); // ResourceBundle可直接获取配置文件名 URL = ResourceBundle.getBundle("jdbc").getString("url"); USERNAME = ResourceBundle.getBundle("jdbc").getString("username"); PASSWORD = ResourceBundle.getBundle("jdbc").getString("password"); &#125; static &#123; try &#123; // 1.将加载驱动操作，放置在静态代码块中.这样就保证了只加载一次. Class.forName(DRIVERCLASS); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; // 2.获取连接 Connection con = DriverManager.getConnection(URL, USERNAME, PASSWORD); return con; &#125; // 3.关闭操作 public static void closeConnection(Connection con) throws SQLException&#123; if(con!=null)&#123; con.close(); &#125; &#125; public static void closeStatement(Statement st) throws SQLException&#123; if(st!=null)&#123; st.close(); &#125; &#125; public static void closeResultSet(ResultSet rs) throws SQLException&#123; if(rs!=null)&#123; rs.close(); &#125; &#125;&#125; 1.查询查询全部：条件查询：根据id12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void findByIdTest() &#123; // 定义sql String sql = "select * from user where id=1"; Connection con = null; Statement st = null; ResultSet rs = null; try &#123; // 1.注册驱动 Class.forName("com.mysql.jdbc.Driver"); // 2.获取连接 con = DriverManager.getConnection("jdbc:mysql:///day17", "root", "abc"); // 3.获取操作sql语句对象Statement st = con.createStatement(); // 4.执行sql rs = st.executeQuery(sql); // 5.遍历结果集 while (rs.next()) &#123; int id = rs.getInt("id"); String username = rs.getString("username"); String password = rs.getString("password"); String email = rs.getString("email"); System.out.println(id + " " + username + " " + password + " " + email); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 6.释放资源 try &#123; if (rs != null) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (st != null) st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (con != null) con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.修改1234567891011121314151617181920212223242526272829303132333435public void update() &#123; // 将id=3的人的password修改为456 String password = "456"; String sql = "update user set password='" + password + "' where id=3"; // 1.得到Connection Connection con = null; Statement st = null; try &#123; con = JdbcUtils.getConnection(); // 3.获取操作sql语句对象Statement st = con.createStatement(); // 4.执行sql int row = st.executeUpdate(sql); if (row != 0) &#123; System.out.println("修改成功"); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭资源 try &#123; if (st != null) st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (con != null) con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3.删除1234567891011121314151617181920212223242526public void delete() &#123; // 将id=3的人删除 String sql = "delete from user where id=2"; // 1.得到Connection Connection con = null; Statement st = null; try &#123; con = JdbcUtils.getConnection(); // 3.获取操作sql语句对象Statement st = con.createStatement(); // 4.执行sql int row = st.executeUpdate(sql); if (row != 0) &#123; System.out.println("删除成功"); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭资源 try &#123; JdbcUtils.closeStatement(st); JdbcUtils.closeConnection(con); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 4.添加123456789101112131415161718192021222324252627282930313233343536373839404142434445public void add() &#123; // 定义sql String sql = "insert into user values(null,'张三','123','zs@163.com')"; Connection con = null; Statement st = null; ResultSet rs = null; try &#123; // 1.注册驱动 Class.forName("com.mysql.jdbc.Driver"); // 2.获取连接 con = DriverManager.getConnection("jdbc:mysql:///day17", "root", "abc"); // 3.获取操作sql语句对象Statement st = con.createStatement(); // 4.执行sql int row = st.executeUpdate(sql); if (row != 0) &#123; System.out.println("添加成功"); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 6.释放资源 try &#123; if (rs != null) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (st != null) st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (con != null) con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 滚动结果集：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647默认得到的ResultSet它只能向下遍历(next()),对于ResultSet它可以设置成是滚动的，可以向上遍历，或者直接定位到一个指定的物理行号.问题:怎样得到一个滚动结果集? Statement st=con.createStatement(); ResultSet rs=st.executeQuery(sql); 这是一个默认结果集:只能向下执行，并且只能迭代一次。 Statement stmt = con.createStatement( ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE); ResultSet rs = stmt.executeQuery(sql); 这个就可以创建滚动结果集. 简单说，就是在创建Statement对象时，不使用createStatement(); 而使用带参数的createStatement(int,int) Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException resultSetType - 结果集类型，它是 ResultSet.TYPE_FORWARD_ONLY、ResultSet.TYPE_SCROLL_INSENSITIVE 或 ResultSet.TYPE_SCROLL_SENSITIVE 之一 resultSetConcurrency - 并发类型；它是 ResultSet.CONCUR_READ_ONLY 或 ResultSet.CONCUR_UPDATABLE 之一 第一个参数值 ResultSet.TYPE_FORWARD_ONLY 该常量指示光标只能向前移动的 ResultSet 对象的类型。 ResultSet.TYPE_SCROLL_INSENSITIVE 该常量指示可滚动但通常不受 ResultSet 底层数据更改影响的 ResultSet 对象的类型。 ResultSet.TYPE_SCROLL_SENSITIVE 该常量指示可滚动并且通常受 ResultSet 底层数据更改影响的 ResultSet 对象的类型。 第二个参数值 ResultSet.CONCUR_READ_ONLY 该常量指示不可以更新的 ResultSet 对象的并发模式。 ResultSet.CONCUR_UPDATABLE 该常量指示可以更新的 ResultSet 对象的并发模式。 以上五个值，可以有三种搭配方式 ResultSet.TYPE_FORWARD_ONLY ResultSet.CONCUR_READ_ONLY 默认 ResultSet.TYPE_SCROLL_INSENSITIVE ResultSet.CONCUR_READ_ONLY ResultSet.TYPE_SCROLL_SENSITIVE ResultSet.CONCUR_UPDATABLE 常用API next()：移动到下一行 previous()：移动到前一行 absolute(int row)：移动到指定行 beforeFirst()：移动resultSet的最前面 afterLast() ：移动到resultSet的最后面 updateRow() ：更新行数据 四、dao模式DAO模式（Data Access Object 数据访问对象）：在持久层通过DAO将数据源操作完全封装起来，业务层通过操作Java对象，完成对数据源操作业务层无需知道数据源底层实现，通过java对象操作数据源 DAO模式结构 ： 数据源（MySQL数据库） Business Object 业务层代码，调用DAO完成 对数据源操作 DataAccessObject 数据访问对象，持久层DAO程序，封装对数据源增删改查，提供方法参数都是Java对象 TransferObject 传输对象（值对象） 业务层通过向数据层传递 TO对象，完成对数据源的增删改查 1.使用dao模式登录操作1234561.web层 login.jsp LoginServlet User2.service层 UserService3.dao层 UserDao 2.sql注入1234567891011121314151617181920212223242526272829由于没有对用户输入进行充分检查，而SQL又是拼接而成，在用户输入参数时，在参数中添加一些SQL关键字，达到改变SQL运行结果的目的，也可以完成恶意攻击。示例: 在输入用户名时 tom&apos; or &apos;1&apos;=&apos;1 这时就不会验证密码了。解决方案: PreparedStatement(重点) 它是一个预处理的Statement，它是java.sql.Statement接口的一个子接口。总结PreparedStatement使用: 1.在sql语句中，使用&quot;?&quot;占位 String sql=&quot;select * from user where username=? and password=?&quot;; 2.得到PreparedStatement对象 PreparedStatement pst=con.prepareStatement(String sql); 3.对占位符赋值 pst.setXxx(int index,Xxx obj); 例如: setInt() setString(); 参数index,代表的是&quot;?&quot;的序号.注意：从1开始。 4.执行sql DML： pst.executeUpdate(); DQL: pst.executeQuery(); 注意：这两方法无参数关于PreparedStatement优点: 1.解决sql注入(具有预处理功能) 2.不需要在拼sql语句。 五、JDBC处理大数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748mysql中有大数据 blob 大二进制 TINYBLOB(255)、BLOB(64kb)、MEDIUMBLOB(16m)和LONGBLOB(4g) text(clob) 大文本 TINYTEXT(255)、TEXT(64kb)、MEDIUMTEXT(16m)和LONGTEXT(4g) 对于大数据操作，我们一般只有两种 insert select 演示1: 大二进制操作 create table myblob( id int primary key auto_increment, content longblob ) 向表中插入数据 问题1:java.lang.AbstractMethodError: com.mysql.jdbc.PreparedStatement.setBinaryStream(ILjava/io/InputStream;)V 原因:mysql驱动不支持setBinaryStream(int,InputStream); 修改成 pst.setBinaryStream(1, fis,file.length()); 原因:因为mysql驱动不支持setBinaryStream(int,InputStream,long); 解决: mysql驱动支持setBinaryStream(int,InputStream,int); 注意：如果文件比较大，那么需要在my.ini文件中配置 max_allowed_packet=64M 总结: 存 pst.setBinaryStream(1, fis, (int) (file.length())); 取 InputStream is = rs.getBinaryStream(&quot;content&quot;); -------------------------------------------------------------- 演示:存储大文本 create table mytext( id int primary key auto_increment, content longtext ) 存储 File file = new File(&quot;D:\\java1110\\workspace\\day17_3\\a.txt&quot;); FileReader fr = new FileReader(file); pst.setCharacterStream(1, fr, (int) (file.length())); 获取: Reader r = rs.getCharacterStream(&quot;content&quot;); 六、JDBC批处理1234567891011121314151617181920212223一次可以执行多条sql语句.在jdbc中可以执行sql语句的对象有Statement,PreparedStatement，它们都提供批处理.1.Statement执行批处理 addBatch(String sql); 将sql语句添加到批处理 executeBatch(); 执行批处理 clearBatch();2.PreparedStatement执行批处理 addBatch(); executeBatch(); clearBatch();以上两个对象执行批处理区别? 1.Statement它更适合执行不同sql的批处理。它没有提供预处理功能，性能比较低。 2.PreparedStatement它适合执行相同sql的批处理，它提供了预处理功能，性能比较高。注意;mysql默认情况下，批处理中的预处理功能没有开启，需要开启 1.在 url下添加参数 url=jdbc:mysql:///day17?useServerPrepStmts=true&amp;cachePrepStmts=true&amp;rewriteBatchedStatements=true 2.注意驱动版本 Mysql驱动要使用mysql-connector-java-5.1.13以上]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySql]]></title>
      <url>%2F2017%2F02%2F03%2Fmysql%2F</url>
      <content type="text"><![CDATA[基本操作mysql -u root -p 不需要输入密码.就可以进入.mysqld --skip-grant-tables 开启一个mysql服务,不需要进行认证.show databases 查看数据库use mysql 使用mysql数据库update user set password=password(&#39;root&#39;) WHERE user=&#39;root&#39; 修改密码 一、数据库 创建数据库：create database 数据名称;create database 数据库名称 character set 编码 collate 校对规则; 查看数据库：show databases; 查询数据库的定义：show create database 数据库; 删除数据库：drop database 数据库名称; 修改数据库：alter database 数据库 character set 编码 collate 校对规则; 切换数据库：use 数据库; 查看当前使用的数据库：select database(); 二、表 创建表： 123456create table 表名( 字段1 类型(长度) 约束, 字段2 类型(长度) 约束, 字段3 类型(长度) 约束, 字段4 类型(长度) 约束); 注意： 表名小括号，后面要有分号。 每一行字段后面要有逗号，但是最后一行没有逗号。 数据的类型后面有长度，如果是字符串类型，长度必须加。如果其他类型可以不加。默认长度。int 默认长度11 数据的类型 字符串型 VARCHAR、CHAR * varchar和char区别： * varchar（经常使用）：长度可变。name varchar(8)存入数据hello，但如果存helloworld报错 * char：长度不可变的。 name char(8) 存入的数据hello，如果不够用空格补全。 大数据类型（一般不用） BLOB、TEXT BLOB：二进制文件 TEXT：字符 数值型 TINYINT 、SMALLINT、INT、BIGINT、FLOAT、DOUBLE 逻辑性 对应boolean BIT 日期型 DATE、TIME、DATETIME、TIMESTAMP * date 只包含日期 * time 只包含时分秒 * datetime和timestamp包含日期和时分秒区别： * datetime需要手动录入时间。 * timestamp不传入数据，默认选择当前系统时间。 查看表的信息：desc 表名 查看当前库内所有表名：show tables; 查看建表语句和字符集：show create table 表名; 约束（单表）： 123456789101112131415161718192021* 主键约束（*****） * 标识标记该条记录。 通过pramary key声明主键。（默认唯一、非空） * auto_increment 数据库维护主键。自动增长。 * 唯一约束 * 值是唯一的。使用unique声明 * 非空约束 * 值不能为空 not null * 创建新的标签employee2，把约束加上。 create table employee2( id int primary key auto_increment, name varchar(20) unique not null, gender varchar(10) not null, birthday date not null, entry_date date not null, job varchar(100) not null, salary double not null, resume text not null ); 删除表：drop table employee2; 修改表：123456alter table 表名 add 字段 类型(长度) 约束; -- 添加字段addalter table 表名 drop 字段; -- 删除字段dropalter table 表名 modify 字段 类型(长度) 约束; -- 修改类型或者约束modifyalter table 表名 change 旧字段 新字段 类型(长度) 约束 -- 修改字段的名称changerename table 表名 to 新表名; -- 修改表名toalter table 表名 character set utf8; -- 修改字符集character 三、数据 添加数据：insert into 表名 (字段1,字段2,字段3..) values(值1,值2,值3...); 有几列就插入多少的值insert into 表名 values(值1,值2,值3...); 插入所有的列 修改数据：update 表名 set 字段=值,字段=值... [where ]如果没有where条件，默认更新所有的记录 删除数据：delete from 表名 [where ]; 删除数据truncate 表名; 删除所有的数据truncate 和 delete的区别：truncate删除数据，先删除整个表。再创建一个新的空的表。（效率）/// delete删除数据，一条一条删除的。 查询语句：select * from 表名 查询所有（字段）select 字段名1,字段名2,字段名3 from 表名; 显示查询字段名select distinct 字段名 from 表名; 去除重复的数据 * 查询的列可以运算 * 可以使用别名：使用as 别名 并且as可以省略。 练习： 在所有学生分数上加10分特长分。 select name,math+10,english+10,chinese+10 from stu; 统计每个学生的总分。 select name,math+english+chinese from stu; 使用别名表示学生分数。 select name,(math+english+chinese) as sum from stu; * 使用where条件过滤 查询姓名为班长的学生成绩 select * from stu where name=&apos;班长&apos;; 查询英语成绩大于90分的同学 select name,english from stu where english &lt; 15; 查询总分大于200分的所有同学 select name,math+english+chinese from stu where (math+english+chinese) &gt; 200; * 常用的符号 &gt; &lt; &lt;= &gt;= = &lt;&gt;（不等于） in(范围内取内容) like -- 模糊查询 写法：like &apos;张_或者%&apos;; _和%区别：占位符。_只一个%可以有多个 %的写法 like &apos;%张&apos;; 结果XXX张 like &apos;张%&apos;; 结果张XXX like &apos;%张%&apos;; 只要有张就行 is null -- 判断是否为null and -- 并且 or -- 或者 not -- 不成立 * 练习 查询英语分数在 80－90之间的同学。 select * from stu where english &gt;80 and english &lt;90; select * from stu where english between 80 and 90; 查询数学分数为18,78,46的同学。（in） select * from stu where math in(18,78,46); 查询所有姓班的学生成绩。 select * from stu where name like &apos;班%&apos;; 查询数学分&gt;80，语文分&gt;80的同学。 select * from stu where math &gt;80 or chinese &gt; 80; 排序 出现select的语句末尾 order by 升序默认的(asc)/降序(desc) 123456count 获取数量sum 求和（忽略null值）avg 平均数max 最大值min 最小值group by 分组（一起使用）.条件过滤需要是having，不能使用where 小结：select 语句 ： S-F-W-G-H-O 组合 select … from … where … group by… having… order by … ; 顺序不能改变]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSTL标签 & EL函数]]></title>
      <url>%2F2017%2F02%2F02%2FJSTL%E6%A0%87%E7%AD%BE%20EL%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[一、jstl标签1.JSTL标签库概述12345* JSP标准标签库。* 作用：和EL表达式一起 取代&lt;% %&gt;* 版本：1.0 1.1和1.2（区别不大） * 1.0EL表达式没有纳入规范 * 1.1和1.2EL表达式纳入规范 导入Jar包：jstl.jar和standard.jar标签库：c.tld(核心的标签库) 和 fn.tld(EL表达式标签库) 2.JSTL的快速入门 导入相应jar包。 新建JSP的文件，引入标签库:&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; 直接使用标签库 3.JSTL的标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228&lt;c:out&gt; 输出内容 value ：输出的内容（常量或者变量） default : 默认值 escapeXml：默认是true，进行转义，设置成false，不转义。 代码： &lt;c:out value=&quot;Hello&quot;&gt;&lt;/c:out&gt; &lt;c:out value=&quot;$&#123; name &#125;&quot;&gt;&lt;/c:out&gt; &lt;!-- &quot;&quot; --&gt; &lt;c:out value=&quot;$&#123; city &#125;&quot; default=&quot;取不到&quot;&gt;&lt;/c:out&gt; &lt;c:out value=&quot;&lt;a href=&apos;#&apos;&gt;超链接&lt;/a&gt;&quot; escapeXml=&quot;false&quot;/&gt;&lt;c:set&gt; * 属性 var ：定义属性 value ：存入的值 scope ：域范围 target ：修改JavaBean对象 property：修改的属性 * 向4个web域对象存入值 &lt;c:set var=&quot;i&quot; value=&quot;10&quot; scope=&quot;request&quot; &gt;&lt;/c:set&gt; * 修改JavaBean对象属性的值 &lt;c:set target=&quot;$&#123; user &#125;&quot; property=&quot;username&quot; value=&quot;小凤&quot;&gt;&lt;/c:set&gt;&lt;c:remove&gt; * 属性 var ：删除的属性 scope ：在域的范围 * 代码 &lt;c:set var=&quot;name&quot; value=&quot;小凤&quot; scope=&quot;page&quot;&gt;&lt;/c:set&gt; $&#123; name &#125; &lt;c:remove var=&quot;name&quot; scope=&quot;page&quot;/&gt; $&#123; name &#125;* &lt;c:catch&gt; * 属性：var 把异常的信息保存变量中 * 代码 &lt;c:catch var=&quot;e&quot;&gt; &lt;% int a = 10/0; %&gt; &lt;/c:catch&gt; $&#123; e.message &#125;* &lt;c:if&gt; 没有&lt;c:else&gt;标签 * 属性 * test 判断的条件 * var 计算的结果保存到变量中 * scope 域的范围 * 代码 &lt;c:set var=&quot;i&quot; value=&quot;10&quot; scope=&quot;page&quot;&gt;&lt;/c:set&gt; &lt;c:if test=&quot;$&#123; i ge 10 &#125;&quot; var=&quot;x&quot; scope=&quot;page&quot;&gt; i &gt;= 10 &lt;/c:if&gt; &lt;c:if test=&quot;$&#123; i lt 10 &#125;&quot;&gt; i &lt; 10 &lt;/c:if&gt; $&#123; x &#125;* &lt;c:choose&gt;标签 &lt;c:when&gt; &lt;c:otherwise&gt; 代码： &lt;c:set var=&quot;i&quot; value=&quot;10&quot; scope=&quot;page&quot;&gt;&lt;/c:set&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123; i ge 10 &#125;&quot;&gt; i &gt;= 10 &lt;/c:when&gt; &lt;c:when test=&quot;$&#123; i lt 10 &#125;&quot;&gt; i &lt; 10 &lt;/c:when&gt; &lt;c:otherwise&gt; 其他 &lt;/c:otherwise&gt; &lt;/c:choose&gt;* &lt;c:forEach&gt;（*****） * 循环遍历数据（数组，集合，Map集合） * 属性 var ：遍历数据的类型 items ：要遍历的内容 begin ：从哪开始 end ：到哪结束 step ：步长 varStatus：记录循环遍历的信息 * index * count（常用） * first * last * 代码 &lt;% String [] arrs = &#123;&quot;美美&quot;,&quot;小凤&quot;,&quot;芙蓉&quot;,&quot;小苍&quot;&#125;; request.setAttribute(&quot;arrs&quot;, arrs); %&gt; &lt;!-- for(String s : arrs)&#123; &#125; --&gt; &lt;c:forEach var=&quot;s&quot; items=&quot;$&#123; arrs &#125;&quot;&gt; $&#123; s &#125; &lt;/c:forEach&gt; &lt;h4&gt;遍历集合&lt;/h4&gt; &lt;% List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;美美&quot;); list.add(&quot;小凤&quot;); list.add(&quot;芙蓉&quot;); list.add(&quot;小泽&quot;); request.setAttribute(&quot;list&quot;, list); %&gt; &lt;c:forEach var=&quot;s&quot; items=&quot;$&#123; list &#125;&quot;&gt; $&#123; s &#125; &lt;/c:forEach&gt; &lt;h4&gt;遍历Map集合&lt;/h4&gt; &lt;% Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(&quot;aa&quot;, &quot;美美&quot;); map.put(&quot;bb&quot;, &quot;小凤&quot;); map.put(&quot;cc&quot;, &quot;芙蓉&quot;); request.setAttribute(&quot;map&quot;, map); %&gt; &lt;c:forEach var=&quot;entry&quot; items=&quot;$&#123; map &#125;&quot;&gt; $&#123; entry.key &#125; -- $&#123; entry.value &#125; &lt;/c:forEach&gt; &lt;h4&gt;遍历对象的集合&lt;/h4&gt; &lt;% List&lt;User&gt; uList = new ArrayList&lt;User&gt;(); uList.add(new User(&quot;美美&quot;,&quot;123&quot;)); uList.add(new User(&quot;小风&quot;,&quot;234&quot;)); uList.add(new User(&quot;芙蓉&quot;,&quot;345&quot;)); request.setAttribute(&quot;uList&quot;, uList); %&gt; &lt;c:forEach var=&quot;user&quot; items=&quot;$&#123; uList &#125;&quot;&gt; $&#123; user.username &#125; -- $&#123; user.password &#125; &lt;/c:forEach&gt; &lt;h4&gt;迭代数据&lt;/h4&gt; &lt;h4&gt;迭代从1到10&lt;/h4&gt; &lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;10&quot; step=&quot;2&quot;&gt; $&#123; i &#125; &lt;/c:forEach&gt; &lt;h4&gt;计算从1加到100的和&lt;/h4&gt; &lt;c:set var=&quot;sum&quot; value=&quot;0&quot; scope=&quot;page&quot;&gt;&lt;/c:set&gt; &lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;100&quot; step=&quot;1&quot;&gt; &lt;c:set var=&quot;sum&quot; value=&quot;$&#123; sum + i &#125;&quot;&gt;&lt;/c:set&gt; &lt;/c:forEach&gt; $&#123; sum &#125; &lt;h4&gt;遍历10到100的偶数，每到第3个数，显示红色&lt;/h4&gt; &lt;c:forEach var=&quot;i&quot; begin=&quot;10&quot; end=&quot;100&quot; step=&quot;2&quot; varStatus=&quot;status&quot;&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123; status.first &#125;&quot;&gt; &lt;font color=&quot;blue&quot;&gt;$&#123; i &#125;&lt;/font&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123; status.count % 3 eq 0 &#125;&quot;&gt; &lt;font color=&quot;red&quot;&gt;$&#123; i &#125;&lt;/font&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; $&#123; i &#125; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/c:forEach&gt;* &lt;c:param&gt; 传递参数 * 属性 name ：参数名称 value ：参数的值* &lt;c:import&gt; 包含页面 * url ：引入页面的地址 * context ：虚拟路径 * var ：引入页面保存到属性中 * scope ：域的范围 * 代码 &lt;c:import url=&quot;/jstl/choose.jsp&quot; context=&quot;/day13&quot; var=&quot;i&quot; scope=&quot;page&quot;&gt; &lt;c:param name=&quot;username&quot; value=&quot;meimei&quot;&gt;&lt;/c:param&gt; &lt;/c:import&gt; $&#123; i &#125;* &lt;c:url&gt; &lt;c:url&gt;标签用于在JSP页面中构造一个URL地址，其主要目的是实现URL重写。 URL重写就是将会话标识号以参数形式附加在URL地址后面 http://localhost/day12/demo?jsessionid=xxxxxxxxxxxxxxxxxx; * 属性 * var ：声明属性 * value ：地址 * scope ：域范围 * context ：虚拟路径 * 代码 &lt;c:url var=&quot;i&quot; value=&quot;/jstl/choose.jsp&quot; scope=&quot;request&quot; context=&quot;/day13&quot;&gt; &lt;c:param name=&quot;username&quot; value=&quot;xiaofeng&quot;&gt;&lt;/c:param&gt; &lt;/c:url&gt; &lt;a href=&quot;$&#123; i &#125;&quot;&gt;choose&lt;/a&gt;* &lt;c:redirect&gt;重定向 * 属性 * url ：重定向的地址 * context ：虚拟路径 * 代码 &lt;c:redirect url=&quot;/jstl/choose.jsp&quot; context=&quot;/day13&quot;&gt; &lt;c:param name=&quot;username&quot; value=&quot;furong&quot;&gt;&lt;/c:param&gt; &lt;/c:redirect&gt;* &lt;c:forTokens&gt;分隔字符串（了解） &lt;h4&gt;分隔字符串&lt;/h4&gt; &lt;c:set var=&quot;i&quot; value=&quot;aa,bb,cc&quot; scope=&quot;page&quot;&gt;&lt;/c:set&gt; &lt;c:forTokens items=&quot;$&#123;i &#125;&quot; delims=&quot;,&quot; var=&quot;x&quot;&gt; $&#123; x &#125; &lt;/c:forTokens&gt; 二、EL函数1.自定义EL函数（入门） 编写一个类，方法必须是静态方法。 在WEB-INF目录下创建.tld的文件，配置。(选择2.0) 完成配置123456789&lt;!-- 配置自定义的EL函数 --&gt;&lt;function&gt; &lt;!-- 配置方法名称 --&gt; &lt;name&gt;sayHi&lt;/name&gt; &lt;!-- 方法所在的类 --&gt; &lt;function-class&gt;cn.itcast.el.ElDemo1&lt;/function-class&gt; &lt;!-- 配置方法的签名 --&gt; &lt;function-signature&gt;java.lang.String sayHello(java.lang.String)&lt;/function-signature&gt;&lt;/function&gt; 2.自定义标签 实现SimpleTag接口：编写一个类，继承SimpleTagSupport类。 重写5个方法12345void setJspContext(JspContext pc)void setParent(JspTag parent)void setJspBody(JspFragment jspBody) void doTag()JspTag getParent() (1).快速入门的步骤（自定义没有标签体的标签） 编写一个类，继承SimpleTagSupport 选择重写的方法，doTag()必须有的 123456789101112public class TagDemo1 extends SimpleTagSupport&#123; private PageContext pc; public void doTag() throws JspException, IOException &#123; pc.getOut().write("Hello"); &#125; // 服务器默认先执行该方法 public void setJspContext(JspContext pc) &#123; this.pc = (PageContext) pc; &#125;&#125; 需要配置 123456789&lt;!-- 配置自定义标签 --&gt; &lt;tag&gt; &lt;!-- 配置标签名称 --&gt; &lt;name&gt;print&lt;/name&gt; &lt;!-- 配置标签的类 --&gt; &lt;tag-class&gt;cn.itcast.tag.TagDemo1&lt;/tag-class&gt; &lt;!-- 配置标签主体 --&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt; 在JSP页面上，引入标签库：&lt;%@ taglib uri=&quot;http://www.itcast.cn/1110/myc&quot; prefix=&quot;myc&quot; %&gt; 使用标签了 (2).带有标签主体的标签 编写类，继承SimpleTagSupport 重写doTag() 获取标签主体对象：JspFragment jf = getJspBody(); jf.invoke(null); 123456789101112public class TagDemo2 extends SimpleTagSupport&#123; private PageContext pc; public void doTag() throws JspException, IOException &#123; JspFragment jf = getJspBody(); jf.invoke(null); &#125; public void setJspContext(JspContext pc) &#123; this.pc = (PageContext)pc; &#125;&#125; 配置 123456789&lt;!-- 配置自定义标签 --&gt; &lt;tag&gt; &lt;!-- 配置标签名称 --&gt; &lt;name&gt;out&lt;/name&gt; &lt;!-- 配置标签的类 --&gt; &lt;tag-class&gt;cn.itcast.tag.TagDemo2&lt;/tag-class&gt; &lt;!-- 配置标签主体 --&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;/tag&gt; 12345&lt;body-content&gt;元素的可选值有： empty：不能有标签体内容。 JSP：标签体内容可以是任何东西：EL、JSTL、&lt;%=%&gt;、&lt;%%&gt;，以及html；但不建议使用Java代码段，SimpleTag已经不再支持使用&lt;body-content&gt;JSP&lt;/body-content&gt;； scriptless：标签体内容不能是Java代码段，但可以是EL、JSTL等； tagdependent：标签体内容不做运算，由标签处理类自行处理，无论标签体内容是EL、JSP、JSTL，都不会做运算。 (3).带有属性的标签 编写类，继承SimpleTagSupport 重写doTag() 编写一个属性，属性必须和标签中的属性是相同 提供set()方法 获取标签主体对象：JspFragment jf = getJspBody(); jf.invoke(null); 12345678910111213public class TagDemo3 extends SimpleTagSupport&#123; private boolean test; public void setTest(boolean test) &#123; this.test = test; &#125; public void doTag() throws JspException, IOException &#123; if(test)&#123; getJspBody().invoke(null); &#125; &#125;&#125; 配置 1234567891011121314151617181920&lt;!-- 配置自定义标签 --&gt; &lt;tag&gt; &lt;!-- 配置标签名称 --&gt; &lt;name&gt;if&lt;/name&gt; &lt;!-- 配置标签的类 --&gt; &lt;tag-class&gt;cn.itcast.tag.TagDemo3&lt;/tag-class&gt; &lt;!-- 配置标签主体 --&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;!-- 配置属性 --&gt; &lt;attribute&gt; &lt;!-- 配置属性名称 --&gt; &lt;name&gt;test&lt;/name&gt; &lt;!-- 属性是否是必须的 --&gt; &lt;required&gt;true&lt;/required&gt; &lt;!-- 是否支持EL表达式 --&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;!-- 属性的类型 --&gt; &lt;type&gt;boolean&lt;/type&gt; &lt;/attribute&gt; &lt;/tag&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSP & beanutils & EL]]></title>
      <url>%2F2017%2F02%2F02%2FJSP%20beanutils%20EL%2F</url>
      <content type="text"><![CDATA[一、JSP语法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162* JSP的设置 * 设置JSP文件的打开方式：window -- 选项 -- General -- Editors -- 文件关联 -- *.jsp -- 选择MyEclipse JSP Editor -- default * 设置JSP文件的编码：window -- 搜索JSP -- 找到JSP -- 选择UTF-8 -- OK* 脚本元素 &lt;%! %&gt; 成员方法、成员变量 &lt;%= %&gt; 输出内容 &lt;% %&gt; 局部变量，语句* JSP页面的注释 * HTML的注释 &lt;!-- --&gt; JSP文件的阶段存在，在翻译成java文件也存在， 在页面存在 * JAVA的注释 JSP文件的阶段存在，在翻译成java文件也存在， 在页面不存在 &lt;% // 单行 /**/ 多行 /** * 文档 */ %&gt; * JSP的注释 &lt;%-- JSP的注释 --%&gt; 之后存在JSP文件的阶段* JSP的指令元素 * 语法：&lt;%@ 指令元素 属性名=属性值 %&gt; * page ：设置JSP的属性 * 注意：import属性可以出现多次，其他属性只能出现一次。 * 属性： * language ：JSP文件允许嵌入的语言。只支持一种JAVA语言。（不需要改变） * extends ：JSP翻译翻译Servlet文件，servlet继承的类。（不需要改变） * session ：默认值是true，可以直接使用session。设置false，不能直接使用。 * import ：引入java的jar包（使用多次） * buffer ：设置缓冲区的大小 默认8kb * aotoFlush ：设置默认刷新缓冲区（不要修改） * errorPage ：指定错误页面 * isErrorPage ：设置值，可以是exception对象，设置true，使用exception，设置不能使用exception对象 * contentType ：服务器端输出所有内容采用编码。 * pageEncoding ：JSP翻译成Servlet文件时采用的编码。 * isELIgnored ：是否忽略EL表达式（默认false，不忽略，true，忽略） * 重点： * session import contentType pageEncoding isELIgnored * include ：包含页面（页面布局） * 语法：&lt;%@ include file=&quot;要包含文件的地址（静态包含）&quot; %&gt; * &lt;%@ include file=&quot;/include/head.jsp&quot; %&gt; * taglib ：引入标签库文件 * 语法：&lt;%taglib %&gt; * 属性: * uri ：引入标签库文件的名称 * prefix ：标签库的前缀名* 配置全局的错误页面 * 在web.xml中进行配置。 &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/500.jsp&lt;/location&gt; &lt;/error-page&gt; 二、JSP的内置对象（9个）直接使用request、response、session、application、out、pageContext、page、config、exception12345678910111213141516171819202122232425262728293031323334353637383940414243内置对象 真实的对象 方法request HttpServletRequest setAttribute() getAttribute()response HttpServletResponse addCookie() getWriter()session HttpSession setAttribute() getAttribute()application ServletContext setAttribute() getAttribute()config ServletConfig getInitParameter() getInitParameterNames()exception Throwable getMessage()page Object （不使用对象）out JspWriter write() print()pageContext PageContext setAttribute() getAttribute()* exception * 和异常有关的 * 前提条件：isErrorPage=&quot;true&quot;，才能使用exception对象。* page * 当前页面的对象。* out对象 JspWriter PrintWriter response.getWriter() &lt;%= &quot;HELLO&quot; %&gt; &lt;% out.print(&quot;AAAA&quot;); %&gt; &lt;% response.getWriter().print(&quot;BBBB&quot;); %&gt; &lt;% out.print(&quot;CCCC&quot;); %&gt; * 输出结果：* pageContext对象 * 域对象 * 自己存取值 * 向其他的域存取值。 * setAttribute(String name, Object value, int scope) * getAttribute(String name, int scope) * findAttribute(String name) * 可以获取其他8个对象。 * 编写框架或者通用性较高代码。* 在JSP的时候（4个域对象） ServletContext 整个web应用 session 一次会话 request 一次请求 pageContext 当前页面 123456789101112131415161718192021222324252627282930&lt;html&gt;&lt;body&gt;&lt;%=request.getParameter("username") %&gt;&lt;h4&gt;pageContext向其他域中存入值&lt;/h4&gt;&lt;% pageContext.setAttribute("name", "美美"); // 下面这句等价于上面 pageContext.setAttribute("name", "美美", pageContext.PAGE_SCOPE); request.setAttribute("name", "小凤"); // 向request域中存入值 pageContext.setAttribute("name", "小凤", pageContext.REQUEST_SCOPE); // 向session域存入值 pageContext.setAttribute("name", "小苍", pageContext.SESSION_SCOPE); // 向ServletContext域存入值 pageContext.setAttribute("name", "小班长", pageContext.APPLICATION_SCOPE);%&gt;&lt;%= pageContext.getAttribute("name", pageContext.SESSION_SCOPE)%&gt;&lt;%= session.getAttribute("name") %&gt;$&#123; pageScope.name &#125;$&#123; requestScope.name &#125;$&#123; sessionScope.name &#125;$&#123; applicationScope.name &#125;&lt;/body&gt;&lt;/html&gt; 三、JSP的标签（JSP的动作）123456&lt;jsp:forward&gt; ：转发 属性：page 要转发的页面&lt;jsp:param&gt; ：传递参数 属性：name：参数名称 value：参数值&lt;jsp:include&gt; ：页面的包含（动态包含） 属性：page 要包含的页面 1234&lt;h4&gt;JSP的动作标签&lt;/h4&gt;&lt;jsp:forward page="/jsp/pageContext.jsp"&gt; &lt;jsp:param name="username" value="meimei"/&gt;&lt;/jsp:forward&gt; 12345&lt;jsp:include page="/action/head.jsp"&gt;&lt;/jsp:include&gt;&lt;jsp:include page="/action/menu.jsp"&gt;&lt;/jsp:include&gt;&lt;h3&gt;网站的新闻（数据变化）&lt;/h3&gt;&lt;jsp:include page="/action/foot.jsp"&gt;&lt;/jsp:include&gt; 四、JavaBean和内省（了解）有个工具类直接完成数据封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455* 什么是JavaBean？ * 定义 * 必须有一个无参的构造方法 * 属性私有化 * 私有化的属性必须通过public类型的方法暴露给其它程序，并且方法的命名也必须遵守一定的命名规范(set开头，后面接大写字母开头的属性)。 public class User()&#123; private String username; private String password; public void setUsername()&#123; &#125; public void getUsername()&#123; &#125; public void getPassword()&#123; &#125; public void getInfo()&#123; &#125; &#125; * 作用：封装数据。把数据封装到JavaBean中（JSP页面中完成的）&lt;jsp:useBean&gt;&lt;jsp:setProperty&gt;&lt;jsp:getProperty&gt;&lt;jsp:useBean id=&quot;u&quot; class=&quot;cn.itcast.vo.User&quot;&gt;&lt;/jsp:useBean&gt;&lt;jsp:setProperty property=&quot;username&quot; name=&quot;u&quot;/&gt;&lt;jsp:setProperty property=&quot;password&quot; name=&quot;u&quot;/&gt;或者&lt;jsp:setProperty property=&quot;*&quot; name=&quot;u&quot;/&gt;&lt;jsp:getProperty property=&quot;username&quot; name=&quot;u&quot;/&gt;&lt;jsp:getProperty property=&quot;password&quot; name=&quot;u&quot;/&gt;``` `User.java` ```javapublic class User &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; login.jsp12345678910111213141516171819202122232425262728&lt;html&gt;&lt;body&gt;&lt;h4&gt;1.表单提交到JSP的页面&lt;/h4&gt;&lt;form action="/day12/bean/success.jsp" method="POST"&gt; 姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; 密码：&lt;input type="password" name="password" /&gt;&lt;br/&gt; &lt;input type="submit" value="登陆"/&gt;&lt;/form&gt;&lt;h4&gt;2.表单提交到Servlet程序&lt;/h4&gt;&lt;form action="/day12/user" method="POST"&gt; 姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; 密码：&lt;input type="password" name="password" /&gt;&lt;br/&gt; &lt;input type="submit" value="登陆"/&gt;&lt;/form&gt;&lt;h4&gt;3.表单提交到Servlet（BeanUtils）程序&lt;/h4&gt;&lt;form action="/day12/userBeanUtil" method="POST"&gt; 姓名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; 密码：&lt;input type="password" name="password" /&gt;&lt;br/&gt; &lt;input type="submit" value="登陆"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; success.jsp1234567891011121314151617181920212223&lt;html&gt;&lt;body&gt;&lt;!-- 1.传统方式封装数据 --&gt;&lt;% // 获取表单的内容 String username = request.getParameter("username"); String password = request.getParameter("password"); // 创建User对象，set设置值 User user = new User(); user.setUsername(username); user.setPassword(password);%&gt;&lt;!-- 2.使用jsp的标签封装数据 --&gt;&lt;jsp:useBean id="u" class="cn.itcast.vo.User"&gt;&lt;/jsp:useBean&gt;&lt;jsp:setProperty property="*" name="u"/&gt; // 当属性特别多时，直接只写一行*设置所有属性&lt;jsp:getProperty property="username" name="u"/&gt;&lt;jsp:getProperty property="password" name="u"/&gt;&lt;/body&gt;&lt;/html&gt; 五、内省（Introspector）123456789101112131415161718public void run() throws Exception&#123; User user = new User(); // 获取类的信息 BeanInfo info = Introspector.getBeanInfo(user.getClass()); // 获取属性的描述 PropertyDescriptor [] pds = info.getPropertyDescriptors(); // 循环遍历，获取属性的名称 for (PropertyDescriptor pd : pds) &#123; // System.out.println(pd.getName()); if(!"class".equals(pd.getName()))&#123; // 获取写的方法 Method m = pd.getWriteMethod(); m.invoke(user, "admin"); &#125; &#125; System.out.println(user.getUsername()); System.out.println(user.getPassword());&#125; UserServlet.jsp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class UserServlet extends HttpServlet &#123; private static final long serialVersionUID = 6390620317553505800L; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取请求参数，创建User对象，设置值。 /** * // 获取表单的内容 String username = request.getParameter("username"); String password = request.getParameter("password"); // 创建User对象，set设置值 User user = new User(); user.setUsername(username); user.setPassword(password); */ // 获取输入的数据 Map&lt;String, String []&gt; map = request.getParameterMap(); // 创建User对象 User user = new User(); // 自己编写封装数据的方法 try &#123; populate(map,user); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 完成数据封装 System.out.println(user.getUsername()); System.out.println(user.getPassword()); &#125; // 完成的数据 private void populate(Map&lt;String, String[]&gt; map, User user) throws Exception &#123; BeanInfo info = Introspector.getBeanInfo(user.getClass()); // 获取属性的描述 PropertyDescriptor [] pds = info.getPropertyDescriptors(); // 循环遍历 for (PropertyDescriptor pd : pds) &#123; // 获取到属性的名称 String name = pd.getName(); // map的key if(map.containsKey(name))&#123; // 获取属性的写的方法 Method m = pd.getWriteMethod(); // 执行之 m.invoke(user, map.get(name)[0]); &#125; &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 六、beanutils工具类导入jar包：commons-beanutils-1.8.3.jar commons-logging-1.1.1.jar1234567891011121314151617181920212223242526272829303132333435363738import org.apache.commons.beanutils.BeanUtils;import org.apache.commons.beanutils.ConvertUtils;public class UserBeanUtilServlet extends HttpServlet &#123; private static final long serialVersionUID = 3625882115495534032L; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取数据 Map&lt;String, String []&gt; map = request.getParameterMap(); // 创建User对象 User user = new User(); // 完成注册 ConvertUtils.register(new MyDateConverter(), Date.class); // 完成封装 try &#123; BeanUtils.populate(user, map); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; // 打印 System.out.println(user.getUsername()); System.out.println(user.getPassword()); System.out.println(user.getMoney()); System.out.println(user.getBirthday()); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 默认把字符串转换成日期类型：MyDateConverter.java12* 编写一个类，实现Converter接口。重写该方法。把字符串转换日期。* 在封装数据之前进行注册。ConvertUtils.register(Converter converter, Class clazz) Date.class MyDateConverter.java12345678910111213141516171819import org.apache.commons.beanutils.Converter;public class MyDateConverter implements Converter&#123; // 字符串转换成日期 public Object convert(Class clazz, Object obj) &#123; // 把输入的字符串，转换成日期类型，返回 String dDate = (String) obj; // 把字符串转换成日期 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Date date; try &#123; date = sdf.parse(dDate); &#125; catch (ParseException e) &#123; e.printStackTrace(); throw new RuntimeException("转换日期错误"); &#125; return date; &#125;&#125; 七、EL表达式语法：${ }获取（域对象中的）数据12345678&lt;h4&gt;获取域对象中的值&lt;/h4&gt;&lt;% pageContext.setAttribute(&quot;name&quot;, &quot;黄海波&quot;); request.setAttribute(&quot;name&quot;, &quot;美美&quot;);%&gt;$&#123; pageScope.name &#125;$&#123; requestScope.name &#125; 123456&lt;h4&gt;域中数组的值&lt;/h4&gt;&lt;% String [] arrs = &#123;&quot;美美&quot;,&quot;波波&quot;,&quot;东东&quot;,&quot;名名&quot;&#125;; request.setAttribute(&quot;arrs&quot;, arrs);%&gt;$&#123; arrs[2] &#125; 123456789&lt;h4&gt;域中集合的值&lt;/h4&gt;&lt;% List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;美美&quot;); list.add(&quot;小凤&quot;); list.add(&quot;芙蓉&quot;); request.setAttribute(&quot;list&quot;, list);%&gt;$&#123; list[1] &#125; 12345678&lt;h4&gt;域中Map集合的值&lt;/h4&gt;&lt;% Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(&quot;aa&quot;, &quot;美美&quot;); map.put(&quot;bb.cc&quot;, &quot;小凤&quot;); //含特殊字符.用中括号取出 request.setAttribute(&quot;map&quot;, map);%&gt;$&#123; map.bb &#125; /$&#123; map[&quot;bb.cc&quot;] &#125; 12345678&lt;h4&gt;域中集合中有对象的值&lt;/h4&gt;&lt;% List&lt;User2&gt; uList = new ArrayList&lt;User2&gt;(); uList.add(new User2(&quot;banzhang&quot;,&quot;123&quot;)); uList.add(new User2(&quot;美美&quot;,&quot;abc&quot;)); request.setAttribute(&quot;uList&quot;, uList);%&gt;$&#123; uList[1].username &#125; 执行运算1.加法运算${ n1 + n2 } 2.关系运算大于：${ n1 &gt; n2 } ${ n1 gt n2 }小于：${ n1 &lt; n2 } ${ n1 lt n2 }等于：${ n1 == n2 } ${ n1 eq n2 }不等于：${ n1 != n2 } ${ n1 ne n2 }大于等于：${ n1 &gt;= n2 } ${ n1 ge n2 }小于等于：${ n1 &lt;= n2 } ${ n1 le n2 } 3.逻辑运算与：${ n1 &gt; n2 &amp;&amp; n3 &gt; n4 } ${ n1 &gt; n2 and n3 &gt; n4 }或：${ n1 &gt; n2 || n3 &gt; n4 } ${ n1 &gt; n2 or n3 &gt; n4 }非：${ !(n1 &gt; n2) } ${ not (n1 &gt; n2) } 获取WEB开发中的对象123456789101112131415pageScoperequestScopesessionScopeapplicationScopeparam 获取请求的参数 getParameter()paramValues 获取请求的参数 getParameterValues()header 获取请求头的信息headerValues 获取请求头的信息initParam 获取全局的初始化参数cookie 获取cookiepageContext EL的WEB对象${ param.username } 获取请求头${ header.referer } 获取全局初始化参数${ initParam.username } pageContext对象${ pageContext.request.contextPath } 调用java的方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cookie & session]]></title>
      <url>%2F2017%2F02%2F01%2Fcookie%20session%2F</url>
      <content type="text"><![CDATA[一、JSP、EL表达式的入门Servlet/JSP 是两种动态的WEB资源的两种技术。 使用Servlet生成HTML的页面 response.getWriter(&quot;&lt;form action=&#39;&#39; method=&#39;post&#39;&gt;&quot;); response.getWriter(&quot;&lt;input type=&#39;text&#39; name=&#39;username&#39;&gt;&quot;); JSP简介 java server pages java服务器端的网页们，是在服务器端执行。 JSP不仅可以写HTML+java代码+JSP自己的代码 JSP的运行原理（*）：JSP – 翻译成Servlet – 编译 – 访问 JSP的脚本元素（JSP的页面可以编写java代码） 123&lt;%! %&gt; ：定义类、定义变量、定义方法（不常用） 成员变量。&lt;%= %&gt; ：输出语句（输出到页面，不能有分号）&lt;% %&gt; ：定义变量、语句 12345678910111213&lt;html&gt; &lt;body&gt; &lt;table border="1" width="60%"&gt; &lt;% for(int i=1;i&lt;=10;i++)&#123; %&gt; &lt;tr&gt; &lt;% for(int j=1;j&lt;=10;j++)&#123; %&gt; &lt;td&gt;1&lt;/td&gt; &lt;% &#125; %&gt; &lt;/tr&gt; &lt;% &#125; %&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; EL快速入门 获取域对象中的内容：request.setAttribute(&quot;xx&quot;,&quot;yy&quot;);${xx}1234567&lt;html&gt; &lt;body&gt; &lt;% request.setAttribute("aa", "苍老师"); %&gt; &lt;%= request.getAttribute("aa") %&gt; $&#123; aa &#125; &lt;/body&gt;&lt;/html&gt; 二、JSP的脚本元素三、cookie和session的原理cookie 显示上次的访问时间（案例） 第一次访问，输出欢迎，在服务器端，记录当前的时间，把当前的时间通过cookie回写到浏览器。 第二次访问，会带着上次的时间，获取时间，可以把时间显示到页面上，记录当前的时间，再把回写浏览器。输出上次的访问时间。 Cookie的API 1234567891011121314151617181920* cookie的构造方式 Cookie(String name, String value)* String getName() 获取cookie的名称* String getValue() 获取cookie的值* void setMaxAge(int expiry) ：设置有效时间 * 失效cookie setMaxAge(0); 前提条件：设置有效路径（和之前设置过相同）* void setPath(String uri) ：设置有效路径 * 默认的有效路径（） * 配置 /last 默认路径 /day11 * 配置 /servlet/last 默认路径 /day11/servlet* void setDomain(String pattern) ：设置有效域名 * www.sina.com.cn * sports.sina.com.cn * xxx.sina.com.cn * 设置有效域名 setDomain(&quot;.sian.com.cn&quot;);* 会话级别的cookie：默认保存到浏览器的内存中。* 持久的cookie：把cookie保存到磁盘上。通过setMaxAge(int a)进行设置。 显示用户上次访问过的商品信息（需求） 123456789101.获取请求参数2.获取cookie数组，通过指定的名称（自己指定）查找cookie3.如果cookie==null，第一次访问 * 如果是第一次访问，创建cookie，回写浏览器4.如果cookie!=null，不是第一次访问 * 如果不是第一次访问，说明我的cookie中已经存在id * 判断，当前的id是否已经存在cookie的中value * 如果存在，不用操作 * 如果不存在，在后面追加（product=1,2）5.重定向到商品页面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LastServlet extends HttpServlet &#123; private static final long serialVersionUID = -5604481158386227221L; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * 1.获取所有的cookie，判断是否是第一次访问 * 2.如果是第一次访问 * * 输出欢迎，记录当前的时间，回写到浏览器 * 3.如果不是第一次访问 * * 获取时间，输出到浏览器，记录当前的时间，回写到浏览器。 * 记录当前的时间，回写到浏览器。 */ // 设置字符中文乱码问题 response.setContentType("text/html;charset=UTF-8"); // 获取所有的cookie Cookie [] cookies = request.getCookies(); // 通过指定cookie名称来查找cookie Cookie c = new Cookie("last","当前的时间"); Cookie cookie = MyCookieUtil.getCookieByName(cookies,"last"); // 判断，如果cookie==null，说明是第一次访问 if(cookie == null)&#123; // 输出欢迎，记录当前的时间，回写到浏览器 response.getWriter().write("&lt;h3&gt;亲，欢迎再来哦！！&lt;/h3&gt;"); &#125;else&#123; // 获取cookie的值，输出浏览器，记录当前的时间，回写到浏览器 String value = cookie.getValue(); // 输出浏览器 response.getWriter().write("&lt;h3&gt;亲，您又来了，上次的时间是"+value+"&lt;/h3&gt;"); &#125; // 记录当前的时间 Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String sDate = sdf.format(date); // 回写到浏览器 // 使用cookie回写 Cookie c = new Cookie("last", sDate); // 设置有效时间 c.setMaxAge(60*60); // 秒 // 设置有效路径 c.setPath("/day11"); // 回写 response.addCookie(c); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; session（服务器）123456789101112131415161718192021* cookie基于客户端，不安全，并且大小和个数的限制。* session域对象，范围一次会话范围，存个人相关的数据。 * setAttribute(String name, Object value) * Object getAttribute(String name) * String getId() 获取seesion的唯一的ID * void invalidate() 销毁的seesion* 完成简单的购物车 * 购物车 Map&lt;String,Integer&gt; cart 购物车，把购物车存入seesion中。 * 获取数据 * 判断是否是第一次访问 session.getAttribute(&quot;cart&quot;); * 如果第一次访问，cart 创建一个购物车，放入商品的名称和数量 * 如果不是第一次访问，cart!=null 判断是否包含该商品？ * 如果包含，数量拿出来，++，放回去，存入seesion中 * 如果不包含，正常放入到购物车中。存入seesion中]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[request & response]]></title>
      <url>%2F2017%2F02%2F01%2Frequest%20response%2F</url>
      <content type="text"><![CDATA[缺省的servlet（了解）自己编写的servlet，不要配置/。在tomcat/conf/web.xml中的配置。 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 一、request对象（请求对象）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970ServletRequest |HttpServletRequest获取客户机信息 getRemoteAddr（*****） 获取IP地址 getMethod() （*****） 获取请求方式 getContextPath()（*****） 获取虚拟路径获取请求头信息 String getHeader(String name) long getDateHeader(String name) int getIntHeader(String name) * 请求头 referer 记住当前网页的来源 User-Agent 判断浏览器 if-modified-since 控制缓存获取请求参数（*****） String getParameter(String name) （*****） String[] getParameterValues(String name)（*****） Map getParameterMap()（*****） Enumeration getParameterNames()（用的比较少） 乱码问题解决： * POST请求乱码 ：request.setCharacterEncoding(&quot;utf-8&quot;); * GET请求乱码 解决方案一：修改tomcat/conf/server.xml &lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;utf-8&quot;/&gt; * 必须有修改tomcat服务器配置文件权限 解决方案二：逆向编解码 username = URLEncoder.encode(username, &quot;ISO8859-1&quot;); username = URLDecoder.decode(username, &quot;utf-8&quot;); 解决方案三：简写的方式（推荐使用） username = new String(username.getBytes(&quot;ISO-8859-1&quot;),&quot;utf-8&quot;); * request获取中文数据乱码（总结：） * post提交 * 设置request缓冲区的编码 request.setCharacterEncoding(&quot;utf-8&quot;); * get提交 * String构造方法 username = new String(username.getBytes(&quot;ISO-8859-1&quot;),&quot;utf-8&quot;);利用请求域传递对象（request域对象）重定向和转发的区别（转发）（*****） * 域对象 ServletContext：服务器一启动，为每个web应用创建一个ServletContext对象，所有servlet实例共享对象。 request：一次请求的范围。 * setAttribute(&quot;&quot;,&quot;&quot;); * getAttribute(&quot;&quot;); * removeAttribute(&quot;&quot;); * getRequestDispatcher(String path) ，返回是RequestDispatcher：对象 * RequestDispatcher： * forward(ServletRequest request, ServletResponse response)（经常使用） 转发的方法 * include(ServletRequest request, ServletResponse response)（了解） 包含 二、response对象（响应对象）想要获取客户端的内容，使用request对象。对客户端做出响应使用response对象。 响应： 响应行 状态码 void setStatus(int sc) 设置状态码 响应头（key:value的形式，一个key对应一个value，一个key对应多个value） 设置头信息 void setHeader(String name, String value) （一个key对应一个value）经常使用的 void setHeader(&quot;aa&quot;,&quot;bb&quot;) void setHeader(&quot;aa&quot;,&quot;cc&quot;) 结果：aa:cc void setIntHeader(String name, int value) void setDateHeader(String name, long date) 值是毫秒值（int 秒 long 毫秒） void addHeader(String name, String value) （一个key对应多个value） void addHeader(&quot;aa&quot;,&quot;bb&quot;) void addHeader(&quot;aa&quot;,&quot;cc&quot;) 结果：aa:bb,cc void addIntHeader(String name, int value) void addDateHeader(String name, long date) 响应体ServletOutputStream getOutputStream() 字节输出流PrintWriter getWriter() 字符输出流]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet]]></title>
      <url>%2F2017%2F02%2F01%2FServlet%2F</url>
      <content type="text"><![CDATA[一、快速入门 编写一个类，实现Servlet接口，重写5个方法。 编写一个类，继承GenericServlet类，重写一个方法。 配置文件，配置Servlet信息。 123456789101112131415&lt;!-- 先配置Servlet信息 --&gt;&lt;servlet&gt; &lt;!-- 配置Servlet名称，名称必须唯一 --&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;!-- 配置Servlet的完全路径（包名+类名） --&gt; &lt;servlet-class&gt;cn.itcast.servlet.ServletDemo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 配置Servlet映射（访问路径） --&gt;&lt;servlet-mapping&gt; &lt;!-- 配置Servlet名称，和上面的名称必须相同 --&gt; &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt; &lt;!-- 配置虚拟路径（访问路径） --&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 二、Servlet的生命周期生命周期：实例被创建，对外提供服务，销毁。 Servlet被创建后，调用init方法进行初始化（不是服务器一启动实例就被创建，第一次请求访问时servlet实例才被创建） void init(ServletConfig config) 从客户端发送所有的请求是service方法进行处理的。（有一次请求就调用一次service方法） void service(ServletRequest req, ServletResponse res) 从服务器中移除服务，调用destroy方法。（服务器关闭，手动移除时调用，所以只调用一次） void destroy() Servlet的生命周期：第一次请求的时候，Servlet实例被创建，立即调用init方法进行初始化。实例通过service方法提供服务。服务器关闭或者移除服务时，调用destroy方法进行销毁。 三、Servlet自动加载 Servlet默认是第一次访问时候创建实例。通过配置，服务器启动，创建实例。 init做初始化的操作，非常消耗时间的。 在标签下 &lt;load-on-startup&gt;3&lt;/load-on-startup&gt; 值是正整数 如果值越小，优先级越高。 四、配置虚拟路径（访问路径）123&lt;servlet-mapping&gt; &lt;url-pattern&gt;/demo5&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 1234567891011* 完全路径匹配 * 以/开头的 /demo5 /servlet/demo5 * 访问：http://localhost/day09/demo5* 目录匹配 * 以/开头的 /* * 访问：http://localhost/day09/demo5可以访问* 扩展名匹配 * 不能以/开头的 *.do *.action * 访问：http://localhost/day09/demo5.do* 优先级：完全路径匹配 &gt; 目录匹配 &gt; 扩展名匹配（*****） 五、WEB开发中路径的问题1234567891011121314151617181920212223* 相对路径 * 一个文件相对于另一个文件的位置的关系。 * 不能以/开头 写法： ./demo等价于demo(当前目录) ../demo(上一级目录) * 访问1.html： http://localhost/day09/1.html * 访问demo5： http://localhost/day09/demo5 * 从1.html中去访问demo5：./demo5 demo5 * 访问2.html： http://localhost/day09/html/2.html * 访问demo5： http://localhost/day09/demo5 * 从2.html访问demo5：../demo5* 绝对路径（推荐使用） * 以/开头的 * 访问demo5： http://localhost/day09/demo5 * 从1.html使用绝对路径访问demo5：http://localhost/day09/demo5 * 简写方式：/day09/demo5 * 客户端绝对路径 * /day09/demo5 需要写项目名 * 服务器绝对路径 * /demo5 不能写项目名 六、ervletConfig对象和配置文件相关 配置初始化参数 需要在标签下配置。 如果要是配置在某个servlet的标签下，那么只能在该servlet中获取初始化参数。 username root String getServletName() 获取配置文件中servlet的名称 String getInitParameter(String name) 获取初始化参数 Enumeration getInitParameterNames() 获取初始化参数的名称们 12345678910111213141516protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 测试ServletConfig对象的ApplicationContext // 先获取ServletConfig对象 ServletConfig config = getServletConfig(); // 获取配置文件中Servlet的名称 System.out.println("Servlet的名称"+config.getServletName()); // 获取初始化的参数 String username = config.getInitParameter("username"); Enumeration&lt;String&gt; e = config,getInitParameterNames(); while(e.hasMoreElements())&#123; String name = e.nextElement(); String value = config.getInitParameter(name); System.out.println(name+" : "+value); &#125;&#125; 七、ServletContext对象（域对象）1234567891011121314151617181920212223242526* 定义：WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。一个WEB应用对应一个ServletContext对象一个WEB应用下有多个Servlet程序所有的servlet程序都共享同一个ServletContext对象demo1存入内容 ServletContext demo2中取出来 实现数据共享* 作用： * 获取WEB应用全局初始化参数 * 在web.xml中配置 &lt;context-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;GBK&lt;/param-value&gt; &lt;/context-param&gt; String getInitParameter(String name) getInitParameterNames() * 实现数据的共享（*****） void setAttribute(String name, Object object) 存入数据 void removeAttribute(String name) 删除数据 Object getAttribute(String name) 获取数据 * 读取资源文件（*****） InputStream getResourceAsStream(String path) 通过文件的地址获取输入流 String getRealPath(String path) 通过文件的地址获取文件的绝对磁盘路径 八、HTTP的协议 请求 referer 记住当前网页的来源 user-agent 浏览器版本信息 if-modefied-since 响应 响应头 location 和302一起来完成重定向的操作 refresh 页面的定时刷新 last-modefied 和 if-modefied-since和304状态码一起来控制缓存。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tomcat组成与架构]]></title>
      <url>%2F2017%2F02%2F01%2Ftomcat%E7%BB%84%E6%88%90%E4%B8%8E%E6%9E%B6%E6%9E%84%2F</url>
      <content type="text"><![CDATA[一、Connector参数配置 指定依赖的线程池配置 直接指定线程池配置参数(minSpareThreads maxThreads) 1. port端口 2. address默认在所有的地址上监听请求，使用它来指定只监听哪几个地址 3. protocol默认http1.1，一般只有在涉及性能调优的时候才用 4. connectionTimeout单位ms，如果连接不发请求一定时间后就关闭 5. acceptCount当系统非常繁忙（所有线程都在请求）的时候，如果再来请求怎么办呢？用它来配置队列长度，默认100，如果超过长度，则会拒绝处理后面的请求 6. maxConnections能支持的最大连接数，默认BIO方式的值等于最大线程数。若超过这个数，后面的请求虽然被接受，但不会被处理若为-1，则不限制最大连接数 二、线程池配置项事先创建一定数目的线程。当有任务时，从池中取出，用完后再放回池内。最小空闲线程数minSpareThreads最大线程数maxThreads 三、Tomcat日志 系统运行日志：记录运行信息与状态 访问日志：记录请求访问 应用日志 1234567&lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot; prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot; fileDateFormat=&quot;yyyy-MM-dd.HH.&quot; 默认:yyyy-MM-dd. rotatable=&quot;true&quot; 默认:true pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt; pattern=&quot;method: %m, client ip: %a, time:%t &amp;quot;%r&amp; quot; statusCode: %s, byteSent: %b, User-Agent: %&#123;User-Agent&#125;i&quot; /&gt; 四、附图tomcat架构： tomcat目录结构： server.xml配置：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git常见操作(完整提交步骤)]]></title>
      <url>%2F2017%2F01%2F03%2FGit%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C-%E5%AE%8C%E6%95%B4%E6%8F%90%E4%BA%A4%E6%AD%A5%E9%AA%A4%2F</url>
      <content type="text"><![CDATA[从已有的Git仓库中克隆一个本地的镜像仓库：git clone https://github.com/YourAccountName/name.git 自己新建一个仓库并上传到远程仓库： git init -&gt; 初始化新的仓库 git add README.md -&gt; 将新加入的untracked状态的文件加入跟踪并放入暂存区///将已修改的文件放入暂存区git add . -&gt; 操作所有文件 12345678On branch masterInitial commitChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: a01.txt git commit -m &quot;第一次提交&quot; -&gt; 将暂存区中的文件提交至HEAD所指向的分支，暂存区的文件将回到未修改状态 123[master (root-commit) af05048] 第一次 1 file changed, 3 insertions(+) create mode 100644 a01.txt 其他常见方法：git status -&gt; 查看仓库中文件的状态git rm a01.txt -&gt; 将已跟踪的文件从Git中移除git checkout -- a01.txt -&gt; 恢复被删除的文件(未被commit)git reset HEAD readme.txt -&gt; 恢复被修改的文件(未被commit),并不会更改文件内容，只是使之回到已修改状态git commit --amend -m a01.txt -&gt; 恢复被删除的文件(已被commit) git remote add origin https://github.com/YourAccountName/name.git -&gt; 这样就可以用origin这个名字来引用添加的远程仓库 git fetch origin -&gt; 并不能看到工作目录下有任何变化，只是把远程的数据抓取到本地，而不会把改动合并到当前分支上git pull https://github.com/YourAccountName/name.git -&gt; 把远程仓库抓取到本地，并合并本地master分支 git push -u origin master -&gt; 将本地的数据更新到远程仓库中git push -&gt; 以后直接使用 遇到的错误(慢慢更新……)1. git push origin master12345678To https://github.com/PatrickYates/patrickyates.github.com.git ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to &apos;https://github.com/PatrickYates/patrickyates.github.com.git&apos;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 解决办法：当前的本地仓库不是最新的，应该pull到本地 2. git pull https://github.com/YourAccountName/name.git123From https://github.com/YourAccountName/name.git * branch HEAD -&gt; FETCH_HEADfatal: refusing to merge unrelated histories 123456789&gt;git pull https://github.com/YourAccountName/name.gitwarning: no common commitsremote: Counting objects: 60, done.remote: Compressing objects: 100% (51/51), done.remote: Total 60 (delta 1), reused 60 (delta 1), pack-reused 0Unpacking objects: 100% (60/60), done.From https://github.com/YourAccountName/name.git * branch HEAD -&gt; FETCH_HEADfatal: refusing to merge unrelated histories 解决办法：本地代码与远程仓库代码完全不同，无法合并 其他Github精华教程： 交互编程-15分钟学会github 书籍-重量级教程progit 书籍-git magic 教程-如何高效利用GitHub 教程-git immersion中文版 参考资料 必须要会的Git基本使用及常用命令操作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[reqwest库的使用]]></title>
      <url>%2F2017%2F01%2F03%2Freqwest%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/reqwest/2.0.5/reqwest.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello There!&lt;/h1&gt; &lt;script&gt; var a = &#123;&#125; reqwest(&#123; url:"http://swapi.co/api/people/1/", type:"json", method:"get", data:&#123;tag:"life"&#125;, success:function (resp) &#123; a = resp &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python爬虫爬取极客学院]]></title>
      <url>%2F2017%2F01%2F03%2FPython%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E6%9E%81%E5%AE%A2%E5%AD%A6%E9%99%A2%2F</url>
      <content type="text"><![CDATA[原文：github 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import urllib.request, urllib.parse, os, urllib, http.cookiejar, re# 下载极客学院的视频# 需要一个vip账号(验证邮箱和手机会有体验vip)class DownCourse(object): # 给urllib添加cookie支持 # path: 下载的视频要保存的文件夹 def __init__(self,path): # 初始化一个CookieJar来处理Cookie cookieJar = http.cookiejar.CookieJar() # 实例化一个全局opener opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cookieJar)) # 把这个cookie处理机制装上去,大概是这个意思-.- urllib.request.install_opener(opener) self.folderPath = path # 判断文件夹是否存在 folderExists = os.path.exists(self.folderPath) if not folderExists: os.mkdir(self.folderPath) # 登陆函数 def login(self): # 从登录页面获取登陆参数 login_url = 'http://passport.jikexueyuan.com/sso/login' # 登陆信息发送到这个地址 passport_url = 'http://passport.jikexueyuan.com/submit/login?is_ajax=1' verifyCode_url = 'http://passport.jikexueyuan.com/sso/verify' # 获取登陆页面源码 request = urllib.request.urlopen(login_url) html = request.read() request.close() # 获取登陆要post的数据 expire = re.search(r"(?s)value='(.*?)' name='expire",html) # 验证码 verifyCodeGifPath = '/tmp/jikexueyuan.gif' request = urllib.request.urlopen(verifyCode_url) gif = request.read() request.close() fGif = open(verifyCodeGifPath,'w') fGif.write(gif) fGif.close() # 读取保存到本地的验证码图片 os.system('eog ' + verifyCodeGifPath) verify = input("请输入图中的验证码:") data = &#123; 'expire': expire.group(1), 'referer': 'http%3A%2F%2Fwww.jikexueyuan.com%2F', 'uname': 15850673601, 'password': pengxiaoye, 'verify': verify, &#125; post_data = urllib.parse.urlencode(data) request = urllib.request.Request(passport_url,post_data) # 给一个useragent,防止被认为是爬虫程序 request.add_header('User-Agent', 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.125 Safari/537.36') # 发送登录请求 request = urllib.request.urlopen(request) request.close() print('登陆完成') # courseUrl: 课程地址首页,例如:http://www.jikexueyuan.com/course/989.html def download(self, courseUrl): # 获取课程名称 request = urllib.request.urlopen(courseUrl) coursePageHtml = request.read() request.close() courseName = re.search(r'(?s)&lt;title&gt;(.*?)-',coursePageHtml).group(1) # 课程数量 courseCount = int(re.search(r'(?s)class="timebox"&gt;&lt;span&gt;(.*?)课时',coursePageHtml).group(1)) # 存储视频的文件夹路径 folderPath = self.folderPath + courseName + '/' # 判断文件夹是否存在 folderExists = os.path.exists(folderPath) if not folderExists: os.mkdir(folderPath) print('课程名:' + courseName + ' 课程数量:' + str(courseCount)) # 课程的编号,构建课程的页面地址 i = 0 while i &lt; courseCount: i += 1 pageUrl = courseUrl.split('.html')[0] + '_' + str(i) + '.html?ss=1' # 本节课程的html代码 request = urllib.request.urlopen(pageUrl) pageHtml = request.read() request.close() # 本节课程的名称 name = re.search(r'(?s)&lt;title&gt;(.*?)-',pageHtml).group(1) # 本节课程的视频地址 videoUrl = re.search(r'&lt;source src="(.*?)"',pageHtml) # 有的页面写的课时比实际课时多,会匹配不到视频地址 if videoUrl == None: continue else: videoUrl = videoUrl.group(1) print('正在下载' + name + '...') # 存储视频的Path: 总路径/课程名/每一节的名称 urllib.urlretrieve(videoUrl,folderPath + str(i) + name + '.mp4',self.cbk) print('下载完成') # 从网上下载的可以显示下载进度的函数 # \b是我加的,产生了很奇特的显示效果,还行 def cbk(self,a, b, c): per = 100.0*a*b/c if per &gt; 100: per = 100 print('%.2f%%\b\b\b\b\b\b' % per) def cbk(self,a,b,c): per = 100.0 * a * b /c if per &gt;100: per = 100 print('%.2f%%\b\b\b\b\b\b' % per)# 建立下载对象,参数是即将下载的这些视频放的目录,程序会根据课程名在这个文件夹里面再建文件夹down = DownCourse('/home/geekgao/视频/SpringMVC/')down.login()# 下载一个页面中的所有课程request = urllib.request.urlopen('http://www.jikexueyuan.com/course/springmvc/')html = request.read()request.close()courseUrls = re.findall(r'class="lesson-info-h2"&gt;&lt;a href="(.*?)"',html)for courseUrl in courseUrls: down.download(courseUrl)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python爬虫实战：极客学院]]></title>
      <url>%2F2017%2F01%2F03%2FPython%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%EF%BC%9A%E6%9E%81%E5%AE%A2%E5%AD%A6%E9%99%A2%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#_*_coding:utf-8_*_ from lxml import etree import requests import sys reload(sys) sys.setdefaultencoding("utf-8") #把课程信息保存到info.txt中 def saveinfo(classinfo): f = open('info.txt','a') f.writelines('title:'+ classinfo['title']+'\n') f.writelines('content:' + classinfo['content'] + '\n') f.writelines('classtime:' + classinfo['classtime'] + '\n') f.writelines('classlevel:' + classinfo['classlevel'] + '\n') f.writelines('learnnum:' +classinfo['learnnum'] +'\n\n') f.close() #爬虫主体 def spider(url): html = requests.get(url) #用Requests下载网页 selector = etree.HTML(html.text) #以下用Xpath来解析网页 content_field = selector.xpath('//div[@class="lesson-list"]/ul/li') info = [] for each in content_field: classinfo = &#123;&#125; classinfo['title'] = each.xpath('div[@class="lesson-infor"]/h2[@class="lesson-info-h2"]/a/text()')[0] classinfo['content'] = (each.xpath('div[@class="lesson-infor"]/p/text()')[0]).strip() classTime = (each.xpath('div[@class="lesson-infor"]/div/div/dl/dd[@class="mar-b8"]/em/text()')[0]).split() classinfo['classtime'] = ''.join(classTime) classinfo['classlevel'] = each.xpath('div[@class="lesson-infor"]/div/div/dl/dd[@class="zhongji"]/em/text()')[0] classinfo['learnnum'] = each.xpath('div[@class="lesson-infor"]/div[@class="timeandicon"]/div/em/text()')[0] info.append(classinfo) return info if __name__ == '__main__': print u'开始爬取内容。。。' page = [] #循环用来生产不同页数的链接 for i in range(1,11): newpage = 'http://www.jikexueyuan.com/course/?pageNum=' + str(i) print u"第%d页"%i print u'正在处理页面：'+ newpage page.append(newpage) for each in page: info = spider(each) for each in info: saveinfo(each) #转自Python爬虫实战：极客学院]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python利用百度天气api查询天气数据]]></title>
      <url>%2F2017%2F01%2F03%2Fpython%E5%88%A9%E7%94%A8%E7%99%BE%E5%BA%A6%E5%A4%A9%E6%B0%94api%E6%9F%A5%E8%AF%A2%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[一.说明本次实验的是百度天气的api,网址为：click here查询广州的天气，返回json格式，然后解析内容（上面链接点开就知道了）。(可以使用chrome应用Postman来pretiffy json内容) 二.示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import requestsimport urllib.requestimport http.clientimport json#1.requests内置json解析方法url = 'http://api.map.baidu.com/telematics/v3/weather?location=%E5%B9%BF%E5%B7%9E&amp;output=json&amp;ak=KPGX6sBfBZvz8NlDN5mXDNBF&amp;callback='r = requests.get(url)print("查询日期："+r.json['date'])print("城市："+r.json['results'][0]['currentCity'])print("pm2.5值："+r.json['results'][0]['pm25'])print("\n")for i in range(0,4): print("日期："+r.json['results'][0]['weather_data'][i]['date']) print("天气："+r.json['results'][0]['weather_data'][i]['weather']) print("风力："+r.json['results'][0]['weather_data'][i]['wind']) print("温度："+r.json['results'][0]['weather_data'][i]['temperature']) print("---------------")#2.urllib库 + json库的json.loads()url = 'http://api.map.baidu.com/telematics/v3/weather?location=%E5%B9%BF%E5%B7%9E&amp;output=json&amp;ak=KPGX6sBfBZvz8NlDN5mXDNBF&amp;callback='request = urllib.request.urlopen(url).read().decode('utf8')) #注意必须要.decode('utf8')，不然会有错误：the JSON object must be str, not 'bytes's = json.loads(request)print("查询日期："+s['date'])print("城市："+s['results'][0]['currentCity'])print("pm2.5值："+s['results'][0]['pm25'])print("\n")for i in range(0,4): print("日期："+s['results'][0]['weather_data'][i]['date']) print("天气："+s['results'][0]['weather_data'][i]['weather']) print("风力："+s['results'][0]['weather_data'][i]['wind']) print("温度："+s['results'][0]['weather_data'][i]['temperature']) print("---------------")#3.http.Client库 + json库的json.loads()url = 'http://api.map.baidu.com/telematics/v3/weather?location=%E5%B9%BF%E5%B7%9E&amp;output=json&amp;ak=KPGX6sBfBZvz8NlDN5mXDNBF&amp;callback='httpClient = http.client.HTTPConnection('api.map.baidu.com', 80, timeout=30)httpClient.request('GET', '/telematics/v3/weather?location=%E5%B9%BF%E5%B7%9E&amp;output=json&amp;ak=KPGX6sBfBZvz8NlDN5mXDNBF&amp;callback=')response = httpClient.getresponse()s = json.loads(response.read().decode('utf8')) #注意必须要.decode('utf8')，不然会有错误：the JSON object must be str, not 'bytes'print("查询日期："+s['date'])print("城市："+s['results'][0]['currentCity'])print("pm2.5值："+s['results'][0]['pm25'])print("\n")for i in range(0,4): print("日期："+s['results'][0]['weather_data'][i]['date']) print("天气："+s['results'][0]['weather_data'][i]['weather']) print("风力："+s['results'][0]['weather_data'][i]['wind']) print("温度："+s['results'][0]['weather_data'][i]['temperature']) print("---------------") 三.自己定义json解析函数待解析json片段：1234567891011121314151617181920212223242526272829303132&#123; "showapi_res_code": 0, "showapi_res_error": "", "showapi_res_body": &#123; "pagebean": &#123; "allNum": 5034, "allPages": 252, "contentlist": [ &#123; "code2img": "http://app1.showapi.com/weixin_info/pubNum/xxxxxx.jpg", "id": "55cbfce16e36a9c5946e40b0", "pubNum": "xxxx", "tag": "", "type1_id": "44", "type1_name": "名人明星", "type2_id": "73", "type2_name": "时尚", "userLogo": "http://app1.showapi.com/weixin_info/pubNum/xxxx.jpg", "weiNum": "xxx66 " &#125;, &#123; "code2img": "http://app1.showapi.com/weixin_info/pubNum/xxxx.jpg", "id": "55cbfcdf6e36a9c5946e40ae", "pubNum": "阳西县蓝星半岛旅游度假村", "tag": "添加微信号:xxxx22 ", "type1_id": "47", "type1_name": "生活购物", "type2_id": "100", "type2_name": "旅游", "userLogo": "http://app1.showapi.com/weixin_info/pubNum/xxxx.jpg", "weiNum": "xxxx22" &#125; 函数：12345678910111213141516def json_path(d, path, sep='.'): pp = path.split(sep) t = d for p in pp: if type(t) is dict: t = t[p] elif type(t) is list: t = t[int(p)] else: t = None return timport jsond = json.loads(s)print json_path(d, "showapi_res_body.pagebean.contentlist.1.pubNum") #阳西县蓝星半岛旅游度假村print json_path(d, "showapi_res_code") # 0 四.参考资料 知乎-为什么我已经知道了python的基本语法，可还是不会写个类似天气预报或者能聊天的小软件？ python结合API实现即时天气信息 python 调用 API 获得的JSON如何处理才能获得我想获得的内容呢? 网上的天气 API 哪一个更加可靠？ python day 08获取天气信息.制作天气预报软件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pyquery库的使用]]></title>
      <url>%2F2017%2F01%2F03%2Fpyquery%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[#coding=utf-8 #防止报错：UnicodeEncodeError: ‘gbk’ codec can’t encode characterfrom pyquery import PyQuery as pqfrom lxml import etree 可加载一段HTML字符串，或一个HTML文件，或是一个url地址，或lxml.etree：12345678htmlblock = "&lt;html&gt;&lt;title&gt;hello&lt;/title&gt;&lt;/html&gt;"filename = "path_to_html_file"url = "http://www.baidu.com"d = pq(htmlblock)d = pq(filename)d = pq(url)d = pq(etree.fromstring("&lt;html&gt;&lt;/html&gt;")) 直接输出截取串的html对象，看着更加直观 v_source = pq(url=&apos;http://yunvs.com/list/mai_1.html&apos;) for data in v_source(&apos;tr&apos;): print(pq(data).html()) print(pq(data).text()) #以text文本的方式输出，这样就去掉了html标记 pq(d)(‘a[class= “”]’).attr(‘’)Aurl= pq(data)(&#39;a[class= &quot;j_th_tit &quot; ]&#39;).attr(&#39;href&#39;) 常用方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#1.html()和text() ——获取相应的HTML块或文本块d = pq("&lt;head&gt;&lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;")d('head').html() #返回&lt;title&gt;hello&lt;/title&gt;d('head').text() #返回hello#2.根据HTML标签获取元素。注意：当获取到的元素不只一个时，html()、text()方法只返回首个元素的相应内容块d = pq('&lt;div&gt;&lt;p&gt;test 1&lt;/p&gt;&lt;p&gt;test 2&lt;/p&gt;&lt;/div&gt;')print(d('p')) #返回&lt;p&gt;test 1&lt;/p&gt;&lt;p&gt;test 2&lt;/p&gt;print(d('p').html()) #返回test 1#3.eq(index) ——根据给定的索引号得到指定元素。接上例，若想得到第二个p标签内的内容，则可以：print(d('p').eq(1).html()) #返回test 2#4.filter() ——根据类名、id名得到指定元素，例：d = pq("&lt;div&gt;&lt;p id='1'&gt;test 1&lt;/p&gt;&lt;p class='2'&gt;test 2&lt;/p&gt;&lt;/div&gt;")d('p').filter('#1') #返回[&lt;p#1&gt;]d('p').filter('.2') #返回[&lt;p.2&gt;]#5.find() ——查找嵌套元素，例：d = pq("&lt;div&gt;&lt;p id='1'&gt;test 1&lt;/p&gt;&lt;p class='2'&gt;test 2&lt;/p&gt;&lt;/div&gt;")d('div').find('p')#返回[&lt;p#1&gt;, &lt;p.2&gt;]d('div').find('p').eq(0)#返回[&lt;p#1&gt;]#6.直接根据类名、id名获取元素，例：d = pq("&lt;div&gt;&lt;p id='1'&gt;test 1&lt;/p&gt;&lt;p class='2'&gt;test 2&lt;/p&gt;&lt;/div&gt;")d('#1').html()#返回test 1d('.2').html()#返回test 2#7.获取属性值，例：d = pq("&lt;p id='my_id'&gt;&lt;a href='http://hello.com'&gt;hello&lt;/a&gt;&lt;/p&gt;")d('a').attr('href')#返回http://hello.comd('p').attr('id')#返回my_id#8.修改属性值，例：d('a').attr('href', 'http://baidu.com')把href属性修改为了baidu#9.addClass(value) ——为元素添加类，例：d = pq('&lt;div&gt;&lt;/div&gt;')d.addClass('my_class')#返回[&lt;div.my_class&gt;]#10.hasClass(name) #返回判断元素是否包含给定的类，例：d = pq("&lt;div class='my_class'&gt;&lt;/div&gt;")d.hasClass('my_class')#返回True#11.children(selector=None) ——获取子元素，例：d = pq("&lt;span&gt;&lt;p id='1'&gt;hello&lt;/p&gt;&lt;p id='2'&gt;world&lt;/p&gt;&lt;/span&gt;")d.children()#返回[&lt;p#1&gt;, &lt;p#2&gt;]d.children('#2')#返回[&lt;p#2&gt;]#12.parents(selector=None)——获取父元素，例：d = pq("&lt;span&gt;&lt;p id='1'&gt;hello&lt;/p&gt;&lt;p id='2'&gt;world&lt;/p&gt;&lt;/span&gt;")d('p').parents() #返回[&lt;span&gt;]d('#1').parents('span') #返回[&lt;span&gt;]d('#1').parents('p') #返回[]#13.clone() ——返回一个节点的拷贝#14.empty() ——移除节点内容#15.nextAll(selector=None) ——返回后面全部的元素块，例：d = pq("&lt;p id='1'&gt;hello&lt;/p&gt;&lt;p id='2'&gt;world&lt;/p&gt;&lt;img scr='' /&gt;")d('p:first').nextAll()#返回[&lt;p#2&gt;, &lt;img&gt;]d('p:last').nextAll()#返回[&lt;img&gt;]#16.not_(selector) ——返回不匹配选择器的元素，例：d = pq("&lt;p id='1'&gt;test 1&lt;/p&gt;&lt;p id='2'&gt;test 2&lt;/p&gt;")d('p').not_('#2')#返回[&lt;p#1&gt;] 与requests库结合使用：123456import requestsfrom pyquery import PyQuery as pqr = requests.get('http://www.meipai.com/media/596371059')d = pq(r.content)print(d('meta[property="og:video:url"]').attr('content')) 参考资料PyQuery 1.2.4 complete APIpyquery: 基于python和jquery语法操作XML这一年Python总结Python爬虫利器六之PyQuery的用法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BeautifulSoup库的使用]]></title>
      <url>%2F2017%2F01%2F03%2FBeautifulSoup%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[导入所需包from bs4 import BeautifulSoupsoup = BeautifulSoup(html) 解析顺序‘lxml’-&gt;’html5lib’-&gt;’html.parser’ 对象种类有四种类型：Tag，NavigableString，BeautifulSoup，Comment。BeautifulSoup将文档转化为树形结构，每个节点都是上述四种类型的Python对象。 遍历文档树BeautifulSoup对象作为一棵树，有多个节点。对于一个节点，相对于它所在的位置，有子节点、父节点、兄弟节点。 1. 子节点* 一个Tag可包含多个Tag以及字符串，这些都是这个Tag的子节点。而NavigableString不会有子节点。 * 如果想要获得某个Tag：`soup.tag_name` * 通过点取属性，只能获得当前名字的第一个tag，若要获取所有，需要使用搜索文档树中的方法:`soup.find_all(&apos;tag_name&apos;)` * tag的.contents属性可将所有子节点以列表的方式输出。可通过tag的.children生成器，对所有子节点遍历。 * `.contents`和`.children`只对获取Tag的直接子节点，`.descendants`可对Tag的所有子孙节点遍历。 * 如果tag只有一个NavigableString类型子节点，则可用`.string`获取。如果包含多个，使用`.strings`遍历。若输出的字符串中包含空格或空行，使用`.stripped_strings`去除。 12res = soup.stripped_stringsprint(list(res)) 2. 父节点.parent -&gt; 当前节点的父节点.parents -&gt; 当前节点的所有父辈节点 3. 兄弟节点拥有同一父节点的节点之间：.next_sibling.previous_sibling 所有兄弟节点： `.next_siblings` `.previous_siblings` 指向下一个或上一个解析对象： `.next_element` `.previous_element` `.next_elements` `.previous_elements` 搜索文档树：find(str)和find_all(str) 其中的str，代表了tag的name。可以是纯字符串、正则表达式、列表（任一匹配就满足条件，是或运算）、True（返回所有Tag节点不返回字符串节点）。另一种入参不是str，而是method。此方法是一个函数，只接受一个元素入参，若此函数返回True表示入参匹配要求。例如：def has_class_but_no_id(tag):return tag.has_attr(‘class’) and not tag.has_attr(‘id’)综上，过滤器包括：纯字符串、正则表达式、列表、True、方法这几种。 1. find_all(name,attrs,recursive,text,**kwargs)该方法搜索当前节点的所有tag子节点。 name参数：指的是tag的name属性，字符串对象自动忽略。过滤器可以使用全部种类。 keyword参数：如果一个入参指定了名字，但是并不是上述提到的入参名字，搜索时会把该入参当做是tag的属性来搜索。例如：soup.find_all(id=&#39;link2&#39;)会返回tag中存在属性id，并且id对应的值是link2的tag。以上方法可使用除方法之外的所有过滤器。某些特殊属性不能这样直接使用，则使用如下方法：soup.find_all(attrs={&quot;key&quot;:&quot;value&quot;})例如要使用class属性进行搜索，由于class是python中的保留字，不能直接写成入参，目前有两种方法：soup.findall(‘tag.name’,class=’class_value’)soup.find_all(‘tag.name’,attrs={‘class’:’classvalue’})class方法可以使用全部过滤器。另外，因为class是一个多值属性，所以只需要匹配一个值，就可以得到结果，所谓的不完全匹配。使用完全匹配时，过滤器中的字符顺序需要和实际相符合才能得到对应结果。 text参数：搜索的是Tag中的字符串内容，可使用全部过滤器。 limit参数：限制返回数量。 recursive参数：find_all()默认是搜索当前节点的所有子孙节点，若只需要搜索直接的子节点，则设置recursive=False。 find_all()是实际当中用的最广泛的。因此有了等价的简化版：soup.find_all(&#39;a&#39;)或soup(&#39;a&#39;) 2. find(name,attrs,recursive,text,**kwargs)find()方法等价于find_all(limit=1)，返回符合条件的第一个对象。区别在于，前者直接返回结果，后者返回只有一个元素的列表。若没有对象符合条件，前者返回None，后者返回空列表。简化版：soup.find(&#39;head&#39;).find(&#39;title&#39;)或soup.head.title 除了find()和find_all()之外还有一些搜索的方法： find_parent() find_next_sibling() find_previous_sibling() 上面三种可以在后面加&apos;s&apos;表示所有。 find_next() find_previous() find_all_next() find_all_previous() 3. CSS选择器(.select()方法)Tag或BeautifulSoup对象的.select()方法。res = soup.select(&#39;#wrapperto&#39;) -&gt; tag’s idres = soup.select(&#39;img[src]&#39;) -&gt; ‘img’ tags有’src’ attributesres = soup.select(&#39;img[src=...]&#39;) -&gt; ‘src’ attributes是… 输出 soup.prettify()将文档树格式化之后输出。 若不注重格式，则可使用python的str()或unicode()。 如果想得到tag中包含的文本内容，使用get_text()，可获取到当前节点的文本，以及子孙节点中的文本。返回的是Unicode。 可以指定参数设置分隔符如get_text(&quot;|&quot;)是以“|”作为分隔符。 get_text(strip=True)可去除文本前后的空白。 或者用.stripped_strings进行遍历。获得父级标签下的所有子标签内的文本信息，相当于处理多个文本的高级的get_text()方法 编码1.soup使用Unicode编码。2.BeautifulSoup对象的.original_encoding属性来获取自动识别编码的结果。3.在创建BeautifulSoup对象时，指定入参from_encoding来告知文档的编码方式。4.有时转码时有些特殊字符替换成了特殊的Unicode，可通过BeautifulSoup对象的.contains_repalcement_characters属性来判断是否有此情况，为True即为有特殊替换。5.输出编码统一为UTF8，若想要其他的编码，则和一般的python字符串相同，需要进行手动设置。 完整实例代码123456789101112131415161718192021222324252627import requests,urllib.requestfrom bs4 import BeautifulSoupsource_code = requests.get(url,headers=header)wb_data = source_code.textsoup = BeautifulSoup(wb_data,'lxml')titles = soup.select('body &gt; div.main-content &gt; ul &gt; li &gt; div.article-info &gt; h3 &gt; a')images = soup.select('body &gt; div.main-content &gt; ul &gt; li &gt; img')#获取网页信息for title,image in zip(titles,images): data = &#123; 'title':title.get_text(), 'image':image.get('src') &#125;print(data)#下载download_links = []folder_path = "C:/Users/asus-pc/Desktop"for pic_tag in soup.find_all('img'): pic_link = pic_tag.get('src') download_links.append(pic_link)for item in download_links: urllib.request.urlretrieve(item,folder_path+item[-5:]) print("done!")]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[requests库的使用]]></title>
      <url>%2F2017%2F01%2F03%2Frequests%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[import requests -&gt; 引用模块 1. 发送请求与传递参数带参数请求：12345678910111213141516171819202122#GET参数实例requests.get('http://www.dict.baidu.com/s', params=&#123;'wd': 'python'&#125;) #或url = 'http://www.baidu.com'payload = &#123;'key1': 'value1', 'key2': 'value2'&#125;headers = &#123; "Accept":"text/html,application/xhtml+xml,application/xml;", "Accept-Encoding":"gzip", "Accept-Language":"zh-CN,zh;q=0.8", "Referer":"http://www.example.com/", "User-Agent":"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.90 Safari/537.36" &#125; res1 = requests.get(url, params=payload, headers=headers, timeout=1)#POST参数实例requests.post('http://www.itwhy.org/wp-comments-post.php', data=&#123;'comment': '测试post'&#125;)files = &#123;'file': open('touxiang.png', 'rb')&#125; #用于发送文件的post属性files = &#123;'file': ('xxxx,jpg',open('/home/lyb/sjzl.mpg','rb'))&#125; #设置文件名#或url = 'http://www.baidu.com'data=&#123;"user":"user","password":"pass"&#125;res2 = requests.post(url1, data=data, headers=headers ,files=files) POST发送JSON数据：12345import jsonr = requests.post('https://api.github.com/some/endpoint', data=json.dumps(&#123;'some': 'data'&#125;))print(r.json()) 12r = requests.get('http://ip.taobao.com/service/getIpInfo.php?ip=122.88.60.28')print (r.json()['data']['country']) 添加代理：12345proxies = &#123; "http": "http://10.10.1.10:3128", "https": "http://10.10.1.10:1080",&#125;requests.get("http://www.zhidaow.com", proxies=proxies) 一些操作requests返回值的方法：12345678910111213141516r.text #字符串方式的响应体，会自动根据响应头部的字符编码进行解码r.content #获得二进制响应内容r.raw #获得原始响应内容,需要stream=Truer.raw.read(50)type(r.text) #返回解码成unicode的内容r.urlr.history #追踪重定向r.cookiesr.cookies['example_cookie_name']r.headers #以字典对象存储服务器的响应头，但该字典比较特殊，字典键不区分大小写，若键不存在返回Noner.headers['Content-Type']r.headers.get('content-type')r.json #讲返回内容编码为jsonr.encoding #返回内容编码r.status_code #返回http状态码r.raise_for_status() #返回错误状态码 若编码出错，则r.text.encode(&#39;utf-8&#39;) Session()12345678910#初始化一个session对象s = requests.Session()#使用这个session对象来进行访问prepped1 = requests.Request('POST', url1, data=data, headers=headers).prepare()s.send(prepped1)#或 r = s.post(url,data = user) 其他的一些访问方式： &gt;&gt;&gt; r = requests.put(&quot;http://httpbin.org/put&quot;) &gt;&gt;&gt; r = requests.delete(&quot;http://httpbin.org/delete&quot;) &gt;&gt;&gt; r = requests.head(&quot;http://httpbin.org/get&quot;) &gt;&gt;&gt; r = requests.options(&quot;http://httpbin.org/get&quot;) 总结该笔记描述那么多方面，好像只是讲了requests模块的参数而已。这也说明了它的强大，但是前提是你必须懂对应的原理。参数如下： json: json数据传到requests的body headers: HTTP Headers的字典传到requests的header cookies: 可以使用字典或者CookieJar object files: 字典{&apos;name&apos;: file-tuple} 来实现multipart encoding upload, 2参数元组 (&apos;filename&apos;, fileobj), 3参数元组 (&apos;filename&apos;, fileobj, &apos;content_type&apos;)或者 4参数元组 (&apos;filename&apos;, fileobj, &apos;content_type&apos;, custom_headers), 其中&apos;content-type&apos; 用于定于文件类型和custom_headers文件的headers auth: Auth元组定义用于Basic/Digest/Custom HTTP Auth timeout: 连接等待时长 allow_redirects: 布尔型， True代表POST/PUT/DELETE只有的重定向是允许的 proxies: 代理的地址 verify: 用于认证SSL证书 stream: False代表返回内容立刻下载 cert: String代表ssl client证书地址(.pem) Tuple代表(&apos;cert&apos;, &apos;key&apos;)键值对 其他参考资料：网页数据压缩deflate&amp;gzip]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[lxml学习笔记]]></title>
      <url>%2F2017%2F01%2F03%2Flxml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[问题1：有一个XML文件，如何解析问题2：解析后，如果查找、定位某个标签问题3：定位后如何操作标签，比如访问属性、文本内容等from lxml import etree -&gt; 导入模块，该库常用的XML处理功能都在lxml.etree中 requests + lxml解析小12345678910from lxml import etree import requests page = 1 url = 'http://www.jikexueyuan.com/course/?pageNum=' + str(page) html = requests.get(url) selector = etree.HTML(html.text) content_field = selector.xpath('//div[@class="lesson-list"]/ul/li') print content_field Element类 Element是XML处理的核心类，Element对象可以直观的理解为XML的节点，大部分XML节点的处理都是围绕该类进行的。这部分包括三个内容：节点的操作、节点属性的操作、节点内文本的操作。 1. 节点操作 创建Element对象使用Element方法，参数即节点名称。 123&gt;&gt;&gt; root = etree.Element('root')&gt;&gt;&gt; print(root)&lt;Element root at 0x2da0708&gt; 获取节点名称使用tag属性，获取节点的名称。 12&gt;&gt;&gt; print(root.tag)root 输出XML内容使用tostring方法输出XML内容，参数为Element对象。 12&gt;&gt;&gt; print(etree.tostring(root))b'&lt;root&gt;&lt;child1/&gt;&lt;child2/&gt;&lt;child3/&gt;&lt;/root&gt;' 添加子节点使用SubElement方法创建子节点，第一个参数为父节点（Element对象），第二个参数为子节点名称。 123&gt;&gt;&gt; child1 = etree.SubElement(root, 'child1')&gt;&gt;&gt; child2 = etree.SubElement(root, 'child2')&gt;&gt;&gt; child3 = etree.SubElement(root, 'child3') 删除子节点使用remove方法删除指定节点，参数为Element对象。clear方法清空所有节点。 123456&gt;&gt;&gt; root.remove(child1) # 删除指定子节点&gt;&gt;&gt; print(etree.tostring(root))b'&lt;root&gt;&lt;child2/&gt;&lt;child3/&gt;&lt;/root&gt;'&gt;&gt;&gt; root.clear() # 清除所有子节点&gt;&gt;&gt; print(etree.tostring(root))b'&lt;root/&gt;' 以列表的方式操作子节点可以将Element对象的子节点视为列表进行各种操作： 12345678910111213141516171819202122232425262728&gt;&gt;&gt; child = root[0] # 下标访问&gt;&gt;&gt; print(child.tag)child1&gt;&gt;&gt; print(len(root)) # 子节点数量3&gt;&gt;&gt; root.index(child2) # 获取索引号1&gt;&gt;&gt; for child in root: # 遍历... print(child.tag)child1child2child3&gt;&gt;&gt; root.insert(0, etree.Element('child0')) # 插入&gt;&gt;&gt; start = root[:1] # 切片&gt;&gt;&gt; end = root[-1:]&gt;&gt;&gt; print(start[0].tag)child0&gt;&gt;&gt; print(end[0].tag)child3&gt;&gt;&gt; root.append( etree.Element('child4') ) # 尾部添加&gt;&gt;&gt; print(etree.tostring(root))b'&lt;root&gt;&lt;child0/&gt;&lt;child1/&gt;&lt;child2/&gt;&lt;child3/&gt;&lt;child4/&gt;&lt;/root&gt;' 获取父节点使用getparent方法可以获取父节点。 12&gt;&gt;&gt; print(child1.getparent().tag)root 属性操作属性是以key-value的方式存储的，就像字典一样。 1. 创建属性可以在创建Element对象时同步创建属性，第二个参数即为属性名和属性值：12345678&gt;&gt;&gt; root = etree.Element('root', interesting='totally')&gt;&gt;&gt; print(etree.tostring(root))b'&lt;root interesting="totally"/&gt;'也可以使用set方法给已有的Element对象添加属性，两个参数分别为属性名和属性值：&gt;&gt;&gt; root.set('hello', 'Huhu')&gt;&gt;&gt; print(etree.tostring(root))b'&lt;root interesting="totally" hello="Huhu"/&gt;' 2. 获取属性属性是以key-value的方式存储的，就像字典一样。直接看例子12345678910111213# get方法获得某一个属性值&gt;&gt;&gt; print(root.get('interesting'))totally# keys方法获取所有的属性名&gt;&gt;&gt; sorted(root.keys())['hello', 'interesting']# items方法获取所有的键值对&gt;&gt;&gt; for name, value in sorted(root.items()):... print('%s = %r' % (name, value))hello = 'Huhu'interesting = 'totally' 也可以用attrib属性一次拿到所有的属性及属性值存于字典中：1234567&gt;&gt;&gt; attributes = root.attrib&gt;&gt;&gt; print(attributes)&#123;'interesting': 'totally', 'hello': 'Huhu'&#125;&gt;&gt;&gt; attributes['good'] = 'Bye' # 字典的修改影响节点&gt;&gt;&gt; print(root.get('good'))Bye 文本操作标签及标签的属性操作介绍完了，最后就剩下标签内的文本了。可以使用text和tail属性、或XPath的方式来访问文本内容。 1. text和tail属性一般情况，可以用Element的text属性访问标签的文本。123456&gt;&gt;&gt; root = etree.Element('root')&gt;&gt;&gt; root.text = 'Hello, World!'&gt;&gt;&gt; print(root.text)Hello, World!&gt;&gt;&gt; print(etree.tostring(root))b'&lt;root&gt;Hello, World!&lt;/root&gt;' XML的标签一般是成对出现的，有开有关，但像HTML则可能出现单一的标签，如下面这段代码中的&lt;br/&gt;。 &lt;html&gt;&lt;body&gt;Text&lt;br/&gt;Tail&lt;/body&gt;&lt;/html&gt; Element类提供了tail属性支持单一标签的文本获取。123456789101112131415161718192021&gt;&gt;&gt; html = etree.Element('html')&gt;&gt;&gt; body = etree.SubElement(html, 'body')&gt;&gt;&gt; body.text = 'Text'&gt;&gt;&gt; print(etree.tostring(html))b'&lt;html&gt;&lt;body&gt;Text&lt;/body&gt;&lt;/html&gt;'&gt;&gt;&gt; br = etree.SubElement(body, 'br')&gt;&gt;&gt; print(etree.tostring(html))b'&lt;html&gt;&lt;body&gt;Text&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;'# tail仅在该标签后面追加文本&gt;&gt;&gt; br.tail = 'Tail'&gt;&gt;&gt; print(etree.tostring(br))b'&lt;br/&gt;Tail'&gt;&gt;&gt; print(etree.tostring(html))b'&lt;html&gt;&lt;body&gt;Text&lt;br/&gt;Tail&lt;/body&gt;&lt;/html&gt;'# tostring方法增加method参数，过滤单一标签，输出全部文本&gt;&gt;&gt; print(etree.tostring(html, method='text'))b'TextTail' 2. XPath方式1234567# 方式一：过滤单一标签，返回文本&gt;&gt;&gt; print(html.xpath('string()'))TextTail# 方式二：返回列表，以单一标签为分隔&gt;&gt;&gt; print(html.xpath('//text()'))['Text', 'Tail'] 方法二获得的列表，每个元素都会带上它所属节点及文本类型信息，如下：12345678910111213141516171819&gt;&gt;&gt; texts = html.xpath('//text()'))&gt;&gt;&gt; print(texts[0])Text# 所属节点&gt;&gt;&gt; parent = texts[0].getparent() &gt;&gt;&gt; print(parent.tag)body&gt;&gt;&gt; print(texts[1], texts[1].getparent().tag)Tail br# 文本类型：是普通文本还是tail文本&gt;&gt;&gt; print(texts[0].is_text)True&gt;&gt;&gt; print(texts[1].is_text)False&gt;&gt;&gt; print(texts[1].is_tail)True 文件解析与输出 这部分讲述如何将XML文件解析为Element对象，以及如何将Element对象输出为XML文件。 1. 文件解析文件解析常用的有fromstring、XML和HTML三个方法。接受的参数都是字符串。12345678910111213141516171819202122&gt;&gt;&gt; xml_data = '&lt;root&gt;data&lt;/root&gt;'# fromstring方法&gt;&gt;&gt; root1 = etree.fromstring(xml_data)&gt;&gt;&gt; print(root1.tag)root&gt;&gt;&gt; print(etree.tostring(root1))b'&lt;root&gt;data&lt;/root&gt;'# XML方法，与fromstring方法基本一样&gt;&gt;&gt; root2 = etree.XML(xml_data)&gt;&gt;&gt; print(root2.tag)root&gt;&gt;&gt; print(etree.tostring(root2))b'&lt;root&gt;data&lt;/root&gt;'# HTML方法，如果没有&lt;html&gt;和&lt;body&gt;标签，会自动补上&gt;&gt;&gt; root3 = etree.HTML(xml_data)&gt;&gt;&gt; print(root3.tag)html&gt;&gt;&gt; print(etree.tostring(root3))b'&lt;html&gt;&lt;body&gt;&lt;root&gt;data&lt;/root&gt;&lt;/body&gt;&lt;/html&gt;' 2. 输出输出其实就是前面一直在用的tostring方法了，这里补充xml_declaration和encoding两个参数，前者是XML声明，后者是指定编码。123456789101112&gt;&gt;&gt; root = etree.XML('&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;')&gt;&gt;&gt; print(etree.tostring(root))b'&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;'# XML声明&gt;&gt;&gt; print(etree.tostring(root, xml_declaration=True))b"&lt;?xml version='1.0' encoding='ASCII'?&gt;\n&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;"# 指定编码&gt;&gt;&gt; print(etree.tostring(root, encoding='iso-8859-1'))b"&lt;?xml version='1.0' encoding='iso-8859-1'?&gt;\n&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;" ElementPath讲ElementPath前，需要引入ElementTree类，一个ElementTree对象可理解为一个完整的XML树，每个节点都是一个Element对象。而ElementPath则相当于XML中的XPath。用于搜索和定位Element元素。 这里介绍两个常用方法，可以满足大部分搜索、查询需求，它们的参数都是XPath语句：findall()：返回所有匹配的元素，返回列表find()：返回匹配到的第一个元素1234567891011121314151617&gt;&gt;&gt; root = etree.XML("&lt;root&gt;&lt;a x='123'&gt;aText&lt;b/&gt;&lt;c/&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;")# 查找第一个b标签&gt;&gt;&gt; print(root.find('b'))None&gt;&gt;&gt; print(root.find('a').tag)a# 查找所有b标签，返回Element对象组成的列表&gt;&gt;&gt; [ b.tag for b in root.findall('.//b') ]['b', 'b']# 根据属性查询&gt;&gt;&gt; print(root.findall('.//a[@x]')[0].tag)a&gt;&gt;&gt; print(root.findall('.//a[@y]'))[] 原文地址：Python lxml教程-SKYue 参考资料 用lxml解析HTML Python中利用xpath解析HTML]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[urllib库的常见用法]]></title>
      <url>%2F2017%2F01%2F03%2Furllib%E5%BA%93%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[先导入三个包：123import urllib.requestimport urllib.parseimport http.cookiejar 最简单的urlopen()123url = "http://www.baidu.com" response = urllib.request.urlopen(url)print(response.read()) 1. 构造headers12345user_agent = ''cookie = ''referer = ''host = ''content_type = '' 2. 构造Request实例对象12345url = 'http://www.baidu.com'values = &#123;'name' : 'Michael Foord', 'location' :'Northampton', 'language' :'Python' &#125;headers=&#123;'User-Agent':user_agent,'Cookie':cookie,'Referer':referer,'Host':host,'Content-Type':content_type&#125; 3. HTTP高级方法①使用Proxy代理12proxy_handler = urllib.request.ProxyHandler(&#123;'http': 'http://www.example.com:3128/'&#125;)opener = urllib.request.build_opener(proxy_handler) ②使用cookiejar1234cookie_jar = http.cookiejar.CookieJar()cookie_jar_handler = urllib.request.HTTPCookieProcessor(cookiejar=cookie_jar)opener.add_handler(cookie_jar_handler) ③发送123456# 1.安装全局opener，然后利用urlopen打开url urllib.request.install_opener(opener) response = urllib.request.urlopen(url)# 2.直接利用opener实例打开url:response = opener.open(url) 4. 抓取网页123456789data = urllib.parse.urlencode(values).encode('utf-8') req = urllib.request.Request(url,data,headers)#或req.add_header('Referer', 'http://www.baidu.com')# req.add_header('Origin', 'https://passport.weibo.cn')# req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X)...')response = urllib.request.urlopen(req,timeout=10)the_page = response.read().decode('utf-8') 或者这样：123data = urllib.parse.urlencode(&#123;"act": "login", "email": "xianhu@qq.com", "password": "123456"&#125;)request1 = urllib.request.Request(url,data=data,headers) # POST方法request2 = urllib.request.Request(url+"?%s" % data) # GET方法 其他方法1234#抓取网页中的图片：同样适用于抓取网络上的文件。右击鼠标，找到图片属性中的地址，然后进行保存。response = urllib.request.urlopen("http://ww3.sinaimg.cn/large/7d742c99tw1ee.jpg",timeout=120)with open("test.jpg", "wb") as file_img: file_img.write(response.read()) 123456# HTTP认证：即HTTP身份验证password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm() # 创建一个PasswordMgrpassword_mgr.add_password(realm=None, uri=url, user='username', passwd='password') # 添加用户名和密码handler = urllib.request.HTTPBasicAuthHandler(password_mgr) # 创建HTTPBasicAuthHandleropener = urllib.request.build_opener(handler) # 创建opnerresponse = opener.open(url, timeout=10) # 获取数据 gzip压缩：在header中加入：&#39;request.add_header(&#39;Accept-encoding&#39;, &#39;gzip&#39;)&#39;这是关键:创建Request对象，添加一个 Accept-encoding 头信息告诉服务器你能接受 gzip 压缩数据 然后就是解压缩数据：1234567import StringIOimport gzipcompresseddata = f.read()compressedstream = StringIO.StringIO(compresseddata)gzipper = gzip.GzipFile(fileobj=compressedstream)print gzipper.read() 多线程爬取：1234567891011121314151617181920212223242526272829from threading import Threadfrom Queue import Queuefrom time import sleep# q是任务队列#NUM是并发线程总数#JOBS是有多少任务q = Queue()NUM = 2JOBS = 10#具体的处理函数，负责处理单个任务def do_somthing_using(arguments): print arguments#这个是工作进程，负责不断从队列取数据并处理def working(): while True: arguments = q.get() do_somthing_using(arguments) sleep(1) q.task_done()#fork NUM个线程等待队列for i in range(NUM): t = Thread(target=working) t.setDaemon(True) t.start()#把JOBS排入队列for i in range(JOBS): q.put(i)#等待所有JOBS完成q.join()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用pytesseract识别简单验证码]]></title>
      <url>%2F2017%2F01%2F03%2F%E4%BD%BF%E7%94%A8pytesseract%E8%AF%86%E5%88%AB%E7%AE%80%E5%8D%95%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233from PIL import Imageimport pytesseractfrom pytesseract import *rep=&#123;'O':'0', #替换列表 'I':'1','L':'1', 'Z':'2', 'S':'8' &#125;;def initTable(threshold=140): # 二值化函数 table = [] for i in range(256): if i &lt; threshold: table.append(0) else: table.append(1) return table#--------------------------------------------------------------------------------------im = Image.open('C:/Users/asus-pc/Desktop/Captcha.jpg') #1.打开图片im = im.convert('L') #2.将彩色图像转化为灰度图binaryImage = im.point(initTable(), '1') #3.降噪，图片二值化# binaryImage.show()text = image_to_string(binaryImage, config='-psm 7')#4.对于识别结果，常进行一些替换操作for r in rep: text = text.replace(r,rep[r])#5.打印识别结果print(text) 别人写的123456789101112131415161718192021222324252627282930313233from PIL import Imageimport pytesseractfrom pytesseract import *rep=&#123;'O':'0', #替换列表 'I':'1','L':'1', 'Z':'2', 'S':'8' &#125;;def initTable(threshold=140): # 二值化函数 table = [] for i in range(256): if i &lt; threshold: table.append(0) else: table.append(1) return table#--------------------------------------------------------------------------------------im = Image.open('C:/Users/asus-pc/Desktop/Captcha.jpg') #1.打开图片im = im.convert('L') #2.将彩色图像转化为灰度图binaryImage = im.point(initTable(), '1') #3.降噪，图片二值化# binaryImage.show()text = image_to_string(binaryImage, config='-psm 7')#4.对于识别结果，常进行一些替换操作for r in rep: text = text.replace(r,rep[r])#5.打印识别结果print(text)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[创建Python虚拟环境]]></title>
      <url>%2F2017%2F01%2F03%2F%E5%88%9B%E5%BB%BAPython%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%2F</url>
      <content type="text"><![CDATA[1. 创建python虚拟环境： 最简单地创建python虚拟环境： 1virtualenv [虚拟环境名称] 如果你的系统里安装有不同版本的python，可以使用–python参数指定虚拟环境的python版本 1&gt;&gt; virtualenv [虚拟环境名称] --no-site-packages --python=C:/Users/asus-pc/AppData/Local/Programs/Python/Python35/python.exe 依赖系统环境的第三方软件包： 1&gt;&gt; virtualenv --system-site-packages [虚拟环境名称] 2. 进入虚拟环境目录，启动虚拟环境：123&gt;&gt; cd env1/&gt;&gt; source bin/activate 或 ./Scripts/activate #前面为Linux 后面为Windows&gt;&gt; python -V 3. 退出虚拟环境123&gt;&gt; deactivate或&gt;&gt; ./Scripts/deactivate 使用virtualenvwrapper 安装virtualenvwrapper 创建一个文件夹，用于存放所有的虚拟环境：mkdir ~/workspaces 设置环境变量，把下面两行添加到~/.bashrc里,然后就可以使用virtualenvwrapper了： 12export WORKON_HOME=~/workspacessource /usr/bin/virtualenvwrapper.sh 创建虚拟环境：mkvirtualenv [虚拟环境名称] 列出虚拟环境：lsvirtualenv -b 切换虚拟环境：workon [虚拟环境名称] 查看环境里安装了哪些包：lssitepackages 进入当前环境的目录：cdvirtualenv [子目录名] 进入当前环境的site-packages目录：cdsitepackages [子目录名] 控制环境是否使用global site-packages：toggleglobalsitepackages 复制虚拟环境：cpvirtualenv [source] [dest] 退出虚拟环境：deactivate 删除虚拟环境：rmvirtualenv [虚拟环境名称]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>%2F2017%2F01%2F03%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[python re模块重要函数变量: 1. compile() 根据正则表达式字符串，创建模式的对象。 2. search() 在字符串中寻找模式。 3. match() 在字符串开始处匹配模式。 4. split() 根据模式的匹配项来分割字符串。 5. findall() 显示出字符串中模式的所有匹配项。 6. sub(old,new) 方法的功能是，用将所有old的匹配项用new替换掉。 7. escape() 将字符串中所有特殊正则表达式字符转义。 re.compile:可以把正则表达式编译成一个正则表达式对象。可以把那些经常使用的正则表达式编译成正则表达式对象，这样可以提高一定的效率。 12345import retext = "JGood is a handsome boy, he is cool, clever, and so on..."regex = re.compile(r'\w*oo\w*')print regex.findall(text) #查找所有包含'oo'的单词print regex.sub(lambda m: '[' + m.group(0) + ']', text) #将字符串中含有'oo'的单词用[]括起来。 re.split():会根据模式的匹配项来分割字符串，类似于我们字符串的split方法，不过它是用完整的正则表达式来替代了固定的分隔符。re.split(r&#39;\s+&#39;, text)将字符串按空格分割成一个单词列表。 re.findall:可以获取字符串中所有匹配的字符串。re.findall(r&#39;\w*oo\w*&#39;, text)获取字符串中，包含’oo’的所有单词。 re.sub()用于替换字符串中的匹配项。下面一个例子将字符串中的空格 ‘ ‘ 替换成 ‘-‘ : 123import retext = "JGood is a handsome boy, he is cool, clever, and so on..."print re.sub(r'\s+', '-', text) re.sub的函数原型为：re.sub(pattern, repl, string, count)其中第二个函数是替换后的字符串；本例中为’-‘第四个参数指替换个数。默认为0，表示每个匹配项都替换。re.sub还允许使用函数对匹配项的替换进行复杂的处理。如：re.sub(r&#39;\s&#39;, lambda m: &#39;[&#39; + m.group(0) + &#39;]&#39;, text, 0)将字符串中的空格’ ‘替换为’[ ]’。 re.match():尝试从字符串的开始匹配一个模式，如：下面的例子匹配第一个单词1234567891011121314import retext = "JGood is a handsome boy, he is cool, clever, and so on..."m = re.match(r"(\w+)\s", text)if m:print m.group(0), '\n', m.group(1)else:print 'not match'``` re.match的函数原型为：re.match(pattern, string, flags)第一个参数是正则表达式，这里为"(\w+)\s"，如果匹配成功，则返回一个Match，否则返回一个None；第二个参数表示要匹配的字符串；第三个参数是标致位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。5. `re.search()`:会在字符串内查找模式匹配,只到找到第一个匹配然后返回，若字符串无匹配，则返回None。 `re.search()`的函数原型为:`re.search(pattern, string, flags)`.每个参数的含意与re.match一样。 import retext = “JGood is a handsome boy, he is cool, clever, and so on…”m = re.search(r’\shan(ds)ome\s’, text)if m:print m.group(0), m.group(1)else:print ‘not search’ ``` re.match与re.search的区别：re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 1. (\b)代表着单词的开头或结尾，也就是单词的分界处 2. (.)匹配除了换行符以外的任意字符 3. (*)代表的不是字符，不是位置，而是数量。它指定*前边的内容可连续重复使用任意次以使整个表达式得到匹配 4. 为了避免重复，可以这样写：0\d{2}-\d{8}。这里\d后面的{2}({8})的意思是前面\d必须连续重复匹配2次(8次) 5. (\s)匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等 6. (\w)匹配字母或数字或下划线或汉字等 表1.常用的元字符 代码 说明 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 | 或指明一个非贪婪限定符 \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符 () 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。 [ 标记一个中括号表达式的开始 { 标记限定符表达式的开始 表2.常用的限定符 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次,或指明一个非贪婪限定符 {n} 重复n次 {n,} 重复n次或更多次 {m,n} 重复m到n次 字符转义：使用\来取消这些字符的特殊意义。 字符类：要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。 分枝条件:用|把不同的规则分隔开。 分组：如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)。 表3.常用的反义代码 代码/语法 说明 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 后向引用：用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?\w+)(或者把尖括号换成’也行：(?’Word’\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k,所以上一个例子也可以写成这样：\b(?\w+)\b\s+\k\b。 表4.常用分组语法 分类 代码/语法 说明 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 (?&lt;name&gt;exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?&apos;name&apos;exp) (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配exp前面的位置 (?&lt;=exp) 匹配exp后面的位置 (?!exp) 匹配后面跟的不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 零宽断言：用于查找在某些内容(但并不包括这些内容)之前或之后的东西。(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。(?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。 负向零宽断言：只是想要确保某个字符没有出现，但并不想去匹配它时。零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。同理，我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。 注释:(?#comment) 贪婪与懒惰:贪婪匹配:匹配尽可能多的字符。懒惰匹配:匹配尽可能少的字符。用法：前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。 表5.懒惰限定符 代码/语法 说明 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 表6.常用的处理选项 名称 说明 IgnoreCase(忽略大小写) 匹配时不区分大小写。 Multiline(多行模式) 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.) Singleline(单行模式) 更改.的含义，使它与每一个字符匹配（包括换行符\n）。 IgnorePatternWhitespace(忽略空白) 忽略表达式中的非转义空白并启用由#标记的注释。 ExplicitCapture(显式捕获) 仅捕获已被显式命名的组。 表7.尚未详细讨论的语法 代码/语法 说明 \a 报警字符(打印它的效果是电脑嘀一声) \b 通常是单词分界位置，但如果在字符类里使用代表退格 \t 制表符，Tab \r 回车 \v 竖向制表符 \f 换页符 \n 换行符 \e Escape \0nn ASCII代码中八进制代码为nn的字符 \xnn ASCII代码中十六进制代码为nn的字符 \unnnn Unicode代码中十六进制代码为nnnn的字符 \cN ASCII控制字符。比如\cC代表Ctrl+C \A 字符串开头(类似^，但不受处理多行选项的影响) \Z 字符串结尾或行尾(不受处理多行选项的影响) \z 字符串结尾(类似$，但不受处理多行选项的影响) \G 当前搜索的开头 \p{name} Unicode中命名为name的字符类，例如\p{IsGreek} (?&gt;exp) 贪婪子表达式 (?&lt;x&gt;-&lt;y&gt;exp) 平衡组 (?im-nsx:exp) 在子表达式exp中改变处理选项 (?im-nsx) 为表达式后面的部分改变处理选项 (?(exp)yes|no) 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no (?(exp)yes) 同上，只是使用空表达式作为no (?(name)yes|no) 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no (?(name)yes) 同上，只是使用空表达式作为no]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用codecs模块解决文件编码问题]]></title>
      <url>%2F2017%2F01%2F03%2F%E4%BD%BF%E7%94%A8codecs%E6%A8%A1%E5%9D%97%E8%A7%A3%E5%86%B3%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[错误用例1234567891011# -*- coding: utf-8 -*-#http://www.qiushibaike.com/8hr/page/1?s=4603425import urllib2from bs4 import BeautifulSouppage=1xiubai=open(r'xiubai.txt','w+')for page in range(1,11): url="http://www.qiushibaike.com/8hr/page/"+str(page)+"?s=4603425" soup = BeautifulSoup(urllib2.urlopen(url).read()) for result in soup.findAll("div", "content", title=True): xiubai.write(result.text) 操作文件，读写数据，涉及到非ASCII的话，最好用codes模块操作，其会自动帮你处理不同的编码，效果最好。12345678import codecs;yourStrToSave = "your data string";# 'a+': read,write,append# 'w' : clear before, then writeoutputFp = codecs.open("outputFile.txt", 'w', 'utf-8');outputFp.write(yourStrToSave);outputFp.flush();outputFp.close(); 对于你此处获得html，并用bs处理html的过程，实际上更好的做法： 搞清楚本身html的charset&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; 传递给BeautifulSoup去解析为soupsoup = BeautifuSoup(yourHtml,fromEncoding=&quot;GBK&quot;) 从find处理的soup节点，通过get_text()获得对应的内容 将获得的字符串内容，用codes保存到文件 完整代码123456789import codecs;# 'a+': read,write,append# 'w' : clear before, then writeoutputFp = codecs.open("outputFile.txt", mode='w', encoding='utf-8');for result in soup.findAll("div", "content", title=True): outputFp.write(result.get_text())outputFp.flush();outputFp.close(); 其中，bs中通过get_text()得到的字符串，已经是unicode了]]></content>
    </entry>

    
  
  
</search>
